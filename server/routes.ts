import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
// Phase 39: Replaced old Google Sheets system with stub to prevent crashes
// Old endpoints will return error messages directing users to new /api/sheets/* endpoints
import { storage, googleSheetsService } from "./services/legacy-stub";
import { autoAnalysisService } from "./services/deprecated/auto-analysis";
import { totalReportService } from "./services/reporting/total-report-service";
import { introspectService } from "./services/reporting/introspect-service";
import { generateConsultantReport, getConsultationList, getTrendData, getLeadSourceAverageDetails, type ConsultantReportParams, type PeriodType, type DealStatus, type TrendGrouping } from "./services/consultant-report-service";
import { getOrGenerateConsultantAIReport, type AIReportInput } from "./services/consultant-ai-report-service";
import { devSeedService } from "./services/deprecated/dev-seed-service";
import { reportMetricConfigService } from "./services/reporting/report-metric-config-service";
import { formulaEngine } from "./services/reporting/formula-engine";
import { getAvailableFormulaVariables } from "../configs/report-metric-defaults";
import { getSupabaseClient, isSupabaseAvailable } from "./services/supabase-client";
import { getSharedPool, insertAndReturn, queryDatabase } from "./services/pg-client";

// ä½¿ç”¨å…±äº«é€£ç·šæ± ï¼ˆä¸å†æ¯æ¬¡èª¿ç”¨ pool.end()ï¼‰
const createPool = () => getSharedPool();
import {
  insertSpreadsheetSchema,
  insertWorksheetSchema,
  insertRoleSchema,
  insertCustomDashboardSchema,
  insertCalculationRuleSchema,
  insertDataSourceMappingSchema,
  insertDataSourceRelationshipSchema,
  insertPurchaseRecordSchema,
  insertConsultationRecordSchema,
  insertMultiSourceAnalyticSchema,
  updateDataSourceRelationshipSchema,
  updatePurchaseRecordSchema,
  updateConsultationRecordSchema,
  updateMultiSourceAnalyticSchema,
  enhancedInsertPurchaseRecordSchema,
  enhancedInsertConsultationRecordSchema,
  insertWorksheetAnalysisSchema,
  insertAutoGeneratedReportSchema,
  type WSMessage
} from "@shared/schema";
import { setupAuth, isAuthenticated, requireAdmin, requireActiveUser, initSessionStore } from "./auth";
import { z } from "zod";
import * as teachingQualityGPT from "./services/teaching-quality-gpt-service";
import { registerTeachingQualityRoutes } from "./routes-teaching-quality-new";
import { registerConsultationQualityRoutes } from "./routes-consultation-quality";
import { registerConsultantAIRoutes } from "./routes-consultant-ai";
import { registerEmployeeManagementRoutes } from "./routes-employee-management";
import { registerAuthRoutes } from "./routes-auth";
import { registerKnowItAllRoutes } from "./routes-know-it-all";
import { registerPermissionRoutes, requireModulePermission } from "./routes-permissions";
import { buildPermissionFilter } from "./services/permission-filter-service";
import { apiCache, CACHE_KEYS, CACHE_TTL, APICache } from "./services/api-cache";

export async function registerRoutes(app: Express): Promise<Server> {
  // ğŸ”§ Initialize session store FIRST (test database connection)
  await initSessionStore();

  // Setup authentication (before any routes)
  await setupAuth(app);

  // Health check endpoint for Zeabur
  app.get('/health', (req, res) => {
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: process.env.NODE_ENV || 'development'
    });
  });

  // API health check (used by Zeabur)
  app.get('/api/health', (req, res) => {
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: process.env.NODE_ENV || 'development',
      version: '1.0.0'
    });
  });

  // ======================
  // ä½¿ç”¨è€…ç®¡ç† API
  // ======================

  // å–å¾—æ‰€æœ‰ä½¿ç”¨è€…
  app.get('/api/users', requireAdmin, async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, email, first_name, last_name, role, department, status, created_at, last_login_at, updated_at
         FROM users
         ORDER BY created_at DESC`
      );

      // è™•ç†å¤šé‡è§’è‰²ï¼ˆå¦‚æœæœ‰ roles æ¬„ä½ï¼‰
      const users = result.rows.map((user: any) => ({
        ...user,
        roles: user.role ? [user.role] : [], // æš«æ™‚ç”¨ role ä½œç‚º roles é™£åˆ—
      }));

      res.json({ success: true, users });
    } catch (error: any) {
      console.error('å–å¾—ä½¿ç”¨è€…åˆ—è¡¨å¤±æ•—:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // æ–°å¢ä½¿ç”¨è€…
  app.post('/api/users', isAuthenticated, async (req, res) => {
    try {
      const { email, first_name, last_name, role, roles, department, status } = req.body;

      // é©—è­‰å¿…å¡«æ¬„ä½
      if (!email || !first_name) {
        return res.status(400).json({
          success: false,
          message: 'Email å’Œå§“åç‚ºå¿…å¡«æ¬„ä½',
        });
      }

      // æª¢æŸ¥ email æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await queryDatabase(
        `SELECT id FROM users WHERE email = $1`,
        [email]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: 'æ­¤ Email å·²è¢«ä½¿ç”¨',
        });
      }

      // æ–°å¢ä½¿ç”¨è€…
      const result = await queryDatabase(
        `INSERT INTO users (email, first_name, last_name, role, department, status, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
         RETURNING id, email, first_name, last_name, role, department, status, created_at`,
        [email, first_name, last_name || '', role || 'user', department || '', status || 'active']
      );

      res.json({
        success: true,
        user: result.rows[0],
        message: 'ä½¿ç”¨è€…æ–°å¢æˆåŠŸ',
      });
    } catch (error: any) {
      console.error('æ–°å¢ä½¿ç”¨è€…å¤±æ•—:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // æ›´æ–°ä½¿ç”¨è€…
  app.put('/api/users/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { first_name, last_name, role, roles, department, status } = req.body;

      const result = await queryDatabase(
        `UPDATE users
         SET first_name = $1, last_name = $2, role = $3, department = $4, status = $5, updated_at = NOW()
         WHERE id = $6
         RETURNING id, email, first_name, last_name, role, department, status, created_at, updated_at`,
        [first_name, last_name || '', role || 'user', department || '', status || 'active', id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'ä½¿ç”¨è€…ä¸å­˜åœ¨',
        });
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: 'ä½¿ç”¨è€…æ›´æ–°æˆåŠŸ',
      });
    } catch (error: any) {
      console.error('æ›´æ–°ä½¿ç”¨è€…å¤±æ•—:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // åˆªé™¤ä½¿ç”¨è€…
  app.delete('/api/users/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(
        `DELETE FROM users WHERE id = $1 RETURNING id`,
        [id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'ä½¿ç”¨è€…ä¸å­˜åœ¨',
        });
      }

      res.json({
        success: true,
        message: 'ä½¿ç”¨è€…åˆªé™¤æˆåŠŸ',
      });
    } catch (error: any) {
      console.error('åˆªé™¤ä½¿ç”¨è€…å¤±æ•—:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // Authentication already setup at the top of registerRoutes

  const httpServer = createServer(app);
  
  app.get('/api/status', async (_req, res) => {
    try {
      const [spreadsheets, worksheets] = await Promise.all([
        storage.listSpreadsheets(),
        storage.getAllWorksheets(),
      ]);

      const worksheetsBySheetId = worksheets.reduce<Record<string, any[]>>((acc, worksheet) => {
        const list = acc[worksheet.spreadsheetId] || [];
        list.push(worksheet);
        acc[worksheet.spreadsheetId] = list;
        return acc;
      }, {});

      const dataSources = spreadsheets.map((sheet) => {
        const sheetWorksheets = worksheetsBySheetId[sheet.spreadsheetId] || [];
        const isActive = sheetWorksheets.some((worksheet) => worksheet.isEnabled);

        return {
          id: sheet.id,
          name: sheet.name,
          type: 'spreadsheet',
          isActive,
          lastSyncAt: toIsoString(sheet.lastSyncAt ?? sheet.createdAt ?? null) ?? new Date().toISOString(),
        };
      });

      const totalRowCount = spreadsheets.reduce(
        (total, sheet) => total + (sheet.rowCount ?? 0),
        0,
      );

      res.json({
        success: true,
        data: {
          status: 'healthy',
          lastUpdated: new Date().toISOString(),
          dataSourcesCount: dataSources.length,
          stats: {
            spreadsheetCount: spreadsheets.length,
            worksheetCount: worksheets.length,
            totalRowCount,
          },
          dataSources,
        },
      });
    } catch (error) {
      console.error('Error fetching system status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch system status',
      });
    }
  });

  // WebSocket server disabled for security - needs proper session parsing
  // TODO: Implement proper WebSocket authentication with session parsing
  const wss = null;

  // WebSocket functionality temporarily disabled for security
  const adminClients = new Map();

  // Broadcast disabled - WebSocket functionality needs security improvements
  function broadcast(message: WSMessage) {
    // TODO: Re-enable when WebSocket auth is properly implemented
    console.log('Broadcast message:', message.type, 
      'status' in message ? message.status : undefined,
      'message' in message ? message.message : undefined
    );
  }

  // ===== Dashboard API Routes =====
  
  // Dashboard Templates (admin only)
  app.get('/api/dashboards/templates', async (req, res) => {
    try {
      const templates = await storage.listActiveDashboardTemplates();
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error('Error fetching dashboard templates:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/templates/:id', async (req, res) => {
    try {
      const template = await storage.getDashboardTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }
      res.json({ success: true, data: template });
    } catch (error) {
      console.error('Error fetching dashboard template:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/templates/type/:type', async (req, res) => {
    try {
      const template = await storage.getDashboardTemplateByType(req.params.type);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }
      res.json({ success: true, data: template });
    } catch (error) {
      console.error('Error fetching dashboard template by type:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Custom Dashboards (admin only)
  app.get('/api/dashboards', async (req, res) => {
    try {
      const userId = req.query.userId as string;
      const dashboards = await storage.listCustomDashboards(userId);
      res.json({ success: true, data: dashboards });
    } catch (error) {
      console.error('Error fetching custom dashboards:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/:id', async (req, res) => {
    try {
      const dashboard = await storage.getCustomDashboard(req.params.id);
      if (!dashboard) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Error fetching dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/dashboards', async (req, res) => {
    console.log('Dashboard creation request received:', {
      body: req.body,
      user: req.user ? { sub: (req.user as any).claims?.sub } : 'no user'
    });

    try {
      const user = req.user as any;
      if (!user || !user.claims || !user.claims.sub) {
        console.error('No authenticated user found for dashboard creation');
        return res.status(401).json({ success: false, error: 'User not authenticated' });
      }

      const userId = user.claims.sub;
      console.log('Creating dashboard for user:', userId);

      // Parse request body but override userId with authenticated user
      const { userId: _, ...requestData } = req.body;
      console.log('Request data before validation:', requestData);

      const parsedData = insertCustomDashboardSchema.parse({
        ...requestData,
        userId: userId
      });
      console.log('Parsed data after validation:', parsedData);

      const dashboard = await storage.createCustomDashboard(parsedData);
      console.log('Dashboard created successfully:', dashboard.id);
      res.status(201).json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Dashboard creation error:', error);
      if (error instanceof z.ZodError) {
        console.error('Validation errors:', error.errors);
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/dashboards/:id', async (req, res) => {
    try {
      const updates = req.body;
      const updatedDashboard = await storage.updateCustomDashboard(req.params.id, updates);
      if (!updatedDashboard) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.json({ success: true, data: updatedDashboard });
    } catch (error) {
      console.error('Error updating dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/dashboards/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteCustomDashboard(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Create dashboard from template
  app.post('/api/dashboards/from-template', async (req, res) => {
    try {
      const user = req.user as any;
      if (!user || !user.claims || !user.claims.sub) {
        return res.status(401).json({ success: false, error: 'User not authenticated' });
      }
      
      const { templateId } = req.body;
      if (!templateId) {
        return res.status(400).json({ success: false, error: 'Template ID is required' });
      }

      // ç²å–æ¨¡æ¿
      const template = await storage.getDashboardTemplate(templateId);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Template not found' });
      }

      // å¾æ¨¡æ¿å‰µå»ºå„€è¡¨æ¿
      const dashboardData = {
        templateId: template.id,
        userId: user.claims.sub,
        name: `${template.displayName} - ${new Date().toLocaleDateString('zh-TW')}`,
        description: `åŸºæ–¼${template.displayName}æ¨¡æ¿å‰µå»ºçš„å„€è¡¨æ¿`,
        config: {
          ...template.config,
          // ä¿æŒæ¨¡æ¿çš„é…ç½®ä½†æ¨™è¨˜ç‚ºç”¨æˆ¶è‡ªå®šç¾©
          isFromTemplate: true,
          originalTemplateId: template.id
        },
        isPublic: false
      };

      const dashboard = await storage.createCustomDashboard(dashboardData);
      res.status(201).json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Error creating dashboard from template:', error);
      res.status(500).json({ success: false, error: 'Failed to create dashboard from template' });
    }
  });

  // Calculation Rules (admin only)
  app.get('/api/calculations', async (req, res) => {
    try {
      const category = req.query.category as string;
      const rules = await storage.listCalculationRules(category);
      res.json({ success: true, data: rules });
    } catch (error) {
      console.error('Error fetching calculation rules:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/calculations/active', async (req, res) => {
    try {
      const rules = await storage.listActiveCalculationRules();
      res.json({ success: true, data: rules });
    } catch (error) {
      console.error('Error fetching active calculation rules:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/calculations/:id', async (req, res) => {
    try {
      const rule = await storage.getCalculationRule(req.params.id);
      if (!rule) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.json({ success: true, data: rule });
    } catch (error) {
      console.error('Error fetching calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/calculations', async (req, res) => {
    try {
      const parsedData = insertCalculationRuleSchema.parse(req.body);
      const rule = await storage.createCalculationRule(parsedData);
      res.status(201).json({ success: true, data: rule });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/calculations/:id', async (req, res) => {
    try {
      const updates = req.body;
      const rule = await storage.updateCalculationRule(req.params.id, updates);
      if (!rule) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.json({ success: true, data: rule });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error updating calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/calculations/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteCalculationRule(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Data Source Mappings (admin only)
  app.get('/api/datasources', async (req, res) => {
    try {
      const mappings = await storage.listActiveDataSourceMappings();
      res.json({ success: true, data: mappings });
    } catch (error) {
      console.error('Error fetching data source mappings:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/datasources/:id', async (req, res) => {
    try {
      const mapping = await storage.getDataSourceMapping(req.params.id);
      if (!mapping) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.json({ success: true, data: mapping });
    } catch (error) {
      console.error('Error fetching data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/datasources', async (req, res) => {
    try {
      const parsedData = insertDataSourceMappingSchema.parse(req.body);
      const mapping = await storage.createDataSourceMapping(parsedData);
      res.status(201).json({ success: true, data: mapping });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/datasources/:id', async (req, res) => {
    try {
      const parsedData = insertDataSourceMappingSchema.partial().parse(req.body);
      const mapping = await storage.updateDataSourceMapping(req.params.id, parsedData);
      if (!mapping) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.json({ success: true, data: mapping });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error updating data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/datasources/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteDataSourceMapping(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Core Metrics API - æ ¸å¿ƒæŒ‡æ¨™ç³»çµ± (admin only)
  app.get('/api/analytics/core-metrics', async (req, res) => {
    try {
      // Get data from experience course records worksheet
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Calculate core business metrics
      const coreMetrics = {
        // é«”é©—ä¸­å­¸ç”Ÿæ•¸é‡ (Total Experience Students)
        totalExperienceStudents: experienceData.length,
        
        // ä¸Šèª²ä¸­å­¸ç”Ÿæ•¸é‡ (Students Currently in Class)
        activeStudents: experienceData.filter(row => 
          row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯'
        ).length,
        
        // æœªç¢ºèªå­¸ç”Ÿæ•¸é‡ (Unconfirmed Students)
        unconfirmedStudents: experienceData.filter(row => 
          row.data['æ˜¯å¦å·²ç¢ºèª'] !== 'æ˜¯' && row.data['æ˜¯å¦å·²ç¢ºèª'] !== ''
        ).length,
        
        // å¾…è¯ç¹«å­¸ç”Ÿæ•¸é‡ (Students Pending Contact)
        pendingContactStudents: experienceData.filter(row => 
          row.data['æœªè¯ç¹«åŸå› '] && row.data['æœªè¯ç¹«åŸå› '] !== ''
        ).length,
        
        // æŒ‰æˆèª²è€å¸«åˆ†çµ„çµ±è¨ˆ
        teacherStats: experienceData.reduce((acc, row) => {
          const teacher = row.data['æˆèª²è€å¸«'] || 'æœªåˆ†é…';
          if (!acc[teacher]) {
            acc[teacher] = { total: 0, confirmed: 0 };
          }
          acc[teacher].total++;
          if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
            acc[teacher].confirmed++;
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number }>),
        
        // æœˆåº¦è¶¨å‹¢åˆ†æ
        monthlyTrend: experienceData.reduce((acc, row) => {
          const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
          if (dateStr) {
            try {
              const date = new Date(dateStr);
              const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
              if (!acc[monthKey]) {
                acc[monthKey] = { total: 0, confirmed: 0 };
              }
              acc[monthKey].total++;
              if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
                acc[monthKey].confirmed++;
              }
            } catch (error) {
              // Skip invalid dates
            }
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number }>),
        
        // ç¢ºèªç‡çµ±è¨ˆ
        confirmationRate: experienceData.length > 0 
          ? ((experienceData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length / experienceData.length) * 100).toFixed(1)
          : '0.0',
        
        // æœ€è¿‘æ›´æ–°æ™‚é–“
        lastUpdated: new Date(),
        
        // æ•¸æ“šæºä¿¡æ¯
        dataSource: {
          worksheetId: '110563615',
          worksheetName: 'é«”é©—èª²ä¸Šèª²è¨˜éŒ„è¡¨',
          totalRows: experienceData.length,
          lastSyncTime: new Date()
        }
      };

      res.json({ success: true, data: coreMetrics });
    } catch (error) {
      console.error('Error calculating core metrics:', error);
      res.status(500).json({ success: false, error: 'Failed to calculate core metrics' });
    }
  });

  // Executive Dashboard Summary - ç®¡ç†å±¤å„€è¡¨æ¿ç¸½è¦½ (admin only)
  app.get('/api/analytics/executive-summary', async (req, res) => {
    try {
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Calculate time-based comparisons
      const now = new Date();
      const last30Days = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const last7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      
      const recentData = experienceData.filter(row => {
        const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= last30Days;
        } catch {
          return false;
        }
      });
      
      const weeklyData = experienceData.filter(row => {
        const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= last7Days;
        } catch {
          return false;
        }
      });

      // Core metrics for executive summary
      const totalStudents = experienceData.length;
      const confirmedStudents = experienceData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length;
      const recentConfirmed = recentData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length;
      const weeklyConfirmed = weeklyData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length;
      
      // Calculate teacher performance rankings
      const teacherPerformance = Object.entries(
        experienceData.reduce((acc, row) => {
          const teacher = row.data['æˆèª²è€å¸«'] || 'æœªåˆ†é…';
          if (!acc[teacher]) {
            acc[teacher] = { total: 0, confirmed: 0, recent: 0, recentConfirmed: 0 };
          }
          acc[teacher].total++;
          if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
            acc[teacher].confirmed++;
          }
          
          // Check if this is recent data
          const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
          if (dateStr) {
            try {
              const rowDate = new Date(dateStr);
              if (rowDate >= last30Days) {
                acc[teacher].recent++;
                if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
                  acc[teacher].recentConfirmed++;
                }
              }
            } catch {
              // Skip invalid dates
            }
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number; recent: number; recentConfirmed: number }>)
      ).map(([teacher, stats]) => ({
        teacher,
        totalStudents: stats.total,
        totalConfirmed: stats.confirmed,
        recentStudents: stats.recent,
        recentConfirmed: stats.recentConfirmed,
        overallRate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0.0',
        recentRate: stats.recent > 0 ? (stats.recentConfirmed / stats.recent * 100).toFixed(1) : '0.0'
      }));

      const executiveSummary = {
        // æ ¸å¿ƒæ¥­å‹™æŒ‡æ¨™ (Core Business Metrics)
        coreMetrics: {
          totalExperienceStudents: totalStudents,
          totalConfirmedStudents: confirmedStudents,
          overallConfirmationRate: totalStudents > 0 ? (confirmedStudents / totalStudents * 100).toFixed(1) : '0.0',
          
          // æˆäº¤å­¸ç”Ÿæ•¸é‡ (é ç•™å¾…è³¼è²·æ•¸æ“šæ¥å…¥)
          totalPurchasingStudents: 0, // Will be calculated when purchase data is available
          
          // ç¸½æˆäº¤é‡‘é¡ (é ç•™å¾…è³¼è²·æ•¸æ“šæ¥å…¥)  
          totalRevenue: 0, // Will be calculated when purchase data is available
          
          // è¿‘æœŸè¡¨ç¾ (Recent Performance)
          recentPerformance: {
            last30Days: {
              newStudents: recentData.length,
              confirmedStudents: recentConfirmed,
              confirmationRate: recentData.length > 0 ? (recentConfirmed / recentData.length * 100).toFixed(1) : '0.0'
            },
            last7Days: {
              newStudents: weeklyData.length,
              confirmedStudents: weeklyConfirmed,
              confirmationRate: weeklyData.length > 0 ? (weeklyConfirmed / weeklyData.length * 100).toFixed(1) : '0.0'
            }
          }
        },
        
        // æ•™å¸«ç¸¾æ•ˆæ’è¡Œ (Teacher Performance Rankings)
        teacherRankings: {
          topPerformers: teacherPerformance
            .filter(t => t.totalStudents >= 3) // Only include teachers with significant data
            .sort((a, b) => parseFloat(b.overallRate) - parseFloat(a.overallRate))
            .slice(0, 5),
          
          recentTopPerformers: teacherPerformance
            .filter(t => t.recentStudents >= 2) // Recent activity threshold
            .sort((a, b) => parseFloat(b.recentRate) - parseFloat(a.recentRate))
            .slice(0, 5)
        },
        
        // æ¥­å‹™æ´å¯Ÿ (Business Insights)
        businessInsights: {
          totalTeachers: teacherPerformance.length,
          activeTeachers: teacherPerformance.filter(t => t.recentStudents > 0).length,
          studentsNeedingAttention: experienceData.filter(row => 
            row.data['æ˜¯å¦å·²ç¢ºèª'] !== 'æ˜¯' && 
            (!row.data['æœªè¯ç¹«åŸå› '] || row.data['æœªè¯ç¹«åŸå› '] === '')
          ).length,
          
          // å¢é•·è¶¨å‹¢æŒ‡æ¨™
          growthIndicators: {
            weeklyGrowth: weeklyData.length,
            monthlyGrowth: recentData.length,
            confirmationTrend: {
              improving: false, // Will be calculated with historical comparison
              stable: true,
              declining: false
            }
          }
        },
        
        // ç³»çµ±ç‹€æ…‹
        systemStatus: {
          dataFreshness: 'Live', // Real-time from Google Sheets
          lastSyncTime: new Date(),
          totalDataPoints: totalStudents,
          dataQuality: {
            completeName: experienceData.filter(row => row.data['å§“å'] && row.data['å§“å'] !== '').length,
            completeEmail: experienceData.filter(row => row.data['email'] && row.data['email'] !== '').length,
            completeDate: experienceData.filter(row => row.data['ä¸Šèª²æ—¥æœŸ'] && row.data['ä¸Šèª²æ—¥æœŸ'] !== '').length,
            dataIntegrityScore: ((
              experienceData.filter(row => row.data['å§“å'] && row.data['å§“å'] !== '').length +
              experienceData.filter(row => row.data['email'] && row.data['email'] !== '').length +
              experienceData.filter(row => row.data['ä¸Šèª²æ—¥æœŸ'] && row.data['ä¸Šèª²æ—¥æœŸ'] !== '').length
            ) / (totalStudents * 3) * 100).toFixed(1)
          }
        },
        
        lastUpdated: new Date()
      };

      res.json({ success: true, data: executiveSummary });
    } catch (error) {
      console.error('Error generating executive summary:', error);
      res.status(500).json({ success: false, error: 'Failed to generate executive summary' });
    }
  });

  // Enhanced Analytics for specific business needs
  app.get('/api/analytics/business-insights', async (req, res) => {
    try {
      const { timeRange = '30' } = req.query;
      const days = parseInt(timeRange as string) || 30;
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Filter data by time range
      const recentData = experienceData.filter(row => {
        const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= cutoffDate;
        } catch {
          return false;
        }
      });

      const insights = {
        timeRange: `Last ${days} days`,
        period: {
          from: cutoffDate.toISOString().split('T')[0],
          to: new Date().toISOString().split('T')[0]
        },
        
        // æ ¸å¿ƒæŒ‡æ¨™ (Core Metrics)
        metrics: {
          newExperienceStudents: recentData.length,
          confirmedStudents: recentData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length,
          conversionRate: recentData.length > 0 
            ? ((recentData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯').length / recentData.length) * 100).toFixed(1)
            : '0.0'
        },
        
        // æˆèª²è€å¸«ç¸¾æ•ˆ (Teacher Performance)
        teacherPerformance: Object.entries(
          recentData.reduce((acc, row) => {
            const teacher = row.data['æˆèª²è€å¸«'] || 'æœªåˆ†é…';
            if (!acc[teacher]) {
              acc[teacher] = { students: 0, confirmed: 0, conversionRate: 0 };
            }
            acc[teacher].students++;
            if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
              acc[teacher].confirmed++;
            }
            acc[teacher].conversionRate = acc[teacher].students > 0 
              ? (acc[teacher].confirmed / acc[teacher].students * 100) 
              : 0;
            return acc;
          }, {} as Record<string, { students: number; confirmed: number; conversionRate: number }>)
        ).map(([teacher, stats]) => ({
          teacher,
          ...stats,
          conversionRate: parseFloat(stats.conversionRate.toFixed(1))
        })).sort((a, b) => b.conversionRate - a.conversionRate),
        
        // éœ€è¦é—œæ³¨çš„å­¸ç”Ÿ (Students Requiring Attention)
        attentionRequired: {
          uncontactedStudents: recentData.filter(row => 
            row.data['æ˜¯å¦å·²ç¢ºèª'] !== 'æ˜¯' && 
            (!row.data['æœªè¯ç¹«åŸå› '] || row.data['æœªè¯ç¹«åŸå› '] === '')
          ).length,
          
          studentsWithContactIssues: recentData.filter(row => 
            row.data['æœªè¯ç¹«åŸå› '] && row.data['æœªè¯ç¹«åŸå› '] !== ''
          ).length
        },
        
        lastUpdated: new Date()
      };

      res.json({ success: true, data: insights });
    } catch (error) {
      console.error('Error generating business insights:', error);
      res.status(500).json({ success: false, error: 'Failed to generate business insights' });
    }
  });

  // Dashboard Analytics with Real Data (admin only)
  app.get('/api/analytics/dashboard/:templateType', async (req, res) => {
    try {
      const { templateType } = req.params;
      const template = await storage.getDashboardTemplateByType(templateType);
      
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }

      // Get real metrics data based on template type
      let metricsData: {
        templateId: string;
        templateName: string;
        metrics: Array<{
          id: string;
          name: string;
          value: string | number;
          chartType: string;
          position: { x: number; y: number; w: number; h: number };
        }>;
        lastUpdated: Date;
      } = {
        templateId: template.id,
        templateName: template.name,
        metrics: [],
        lastUpdated: new Date()
      };

      switch (templateType) {
        case 'experience_customers':
          // Get comprehensive metrics from core metrics system
          const experienceData = await storage.getWorksheetData('110563615');
          const totalStudents = experienceData.length;
          const confirmedStudents = experienceData.filter(row => row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯');
          const unconfirmedStudents = experienceData.filter(row => 
            row.data['æ˜¯å¦å·²ç¢ºèª'] !== 'æ˜¯' && row.data['æ˜¯å¦å·²ç¢ºèª'] !== ''
          );
          
          // Calculate teacher performance for charts
          const teacherStats = experienceData.reduce((acc, row) => {
            const teacher = row.data['æˆèª²è€å¸«'] || 'æœªåˆ†é…';
            if (!acc[teacher]) {
              acc[teacher] = { total: 0, confirmed: 0 };
            }
            acc[teacher].total++;
            if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
              acc[teacher].confirmed++;
            }
            return acc;
          }, {} as Record<string, { total: number; confirmed: number }>);
          
          // Calculate monthly trend for the trend chart
          const monthlyData = experienceData.reduce((acc, row) => {
            const dateStr = row.data['ä¸Šèª²æ—¥æœŸ'];
            if (dateStr) {
              try {
                const date = new Date(dateStr);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!acc[monthKey]) {
                  acc[monthKey] = { total: 0, confirmed: 0 };
                }
                acc[monthKey].total++;
                if (row.data['æ˜¯å¦å·²ç¢ºèª'] === 'æ˜¯') {
                  acc[monthKey].confirmed++;
                }
              } catch (error) {
                // Skip invalid dates
              }
            }
            return acc;
          }, {} as Record<string, { total: number; confirmed: number }>);
          
          metricsData.metrics = template.config.metrics.map(metric => {
            let value: string | number = 0;
            let chartData: any = undefined;
            
            switch (metric.id) {
              case 'total_students':
                value = totalStudents;
                break;
              case 'active_students':
                value = confirmedStudents.length;
                break;
              case 'conversion_rate':
                value = totalStudents > 0 
                  ? ((confirmedStudents.length / totalStudents) * 100).toFixed(1) + '%'
                  : '0.0%';
                break;
              case 'monthly_trend':
                // Provide trend data for chart
                value = Object.keys(monthlyData).length;
                chartData = Object.entries(monthlyData)
                  .sort(([a], [b]) => a.localeCompare(b))
                  .map(([month, stats]) => ({
                    month,
                    total: stats.total,
                    confirmed: stats.confirmed,
                    rate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0'
                  }));
                break;
              case 'teacher_performance':
                // Provide teacher performance data for chart
                value = Object.keys(teacherStats).length;
                chartData = Object.entries(teacherStats)
                  .map(([teacher, stats]) => ({
                    teacher,
                    total: stats.total,
                    confirmed: stats.confirmed,
                    rate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0'
                  }))
                  .sort((a, b) => parseFloat(b.rate) - parseFloat(a.rate));
                break;
              default:
                value = Math.floor(Math.random() * 100);
            }
            
            return {
              id: metric.id,
              name: metric.name,
              value,
              chartType: metric.chartType,
              position: metric.position,
              chartData
            };
          });
          break;
          
        case 'sales_performance':
          // Mock sales data for now - will connect to purchase records later
          metricsData.metrics = template.config.metrics.map(metric => ({
            id: metric.id,
            name: metric.name,
            value: metric.id === 'total_revenue' ? 'Â¥' + (Math.floor(Math.random() * 100000) + 50000).toLocaleString() :
                   metric.id === 'total_purchases' ? Math.floor(Math.random() * 200) + 50 :
                   metric.id === 'avg_order_value' ? 'Â¥' + (Math.floor(Math.random() * 5000) + 1000).toLocaleString() :
                   Math.floor(Math.random() * 100),
            chartType: metric.chartType,
            position: metric.position
          }));
          break;
          
        default:
          // Generic mock data for other templates
          metricsData.metrics = template.config.metrics.map(metric => ({
            id: metric.id,
            name: metric.name,
            value: Math.floor(Math.random() * 1000),
            chartType: metric.chartType,
            position: metric.position
          }));
      }

      res.json({ success: true, data: metricsData });
    } catch (error) {
      console.error('Error generating dashboard analytics:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Authentication API routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      res.json({ success: true, data: user });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ success: false, error: "Failed to fetch user" });
    }
  });

  // User management API routes (Admin only)
  // REMOVED: Duplicate /api/users route - using the one at line 62 instead

  app.patch('/api/users/:id/role', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { role, department } = req.body;
      
      if (!role) {
        return res.status(400).json({ success: false, error: "Role is required" });
      }
      
      // Validate role exists
      const validRoles = ['admin', 'manager', 'staff', 'user'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }
      
      const updatedUser = await storage.updateUserRole(id, role, department);
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ success: false, error: "Failed to update user role" });
    }
  });

  app.patch('/api/users/:id/status', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, role } = req.body;
      
      if (!status) {
        return res.status(400).json({ success: false, error: "Status is required" });
      }
      
      // Validate status exists
      const validStatuses = ['active', 'inactive', 'pending_approval', 'suspended'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status" });
      }
      
      const updatedUser = await storage.updateUserStatus(id, status, role);
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ success: false, error: "Failed to update user status" });
    }
  });

  app.patch('/api/users/:id/profile', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { firstName, lastName, email, department } = req.body;
      
      // Basic validation
      if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }
      
      const validDepartments = ['æ•™ç·´çµ„', 'å®¢æœçµ„', 'è²¡å‹™çµ„', 'ç®¡ç†å±¤'];
      if (department && !validDepartments.includes(department)) {
        return res.status(400).json({ success: false, error: "Invalid department" });
      }
      
      const updatedUser = await storage.updateUserProfile(id, { firstName, lastName, email, department });
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user profile:", error);
      res.status(500).json({ success: false, error: "Failed to update user profile" });
    }
  });

  // Unified user update endpoint (Admin only)
  app.patch('/api/users/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { firstName, lastName, email, department, role, status } = req.body;
      
      // Validate email format if provided
      if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }
      
      // Validate department if provided
      const validDepartments = ['æ•™ç·´çµ„', 'å®¢æœçµ„', 'è²¡å‹™çµ„', 'ç®¡ç†å±¤'];
      if (department && !validDepartments.includes(department)) {
        return res.status(400).json({ success: false, error: "Invalid department" });
      }
      
      // Validate role if provided
      const validRoles = ['admin', 'manager', 'staff', 'user'];
      if (role && !validRoles.includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }
      
      // Validate status if provided
      const validStatuses = ['active', 'inactive', 'pending_approval', 'suspended'];
      if (status && !validStatuses.includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status" });
      }

      // Get current user to check if we have any changes
      const currentUser = await storage.getUser(id);
      if (!currentUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      let updatedUser = currentUser;

      // Update profile if any profile fields changed
      if (firstName !== undefined || lastName !== undefined || email !== undefined || department !== undefined) {
        const profileData = {
          firstName: firstName !== undefined ? firstName : currentUser.firstName,
          lastName: lastName !== undefined ? lastName : currentUser.lastName,
          email: email !== undefined ? email : currentUser.email,
          department: department !== undefined ? department : currentUser.department,
        };
        const result = await storage.updateUserProfile(id, profileData);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }

      // Update role if changed
      if (role !== undefined && role !== currentUser.role) {
        const result = await storage.updateUserRole(id, role, updatedUser.department || undefined);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }

      // Update status if changed
      if (status !== undefined && status !== currentUser.status) {
        const result = await storage.updateUserStatus(id, status, updatedUser.role || undefined);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ success: false, error: "Failed to update user" });
    }
  });

  // Role management API routes (Admin only)
  app.get('/api/roles', requireAdmin, async (req, res) => {
    try {
      const roles = await storage.listRoles();
      res.json({ success: true, data: roles });
    } catch (error) {
      console.error("Error fetching roles:", error);
      res.status(500).json({ success: false, error: "Failed to fetch roles" });
    }
  });

  app.post('/api/roles', requireAdmin, async (req, res) => {
    try {
      const data = insertRoleSchema.parse(req.body);
      const role = await storage.createRole(data);
      res.status(201).json({ success: true, data: role });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error("Error creating role:", error);
      res.status(500).json({ success: false, error: "Failed to create role" });
    }
  });

  app.put('/api/roles/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertRoleSchema.partial().parse(req.body);
      const role = await storage.updateRole(id, data);
      if (!role) {
        return res.status(404).json({ success: false, error: "Role not found" });
      }
      res.json({ success: true, data: role });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error("Error updating role:", error);
      res.status(500).json({ success: false, error: "Failed to update role" });
    }
  });

  app.delete('/api/roles/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteRole(id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: "Role not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting role:", error);
      res.status(500).json({ success: false, error: "Failed to delete role" });
    }
  });


  // Spreadsheets API routes (now protected)
  const toIsoString = (value?: Date | string | null) => {
    if (!value) {
      return null;
    }

    if (value instanceof Date) {
      return value.toISOString();
    }

    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed.toISOString();
  };

  app.get('/api/spreadsheets', async (req, res) => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      const enhanced = await Promise.all(
        spreadsheets.map(async (sheet) => {
          const relatedWorksheets = await storage.getWorksheets(sheet.spreadsheetId);
          const isActive = relatedWorksheets.some((worksheet) => worksheet.isEnabled);

          return {
            ...sheet,
            isActive,
            lastSyncAt: toIsoString(sheet.lastSyncAt ?? sheet.createdAt ?? null),
            createdAt: toIsoString(sheet.createdAt ?? null),
          };
        })
      );

      res.json({ success: true, data: enhanced });
    } catch (error) {
      console.error('Error fetching spreadsheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch spreadsheets' });
    }
  });

  app.post('/api/spreadsheets', async (req, res) => {
    try {
      const data = insertSpreadsheetSchema.parse(req.body);
      
      // Validate spreadsheet exists and is accessible
      const metadata = await googleSheetsService.validateSpreadsheet(data.spreadsheetId);
      if (!metadata) {
        return res.status(400).json({ success: false, error: 'Invalid spreadsheet ID or access denied' });
      }

      // Check if already exists
      const existing = await storage.getSpreadsheetBySheetId(data.spreadsheetId);
      if (existing) {
        return res.status(409).json({ success: false, error: 'Spreadsheet already exists' });
      }

      const spreadsheet = await storage.createSpreadsheet({
        ...data,
        name: data.name || metadata.name,
      });

      // Broadcast new sheet addition
      broadcast({
        type: 'sheet_added',
        spreadsheet: {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId,
        },
      });

      // ä¸åœ¨ä¸²æ¥æ™‚åŒæ­¥è³‡æ–™ï¼Œç­‰å¾…ä½¿ç”¨è€…è¨­å®š worksheet mapping å¾Œå†åŒæ­¥
      console.log('âœ… Spreadsheet created successfully, skipping initial sync');

      res.status(201).json({ success: true, data: spreadsheet });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Error creating spreadsheet:', error);
      res.status(500).json({ success: false, error: 'Failed to create spreadsheet' });
    }
  });

  app.delete('/api/spreadsheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteSpreadsheet(id);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting spreadsheet:', error);
      res.status(500).json({ success: false, error: 'Failed to delete spreadsheet' });
    }
  });

  // Worksheet API routes (protected)

  // å„ªåŒ–ï¼šä¸€æ¬¡å–å¾—æ‰€æœ‰ spreadsheets çš„ worksheetsï¼Œé¿å… N+1 æŸ¥è©¢
  app.get('/api/worksheets/all', async (req, res) => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      const allWorksheets: any[] = [];

      // ä¸¦è¡ŒæŸ¥è©¢æ‰€æœ‰ spreadsheets çš„ worksheets
      await Promise.all(
        spreadsheets.map(async (spreadsheet) => {
          try {
            // Get worksheets from Google Sheets API
            const worksheetInfo = await googleSheetsService.getWorksheets(spreadsheet.spreadsheetId);
            if (!worksheetInfo) return;

            // Get existing worksheets from storage
            const existingWorksheets = await storage.getWorksheets(spreadsheet.id);

            // Merge Google Sheets data with local storage data
            const worksheets = worksheetInfo.map(wsInfo => {
              const existing = existingWorksheets.find(w => w.gid === wsInfo.gid);
              return existing || {
                id: `temp-${wsInfo.gid}`,
                worksheetName: wsInfo.name,
                gid: wsInfo.gid,
                spreadsheetId: spreadsheet.spreadsheetId,
                isEnabled: false,
                range: "A1:Z1000",
                headers: null,
                rowCount: 0,
                lastSyncAt: null,
                createdAt: new Date(),
              };
            });

            allWorksheets.push(...worksheets);
          } catch (error) {
            console.error(`Error fetching worksheets for spreadsheet ${spreadsheet.id}:`, error);
            // Continue with other spreadsheets even if one fails
          }
        })
      );

      res.json({ success: true, data: allWorksheets });
    } catch (error) {
      console.error('Error fetching all worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  app.get('/api/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Get worksheets from Google Sheets API
      const worksheetInfo = await googleSheetsService.getWorksheets(spreadsheet.spreadsheetId);
      if (!worksheetInfo) {
        return res.status(400).json({ success: false, error: 'Failed to fetch worksheets' });
      }

      // Get existing worksheets from storage
      const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
      
      // Merge Google Sheets data with local storage data
      const worksheets = worksheetInfo.map(wsInfo => {
        const existing = existingWorksheets.find(w => w.gid === wsInfo.gid);
        return existing || {
          id: `temp-${wsInfo.gid}`,
          worksheetName: wsInfo.name,
          gid: wsInfo.gid,
          spreadsheetId: spreadsheet.spreadsheetId,
          isEnabled: false,
          range: "A1:Z1000",
          headers: null,
          rowCount: 0,
          lastSyncAt: null,
          createdAt: new Date(),
        };
      });

      res.json({ success: true, data: worksheets });
    } catch (error) {
      console.error('Error fetching worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  app.post('/api/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertWorksheetSchema.omit({ spreadsheetId: true }).parse(req.body);
      
      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Check if worksheet already exists
      const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
      const existing = existingWorksheets.find(w => w.gid === data.gid);
      
      if (existing) {
        return res.status(409).json({ success: false, error: 'Worksheet already exists' });
      }

      const worksheet = await storage.createWorksheet({
        ...data,
        spreadsheetId: spreadsheet.id, // Use internal UUID
      });

      // Broadcast worksheet added
      broadcast({
        type: 'worksheet_added',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: 'Invalid request data',
          errors: error.errors
        });
      }
      console.error('Error creating worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to create worksheet' });
    }
  });

  app.put('/api/worksheets/:id/toggle', async (req, res) => {
    try {
      const { id } = req.params;
      const { isEnabled, spreadsheetId, gid, worksheetName, range } = req.body;
      
      if (typeof isEnabled !== 'boolean') {
        return res.status(400).json({ success: false, error: 'isEnabled must be a boolean' });
      }
      
      let worksheet = await storage.toggleWorksheetSync(id, isEnabled);

      if (!worksheet) {
        if (!spreadsheetId || !gid) {
          return res.status(404).json({ success: false, error: 'Worksheet not found' });
        }

        // Find spreadsheet by Google Sheets ID to get internal UUID
        const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
        if (!spreadsheet) {
          return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
        }

        const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
        const existing = existingWorksheets.find(w => w.gid === gid);

        if (existing) {
          worksheet = await storage.toggleWorksheetSync(existing.id, isEnabled);
        } else {
          const created = await storage.createWorksheet({
            spreadsheetId: spreadsheet.id, // Use internal UUID
            gid,
            worksheetName: worksheetName || `Worksheet ${gid}`,
            range: range || 'A1:Z1000',
            isEnabled,
            headers: [],
          });
          worksheet = created;
        }
      }
      
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet status change
      broadcast({
        type: 'worksheet_updated',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error toggling worksheet sync:', error);
      res.status(500).json({ success: false, error: 'Failed to toggle worksheet sync' });
    }
  });

  // Update worksheet settings (range, etc.)
  app.put('/api/worksheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const worksheet = await storage.updateWorksheet(id, updates);

      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet update
      broadcast({
        type: 'worksheet_updated',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error updating worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to update worksheet' });
    }
  });

  app.delete('/api/worksheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteWorksheet(id);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet removed
      broadcast({
        type: 'worksheet_removed',
        worksheetId: id,
      });

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to delete worksheet' });
    }
  });

  // Set Supabase table mapping for a worksheet
  app.put('/api/worksheets/:id/supabase-mapping', async (req, res) => {
    try {
      const { id } = req.params;
      const { supabaseTable } = req.body;

      if (!supabaseTable || typeof supabaseTable !== 'string') {
        return res.status(400).json({ success: false, error: 'supabaseTable is required and must be a string' });
      }

      const worksheet = await storage.updateWorksheet(id, { supabaseTable });

      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error setting Supabase mapping:', error);
      res.status(500).json({ success: false, error: 'Failed to set Supabase mapping' });
    }
  });

  // Get all existing Supabase tables
  app.get('/api/supabase/tables', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        console.log('Supabase not available, returning empty table list');
        return res.json({ success: true, data: [] });
      }

      const client = getSupabaseClient();

      // Try to use RPC function to get table names
      // First, try the RPC approach
      const { data: rpcData, error: rpcError } = await client.rpc('get_table_names');

      if (!rpcError && rpcData) {
        console.log('âœ“ Fetched tables via RPC:', rpcData);
        res.json({ success: true, data: rpcData });
        return;
      }

      // Fallback: Use known tables or a hardcoded list
      // This is a temporary solution - in production, you'd create the RPC function
      console.log('âš ï¸  RPC function not available, using fallback method');

      // Try to query a known table to verify connection
      const knownTables = [
        'trial_class_attendance',
        'trial_class_purchase',
        'eods_for_closers',
        'purchase_records',
        'consultation_records'
      ];

      // Verify which tables exist by trying to query them
      const existingTables: string[] = [];
      for (const tableName of knownTables) {
        try {
          const { error } = await client.from(tableName).select('*').limit(0);
          if (!error) {
            existingTables.push(tableName);
          }
        } catch (e) {
          // Table doesn't exist or no access
        }
      }

      console.log('âœ“ Found existing tables:', existingTables);
      res.json({ success: true, data: existingTables });
    } catch (error: any) {
      console.error('Error in /api/supabase/tables:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to fetch Supabase tables' });
    }
  });

  // Create a new Supabase table dynamically
  app.post('/api/supabase/tables', async (req, res) => {
    try {
      const { tableName, columns } = req.body;

      if (!tableName || typeof tableName !== 'string') {
        return res.status(400).json({ success: false, error: 'tableName is required' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase not available' });
      }

      const client = getSupabaseClient();

      // Create table with provided columns or default structure
      const columnDefs = columns && Array.isArray(columns) ? columns : [
        { name: 'id', type: 'uuid', primary: true, default: 'gen_random_uuid()' },
        { name: 'data', type: 'jsonb' },
        { name: 'created_at', type: 'timestamptz', default: 'now()' },
      ];

      // Build CREATE TABLE SQL
      const columnsSql = columnDefs.map((col: any) => {
        let def = `${col.name} ${col.type}`;
        if (col.primary) def += ' PRIMARY KEY';
        if (col.default) def += ` DEFAULT ${col.default}`;
        if (col.notNull) def += ' NOT NULL';
        return def;
      }).join(', ');

      const createTableSql = `CREATE TABLE IF NOT EXISTS ${tableName} (${columnsSql})`;

      // Execute via RPC or direct SQL (Supabase typically doesn't allow DDL via REST API)
      // This is a simplified approach - in production you'd use migrations or Admin API
      const { error } = await client.rpc('exec_sql', { sql: createTableSql });

      if (error) {
        console.error('Error creating table:', error);
        return res.status(500).json({ success: false, error: 'Failed to create table: ' + error.message });
      }

      res.json({ success: true, data: { tableName } });
    } catch (error: any) {
      console.error('Error in /api/supabase/tables POST:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to create table' });
    }
  });

  // Get data for a specific worksheet (protected)
  app.get('/api/worksheets/:id/data', async (req, res) => {
    try {
      const { id } = req.params;
      const { page, limit } = req.query;
      
      const data = await storage.getWorksheetData(id);
      
      // å¦‚æœæ²’æœ‰æä¾›åˆ†é åƒæ•¸ï¼Œä¿æŒå‘å¾Œå…¼å®¹ï¼Œè¿”å›ç´”æ•¸çµ„
      if (!page && !limit) {
        return res.json({ success: true, data });
      }
      
      // åˆ†é åƒæ•¸é©—è­‰
      const pageNum = parseInt(page as string);
      const pageSize = parseInt(limit as string);
      
      if (isNaN(pageNum) || pageNum < 1) {
        return res.status(400).json({ success: false, error: 'Invalid page parameter. Must be a positive integer.' });
      }
      
      if (isNaN(pageSize) || pageSize < 1 || pageSize > 1000) {
        return res.status(400).json({ success: false, error: 'Invalid limit parameter. Must be between 1 and 1000.' });
      }
      
      const startIndex = (pageNum - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      const paginatedData = data.slice(startIndex, endIndex);
      
      res.json({
        success: true,
        data: paginatedData,
        pagination: {
          page: pageNum,
          limit: pageSize,
          total: data.length,
          totalPages: Math.ceil(data.length / pageSize)
        }
      });
    } catch (error) {
      console.error('Error fetching worksheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheet data' });
    }
  });

  // Get column headers for a specific worksheet (protected)
  app.get('/api/worksheets/:id/headers', async (req, res) => {
    try {
      const { id } = req.params;
      const worksheet = await storage.getWorksheet(id);
      
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      res.json({
        headers: worksheet.headers || [],
        worksheetName: worksheet.worksheetName
      });
    } catch (error) {
      console.error('Error fetching worksheet headers:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheet headers' });
    }
  });

  // Get aggregated data for a specific worksheet column (protected)
  app.get('/api/worksheets/:id/aggregate', async (req, res) => {
    try {
      const { id } = req.params;
      const { column, operation } = req.query;
      
      if (!column || !operation) {
        return res.status(400).json({ success: false, error: 'Column and operation parameters are required' });
      }
      
      // é©—è­‰æ“ä½œé¡å‹
      const validOperations = ['sum', 'average', 'count', 'max', 'min'];
      if (!validOperations.includes(operation as string)) {
        return res.status(400).json({ 
          message: `Invalid operation. Supported operations: ${validOperations.join(', ')}` 
        });
      }
      
      // ç²å–å·¥ä½œè¡¨å’Œé©—è­‰æ¬„ä½
      const worksheet = await storage.getWorksheet(id);
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      const headers = worksheet.headers || [];
      if (!headers.includes(column as string)) {
        return res.status(400).json({ 
          message: `Column '${column}' not found. Available columns: ${headers.join(', ')}` 
        });
      }
      
      const data = await storage.getWorksheetData(id);
      const values = data
        .map(row => row.data[column as string])
        .filter(val => val !== null && val !== undefined && val !== '');
      
      let result;
      let numericCount = 0;
      let nonNumericCount = 0;
      
      switch (operation) {
        case 'sum':
          result = values.reduce((sum, val) => {
            const num = parseFloat(val);
            if (!isNaN(num)) {
              numericCount++;
              return sum + num;
            } else {
              nonNumericCount++;
              return sum;
            }
          }, 0);
          break;
        case 'average':
          const numericValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = numericValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? numericValues.reduce((sum, val) => sum + val, 0) / numericCount : 0;
          break;
        case 'count':
          result = values.length;
          numericCount = values.map(val => parseFloat(val)).filter(val => !isNaN(val)).length;
          nonNumericCount = values.length - numericCount;
          break;
        case 'max':
          const maxValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = maxValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? Math.max(...maxValues) : 0;
          break;
        case 'min':
          const minValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = minValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? Math.min(...minValues) : 0;
          break;
      }
      
      res.json({
        column: column as string,
        operation: operation as string,
        result,
        total: data.length,
        validValues: values.length,
        numericCount,
        nonNumericCount
      });
    } catch (error) {
      console.error('Error calculating aggregate:', error);
      res.status(500).json({ success: false, error: 'Failed to calculate aggregate' });
    }
  });

  // Export worksheet data as JSON (protected)
  app.get('/api/worksheets/:id/export', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { format = 'json' } = req.query;
      
      const worksheet = await storage.getWorksheet(id);
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      const data = await storage.getWorksheetData(id);
      
      if (format === 'csv') {
        // Convert to CSV format
        const headers = worksheet.headers || [];
        const csvRows = [
          headers.join(','),
          ...data.map(row => 
            headers.map(header => 
              JSON.stringify(row.data[header] || '')
            ).join(',')
          )
        ];
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(worksheet.worksheetName)}.csv`);
        res.send(csvRows.join('\n'));
      } else {
        // JSON format with metadata
        const exportData = {
          worksheet: {
            id: worksheet.id,
            name: worksheet.worksheetName,
            gid: worksheet.gid,
            spreadsheetId: worksheet.spreadsheetId,
            headers: worksheet.headers,
            rowCount: worksheet.rowCount,
            lastSyncAt: worksheet.lastSyncAt,
          },
          data: data.map(row => row.data),
          exportedAt: new Date().toISOString(),
        };
        
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(worksheet.worksheetName)}.json`);
        res.json({ success: true, data: exportData });
      }
    } catch (error) {
      console.error('Error exporting worksheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to export worksheet data' });
    }
  });

  // Export all enabled worksheets data for dashboard analytics (admin only)
  app.get('/api/spreadsheets/:id/export-analytics', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }
      
      const worksheets = await storage.getWorksheets(spreadsheet.id);
      const enabledWorksheets = worksheets.filter(w => w.isEnabled);

      const analyticsData = {
        spreadsheet: {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId,
          totalRowCount: spreadsheet.rowCount,
          lastSyncAt: spreadsheet.lastSyncAt,
        },
        worksheets: await Promise.all(enabledWorksheets.map(async (worksheet) => {
          const data = await storage.getWorksheetData(worksheet.id);
          return {
            id: worksheet.id,
            name: worksheet.worksheetName,
            gid: worksheet.gid,
            headers: worksheet.headers,
            rowCount: data.length,
            data: data.map(row => row.data),
            lastSyncAt: worksheet.lastSyncAt,
          };
        })),
        exportedAt: new Date().toISOString(),
      };
      
      res.json({ success: true, data: analyticsData });
    } catch (error) {
      console.error('Error exporting analytics data:', error);
      res.status(500).json({ success: false, error: 'Failed to export analytics data' });
    }
  });

  // Worksheet sync routes (admin only)
  app.post('/api/worksheets/:id/sync', async (req, res) => {
    try {
      const { id } = req.params;
      console.log('ğŸ”„ Syncing worksheet with ID:', id);

      const worksheet = await storage.getWorksheet(id);
      console.log('ğŸ“‹ Worksheet found:', worksheet ? `${worksheet.worksheetName} (spreadsheetId: ${worksheet.spreadsheetId})` : 'NOT FOUND');

      if (!worksheet) {
        console.error('âŒ Worksheet not found for ID:', id);
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Get spreadsheet to obtain Google Sheets ID
      const spreadsheet = await storage.getSpreadsheet(worksheet.spreadsheetId);
      console.log('ğŸ“Š Spreadsheet found:', spreadsheet ? `${spreadsheet.name} (ID: ${spreadsheet.spreadsheetId})` : 'NOT FOUND');

      if (!spreadsheet) {
        console.error('âŒ Spreadsheet not found for ID:', worksheet.spreadsheetId);
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing worksheet ${worksheet.worksheetName}...`,
      });

      // Sync worksheet and capture the sync result
      const syncResult = await googleSheetsService.syncWorksheet(worksheet, spreadsheet);
      console.log('âœ… Sync result:', syncResult ? `${syncResult.insertedToSupabase} inserted, ${syncResult.invalidRows} invalid` : 'null');

      // Get updated worksheet after sync
      const updatedWorksheet = await storage.getWorksheet(id);
      console.log('ğŸ“‹ Updated worksheet:', updatedWorksheet ? `ID: ${updatedWorksheet.id}` : 'NOT FOUND');

      if (!updatedWorksheet) {
        console.error('âŒ Failed to get updated worksheet after sync');
        return res.status(500).json({ success: false, error: 'Failed to get updated worksheet' });
      }

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: worksheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for worksheet ${worksheet.worksheetName}`,
      });

      // Return worksheet with sync statistics
      const response = {
        success: true,
        data: updatedWorksheet,
        syncStats: syncResult || {
          totalRows: updatedWorksheet.rowCount || 0,
          insertedToSupabase: 0,
          invalidRows: 0,
          mappedFields: 0,
          hasSyncedToSupabase: !!worksheet.supabaseTable,
          invalidRecords: []
        }
      };

      console.log('ğŸ“¤ API Response:', JSON.stringify({
        success: response.success,
        dataId: response.data.id,
        syncStats: response.syncStats
      }, null, 2));

      res.json(response);
    } catch (error) {
      console.error('Error syncing worksheet:', error);

      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Worksheet sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync worksheet' });
    }
  });

  app.post('/api/spreadsheets/:id/sync-worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing enabled worksheets for ${spreadsheet.name}...`,
      });

      await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);

      // Get updated spreadsheet after sync
      const updatedSpreadsheet = await storage.getSpreadsheet(id);

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: spreadsheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for enabled worksheets in ${spreadsheet.name}`,
      });

      res.json({ success: true, data: updatedSpreadsheet });
    } catch (error) {
      console.error('Error syncing enabled worksheets:', error);
      
      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Worksheet sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync enabled worksheets' });
    }
  });

  // Get all worksheets (for widget builder)
  app.get('/api/worksheets', async (req, res) => {
    try {
      const worksheets = await storage.getAllWorksheets();
      res.json({ success: true, data: worksheets });
    } catch (error) {
      console.error('Error fetching all worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  // Sheet data API routes
  app.get('/api/spreadsheets/:id/data', async (req, res) => {
    try {
      const { id } = req.params;
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50;
      const search = req.query.search as string;

      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      let data;
      let total;

      if (search) {
        data = await storage.searchSheetData(spreadsheet.spreadsheetId, search);
        total = data.length;
        // Apply pagination to search results
        const start = (page - 1) * limit;
        data = data.slice(start, start + limit);
      } else {
        data = await storage.getSheetData(spreadsheet.spreadsheetId, page, limit);
        total = await storage.getSheetDataCount(spreadsheet.spreadsheetId);
      }

      res.json({
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
        spreadsheet,
      });
    } catch (error) {
      console.error('Error fetching sheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch sheet data' });
    }
  });

  app.post('/api/spreadsheets/:id/sync', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing ${spreadsheet.name}...`,
      });

      // Use worksheet-based sync if worksheets are enabled, otherwise use legacy sync
      const worksheets = await storage.getWorksheets(spreadsheet.id);
      const enabledWorksheets = worksheets.filter(w => w.isEnabled);

      if (enabledWorksheets.length > 0) {
        await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);
      } else {
        await googleSheetsService.syncSpreadsheet(spreadsheet);
      }

      // Get updated data count
      const updatedSpreadsheet = await storage.getSpreadsheet(id);

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: spreadsheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for ${spreadsheet.name}`,
      });

      res.json({ success: true, data: updatedSpreadsheet });
    } catch (error) {
      console.error('Error syncing spreadsheet:', error);
      
      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync spreadsheet' });
    }
  });

  // Periodic sync - every 5 minutes
  setInterval(async () => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      
      for (const spreadsheet of spreadsheets) {
        try {
          // Use worksheet-based sync if worksheets are enabled, otherwise use legacy sync
          const worksheets = await storage.getWorksheets(spreadsheet.id);
          const enabledWorksheets = worksheets.filter(w => w.isEnabled);

          if (enabledWorksheets.length > 0) {
            await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);
          } else {
            await googleSheetsService.syncSpreadsheet(spreadsheet);
          }
          
          // Broadcast data update
          broadcast({
            type: 'data_update',
            spreadsheetId: spreadsheet.spreadsheetId,
            changes: [], // Could be more specific about what changed
          });
        } catch (error) {
          console.error(`Failed to sync ${spreadsheet.name}:`, error);
        }
      }
    } catch (error) {
      console.error('Error during periodic sync:', error);
    }
  }, 5 * 60 * 1000); // 5 minutes

  // ===== Multi-Datasource API Routes =====

  // Data Source Relationships
  app.get('/api/data-source-relationships', async (req, res) => {
    try {
      const relationships = await storage.listDataSourceRelationships();
      res.json({ success: true, data: relationships });
    } catch (error) {
      console.error('Error fetching data source relationships:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const relationship = await storage.getDataSourceRelationship(req.params.id);
      if (!relationship) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.json({ success: true, data: relationship });
    } catch (error) {
      console.error('Error fetching data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/data-source-relationships', async (req, res) => {
    try {
      const validated = insertDataSourceRelationshipSchema.parse(req.body);
      
      // Validate referenced data source mappings exist
      const primarySource = await storage.getDataSourceMapping(validated.primarySourceId);
      if (!primarySource) {
        return res.status(400).json({ success: false, error: 'Primary source ID does not exist' });
      }
      const secondarySource = await storage.getDataSourceMapping(validated.secondarySourceId);
      if (!secondarySource) {
        return res.status(400).json({ success: false, error: 'Secondary source ID does not exist' });
      }
      
      const relationship = await storage.createDataSourceRelationship(validated);
      res.status(201).json({ success: true, data: relationship });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const validated = updateDataSourceRelationshipSchema.parse(req.body);
      
      // Validate referenced data source mappings exist
      if (validated.primarySourceId) {
        const primarySource = await storage.getDataSourceMapping(validated.primarySourceId);
        if (!primarySource) {
          return res.status(400).json({ success: false, error: 'Primary source ID does not exist' });
        }
      }
      if (validated.secondarySourceId) {
        const secondarySource = await storage.getDataSourceMapping(validated.secondarySourceId);
        if (!secondarySource) {
          return res.status(400).json({ success: false, error: 'Secondary source ID does not exist' });
        }
      }
      
      const relationship = await storage.updateDataSourceRelationship(req.params.id, validated);
      if (!relationship) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.json({ success: true, data: relationship });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteDataSourceRelationship(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Purchase Records
  app.get('/api/purchase-records', async (req, res) => {
    try {
      const { studentName, courseType, status } = req.query;
      const filters: any = {};
      if (studentName) filters.studentName = studentName as string;
      if (courseType) filters.courseType = courseType as string;
      if (status) filters.status = status as string;
      
      const records = await storage.listPurchaseRecords(filters);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching purchase records:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/purchase-records/:id', async (req, res) => {
    try {
      const record = await storage.getPurchaseRecord(req.params.id);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      console.error('Error fetching purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/purchase-records/student/:email', async (req, res) => {
    try {
      const records = await storage.getPurchaseRecordsByStudent(req.params.email);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching purchase records by student:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/purchase-records', async (req, res) => {
    try {
      const validated = enhancedInsertPurchaseRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.createPurchaseRecord(validated);
      res.status(201).json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/purchase-records/:id', async (req, res) => {
    try {
      const validated = updatePurchaseRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.updatePurchaseRecord(req.params.id, validated);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/purchase-records/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deletePurchaseRecord(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Consultation Records
  app.get('/api/consultation-records', async (req, res) => {
    try {
      const { studentName, status, consultantName } = req.query;
      const filters: any = {};
      if (studentName) filters.studentName = studentName as string;
      if (status) filters.status = status as string;
      if (consultantName) filters.consultantName = consultantName as string;
      
      const records = await storage.listConsultationRecords(filters);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching consultation records:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/consultation-records/:id', async (req, res) => {
    try {
      const record = await storage.getConsultationRecord(req.params.id);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      console.error('Error fetching consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/consultation-records/student/:email', async (req, res) => {
    try {
      const records = await storage.getConsultationRecordsByStudent(req.params.email);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching consultation records by student:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/consultation-records', async (req, res) => {
    try {
      const validated = enhancedInsertConsultationRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.createConsultationRecord(validated);
      res.status(201).json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/consultation-records/:id', async (req, res) => {
    try {
      const validated = updateConsultationRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.updateConsultationRecord(req.params.id, validated);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/consultation-records/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deleteConsultationRecord(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Multi-Source Analytics
  app.get('/api/multi-source-analytics', async (req, res) => {
    try {
      const { analysisType } = req.query;
      const analytics = await storage.listMultiSourceAnalytics(analysisType as string);
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error('Error fetching multi-source analytics:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/multi-source-analytics/:id', async (req, res) => {
    try {
      const analytic = await storage.getMultiSourceAnalytic(req.params.id);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      console.error('Error fetching multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/multi-source-analytics', requireAdmin, async (req, res) => {
    try {
      const validated = insertMultiSourceAnalyticSchema.parse(req.body);
      
      // Validate relationship IDs exist if provided
      if (validated.sourceRelationshipIds && validated.sourceRelationshipIds.length > 0) {
        for (const relationshipId of validated.sourceRelationshipIds) {
          const relationship = await storage.getDataSourceRelationship(relationshipId);
          if (!relationship) {
            return res.status(400).json({ message: `Data source relationship ${relationshipId} does not exist` });
          }
        }
      }
      
      const analytic = await storage.createMultiSourceAnalytic(validated);
      res.status(201).json({ success: true, data: analytic });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/multi-source-analytics/:id', requireAdmin, async (req, res) => {
    try {
      const validated = updateMultiSourceAnalyticSchema.parse(req.body);

      // Validate relationship IDs exist if provided
      if (validated.sourceRelationshipIds) {
        for (const relationshipId of validated.sourceRelationshipIds) {
          const relationship = await storage.getDataSourceRelationship(relationshipId);
          if (!relationship) {
            return res.status(400).json({ message: `Data source relationship ${relationshipId} does not exist` });
          }
        }
      }

      const analytic = await storage.updateMultiSourceAnalytic(req.params.id, validated as any);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/multi-source-analytics/:id/calculate', requireAdmin, async (req, res) => {
    try {
      const analytic = await storage.calculateMultiSourceAnalytic(req.params.id);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      console.error('Error calculating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/multi-source-analytics/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deleteMultiSourceAnalytic(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // ===== Auto Analysis API Routes =====

  // Analyze a specific worksheet
  app.post('/api/worksheets/:id/analyze', async (req, res) => {
    const worksheetId = req.params.id;
    console.log(`ğŸ¯ API request to analyze worksheet: ${worksheetId}`);

    try {
      // Check if worksheet exists
      const worksheet = await storage.getWorksheet(worksheetId);
      if (!worksheet) {
        console.error(`âŒ Worksheet not found: ${worksheetId}`);
        return res.status(404).json({
          message: 'Worksheet not found',
          error: `No worksheet found with ID: ${worksheetId}`
        });
      }

      console.log(`âœ… Found worksheet: ${worksheet.worksheetName}`);

      // Perform analysis
      console.log(`ğŸ” Starting analysis for worksheet: ${worksheet.worksheetName}`);
      const analysis = await autoAnalysisService.analyzeWorksheet(worksheetId);

      if (!analysis) {
        console.error(`âŒ Analysis failed for worksheet: ${worksheet.worksheetName}`);
        return res.status(500).json({
          message: 'Failed to analyze worksheet',
          error: 'Analysis service returned null. Check server logs for details.',
          worksheetName: worksheet.worksheetName
        });
      }

      console.log(`âœ… Analysis completed for worksheet: ${worksheet.worksheetName}`);

      // Save analysis to storage
      console.log(`ğŸ’¾ Saving analysis to storage...`);
      const savedAnalysis = await storage.createWorksheetAnalysis({
        worksheetId: analysis.worksheetId,
        category: analysis.category,
        confidence: Math.round(analysis.confidence * 100),
        columnAnalyses: analysis.columns,
        rowCount: analysis.rowCount,
        dataQuality: analysis.dataQuality,
        suggestedReports: analysis.suggestedReports
      });

      console.log(`ğŸ‰ Analysis saved successfully with ID: ${savedAnalysis.id}`);
      res.json({ success: true, data: savedAnalysis });

    } catch (error) {
      console.error(`âŒ Error analyzing worksheet ${worksheetId}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      res.status(500).json({
        message: 'Internal server error',
        error: errorMessage,
        worksheetId,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Get analysis for a worksheet
  app.get('/api/worksheets/:id/analysis', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      const analysis = await storage.getWorksheetAnalysis(worksheetId);

      if (!analysis) {
        return res.status(404).json({ success: false, error: 'Analysis not found' });
      }

      res.json({ success: true, data: analysis });
    } catch (error) {
      console.error('Error fetching worksheet analysis:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Analyze all worksheets in a spreadsheet
  app.post('/api/spreadsheets/:id/analyze-all', async (req, res) => {
    const spreadsheetId = req.params.id;
    console.log(`ğŸš€ API request to analyze all worksheets in spreadsheet: ${spreadsheetId}`);

    try {
      const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
      if (!spreadsheet) {
        console.error(`âŒ Spreadsheet not found: ${spreadsheetId}`);
        return res.status(404).json({
          message: 'Spreadsheet not found',
          error: `No spreadsheet found with ID: ${spreadsheetId}`
        });
      }

      console.log(`âœ… Found spreadsheet: ${spreadsheet.name}`);

      // Clear existing analyses for this spreadsheet's worksheets
      const existingAnalyses = await storage.listWorksheetAnalyses(spreadsheetId);
      console.log(`ğŸ—‘ï¸ Clearing ${existingAnalyses.length} existing analyses`);

      for (const analysis of existingAnalyses) {
        await storage.deleteWorksheetAnalysis(analysis.id);
      }

      const analyses = await autoAnalysisService.analyzeAllWorksheets(spreadsheetId);
      console.log(`ğŸ“Š Got ${analyses.length} analyses from service`);

      const savedAnalyses = [];
      const errors = [];

      for (const analysis of analyses) {
        try {
          console.log(`ğŸ’¾ Saving analysis for worksheet: ${analysis.worksheetName}`);
          const savedAnalysis = await storage.createWorksheetAnalysis({
            worksheetId: analysis.worksheetId,
            category: analysis.category,
            confidence: Math.round(analysis.confidence * 100),
            columnAnalyses: analysis.columns,
            rowCount: analysis.rowCount,
            dataQuality: analysis.dataQuality,
            suggestedReports: analysis.suggestedReports
          });
          savedAnalyses.push(savedAnalysis);
          console.log(`âœ… Saved analysis for worksheet: ${analysis.worksheetName}`);
        } catch (error) {
          const errorMsg = `Failed to save analysis for worksheet ${analysis.worksheetId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          console.error(`âŒ ${errorMsg}`);
          errors.push(errorMsg);
        }
      }

      console.log(`ğŸ‰ Analysis completed: ${savedAnalyses.length} saved, ${errors.length} errors`);

      res.json({
        analyses: savedAnalyses,
        summary: {
          total: analyses.length,
          saved: savedAnalyses.length,
          errors: errors.length,
          errorMessages: errors
        }
      });

    } catch (error) {
      console.error(`âŒ Error analyzing all worksheets in ${spreadsheetId}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      res.status(500).json({
        message: 'Internal server error',
        error: errorMessage,
        spreadsheetId,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Get all analyses for a spreadsheet
  app.get('/api/spreadsheets/:id/analyses', async (req, res) => {
    try {
      const spreadsheetId = req.params.id;
      const analyses = await storage.listWorksheetAnalyses(spreadsheetId);
      res.json({ success: true, data: analyses });
    } catch (error) {
      console.error('Error fetching spreadsheet analyses:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Generate auto report from analysis suggestion
  app.post('/api/worksheet-analyses/:id/generate-report', async (req, res) => {
    try {
      const analysisId = req.params.id;
      const { suggestionIndex } = req.body;

      const analysis: any = Array.from((storage as any).worksheetAnalyses.values()).find((a: any) => a.id === analysisId);
      if (!analysis) {
        return res.status(404).json({ success: false, error: 'Analysis not found' });
      }

      const suggestion = analysis.suggestedReports[suggestionIndex];
      if (!suggestion) {
        return res.status(404).json({ success: false, error: 'Report suggestion not found' });
      }

      // Convert storage analysis to service analysis format
      const serviceAnalysis = {
        worksheetId: analysis.worksheetId,
        worksheetName: '', // Will be filled by service
        category: analysis.category as any,
        confidence: analysis.confidence / 100,
        columns: analysis.columnAnalyses,
        rowCount: analysis.rowCount,
        suggestedReports: analysis.suggestedReports,
        dataQuality: analysis.dataQuality
      };

      // Generate the report data
      const reportData = await autoAnalysisService.generateAutoReport(serviceAnalysis, suggestion);

      // Save the generated report
      const savedReport = await storage.createAutoGeneratedReport({
        worksheetAnalysisId: analysisId,
        reportType: suggestion.type,
        title: suggestion.title,
        description: suggestion.description,
        config: {
          chartType: suggestion.chartType,
          metrics: suggestion.metrics,
          filters: suggestion.filters,
          groupBy: suggestion.groupBy
        },
        data: reportData,
        isActive: true
      });

      res.json(savedReport);
    } catch (error) {
      console.error('Error generating auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Get auto-generated reports for a worksheet
  app.get('/api/worksheets/:id/auto-reports', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      const reports = await storage.getAutoGeneratedReportsByWorksheet(worksheetId);
      res.json(reports);
    } catch (error) {
      console.error('Error fetching auto-generated reports:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Get a specific auto-generated report
  app.get('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const report = await storage.getAutoGeneratedReport(reportId);

      if (!report) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json(report);
    } catch (error) {
      console.error('Error fetching auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Update an auto-generated report
  app.put('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const updates = req.body;

      const updatedReport = await storage.updateAutoGeneratedReport(reportId, updates);
      if (!updatedReport) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json(updatedReport);
    } catch (error) {
      console.error('Error updating auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Delete an auto-generated report
  app.delete('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const deleted = await storage.deleteAutoGeneratedReport(reportId);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // ===== Development Seed API Routes =====

  // Seed test data for Total Report (DEV only)
  app.post('/api/dev/seed-total-report', isAuthenticated, async (req, res) => {
    // Only allow in development
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({
        success: false,
        error: 'Not allowed in production',
      });
    }

    try {
      const result = await devSeedService.seedTotalReportData();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error seeding data:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to seed data',
        message: error.message,
      });
    }
  });

  // Clear test data (DEV only)
  app.delete('/api/dev/seed-total-report', isAuthenticated, async (req, res) => {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({
        success: false,
        error: 'Not allowed in production',
      });
    }

    try {
      const result = await devSeedService.clearTestData();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error clearing data:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to clear data',
        message: error.message,
      });
    }
  });

  // ===== Introspection Tool API Routes =====

  // Trigger field introspection
  app.post('/api/tools/introspect-sheets', isAuthenticated, async (req, res) => {
    try {
      const result = await introspectService.runIntrospection();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error running introspection:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to run introspection',
        message: error.message,
      });
    }
  });

  // Get latest introspection result
  app.get('/api/tools/introspect-sheets/latest', isAuthenticated, async (req, res) => {
    try {
      const result = await introspectService.getLatestIntrospection();
      if (!result) {
        return res.json({
          success: true,
          data: null,
        });
      }
      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('Error fetching latest introspection:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch introspection data',
      });
    }
  });

  // ===== Report Metric Configuration API Routes =====

  // Get all metric configurations
  app.get('/api/report-metrics/config', isAuthenticated, async (req, res) => {
    try {
      const configs = await reportMetricConfigService.getAllConfigs();
      res.json({
        success: true,
        data: configs,
      });
    } catch (error: any) {
      console.error('Error fetching metric configs:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch metric configurations',
        message: error.message,
      });
    }
  });

  // Get specific metric configuration
  app.get('/api/report-metrics/config/:metricId', isAuthenticated, async (req, res) => {
    try {
      const config = await reportMetricConfigService.getConfig(req.params.metricId);
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Metric configuration not found',
        });
      }
      res.json({
        success: true,
        data: config,
      });
    } catch (error: any) {
      console.error('Error fetching metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch metric configuration',
        message: error.message,
      });
    }
  });

  // Update metric configuration
  app.post('/api/report-metrics/config', isAuthenticated, async (req, res) => {
    try {
      const { metricId, manualFormula, sourceFields } = req.body;

      if (!metricId) {
        return res.status(400).json({
          success: false,
          error: 'metricId is required',
        });
      }

      // Validate formula if provided
      if (manualFormula) {
        const allowedVars = Object.keys(getAvailableFormulaVariables());
        const validation = formulaEngine.validateFormula(manualFormula, allowedVars);

        if (!validation.valid) {
          return res.status(400).json({
            success: false,
            error: validation.error,
          });
        }
      }

      const updated = await reportMetricConfigService.updateConfig(metricId, {
        manualFormula,
        sourceFields,
      });

      res.json({
        success: true,
        data: updated,
      });
    } catch (error: any) {
      console.error('Error updating metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update metric configuration',
        message: error.message,
      });
    }
  });

  // Reset metric configuration to default
  app.delete('/api/report-metrics/config/:metricId', isAuthenticated, async (req, res) => {
    try {
      const reset = await reportMetricConfigService.resetConfig(req.params.metricId);
      res.json({
        success: true,
        data: reset,
      });
    } catch (error: any) {
      console.error('Error resetting metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reset metric configuration',
        message: error.message,
      });
    }
  });

  // ===== Formula Validation API =====

  // Validate formula syntax
  app.post('/api/formula/validate', isAuthenticated, async (req, res) => {
    try {
      const { formula } = req.body;

      if (!formula || typeof formula !== 'string') {
        return res.status(400).json({
          success: false,
          error: 'Formula is required',
        });
      }

      const allowedVars = Object.keys(getAvailableFormulaVariables());
      const validation = formulaEngine.validateFormula(formula, allowedVars);

      res.json({
        success: true,
        data: validation,
      });
    } catch (error: any) {
      console.error('Error validating formula:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to validate formula',
        message: error.message,
      });
    }
  });

  // ===== KPI Calculator API Routes =====

  // Get detailed KPI calculation breakdown
  app.get('/api/kpi-calculator/detail', isAuthenticated, async (req, res) => {
    try {
      const period = (req.query.period as string) || 'monthly';
      const baseDate = req.query.baseDate as string | undefined;
      const startDate = req.query.startDate as string | undefined;
      const endDate = req.query.endDate as string | undefined;

      // Get date range using public helper
      const serviceDateRange = totalReportService.getDateRange(
        period as any,
        baseDate ? new Date(baseDate) : new Date(),
        startDate ? new Date(startDate) : undefined,
        endDate ? new Date(endDate) : undefined
      );

      const warnings: string[] = [];

      // Fetch raw data using public helper
      const rawDataResult = await totalReportService.fetchRawData(serviceDateRange, warnings);

      // Get last sync time from storage if available
      let lastSync: string | null = null;
      if (rawDataResult.dataSource === 'storage') {
        const spreadsheets = await storage.listSpreadsheets();
        const sheets = spreadsheets.filter(s =>
          s.name.includes('é«”é©—èª²') || s.name.includes('EODs')
        );
        if (sheets.length > 0 && sheets[0].lastSyncAt) {
          lastSync = sheets[0].lastSyncAt.toISOString();
        }
      }

      // Calculate with full details
      const { calculateAllKPIs } = await import('./services/kpi-calculator');
      const result = await calculateAllKPIs({
        attendance: rawDataResult.attendanceData,
        purchases: rawDataResult.purchaseData,
        deals: rawDataResult.eodsData,
      });

      // Determine mode
      const mode = rawDataResult.attendanceData.length === 0 &&
                   rawDataResult.purchaseData.length === 0 &&
                   rawDataResult.eodsData.length === 0
                   ? 'mock'
                   : (rawDataResult.dataSource === 'supabase' ? 'supabase' : 'storage');

      res.json({
        success: true,
        data: {
          mode,
          rawDataSummary: {
            source: rawDataResult.dataSource,
            attendance: {
              count: rawDataResult.attendanceData.length,
              source: rawDataResult.dataSource,
            },
            purchases: {
              count: rawDataResult.purchaseData.length,
              source: rawDataResult.dataSource,
            },
            deals: {
              count: rawDataResult.eodsData.length,
              source: rawDataResult.dataSource,
            },
            dateRange: serviceDateRange,
            lastSync,
          },
          calculationDetail: result.calculationDetail,
          summaryMetrics: result.summaryMetrics,
          warnings: Array.from(new Set([...warnings, ...result.warnings])), // Deduplicate warnings
        },
      });
    } catch (error: any) {
      console.error('Error calculating KPI details:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to calculate KPI details',
        message: error.message,
      });
    }
  });

  // ===== Sheet Mappings API Routes =====

  // Development mode - Get all sheet mappings without auth (for testing)
  if (process.env.NODE_ENV !== 'production') {
    app.get('/api/dev/sheet-mappings', async (req, res) => {
      try {
        const mappings = await storage.getSheetMappings();
        res.json({
          success: true,
          data: mappings,
        });
      } catch (error: any) {
        console.error('Error fetching sheet mappings:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to fetch sheet mappings',
          message: error.message,
        });
      }
    });

    app.get('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;
        const mapping = await storage.getSheetMapping(sheetType as any);

        if (!mapping) {
          return res.status(404).json({
            success: false,
            error: 'Sheet mapping not found',
          });
        }

        res.json({
          success: true,
          data: mapping,
        });
      } catch (error: any) {
        console.error('Error fetching sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to fetch sheet mapping',
          message: error.message,
        });
      }
    });

    app.post('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;
        const updates = req.body;

        if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
          });
        }

        const updated = await storage.updateSheetMapping(sheetType as any, updates);

        res.json({
          success: true,
          data: updated,
        });
      } catch (error: any) {
        console.error('Error updating sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to update sheet mapping',
          message: error.message,
        });
      }
    });

    app.delete('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;

        if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
          });
        }

        const reset = await storage.resetSheetMapping(sheetType as any);

        res.json({
          success: true,
          data: reset,
        });
      } catch (error: any) {
        console.error('Error resetting sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to reset sheet mapping',
          message: error.message,
        });
      }
    });
  }

  // Get all sheet mappings
  app.get('/api/sheet-mappings', isAuthenticated, async (req, res) => {
    try {
      const mappings = await storage.getSheetMappings();
      res.json({
        success: true,
        data: mappings,
      });
    } catch (error: any) {
      console.error('Error fetching sheet mappings:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch sheet mappings',
        message: error.message,
      });
    }
  });

  // Get specific sheet mapping
  app.get('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;
      const mapping = await storage.getSheetMapping(sheetType as any);

      if (!mapping) {
        return res.status(404).json({
          success: false,
          error: 'Sheet mapping not found',
        });
      }

      res.json({
        success: true,
        data: mapping,
      });
    } catch (error: any) {
      console.error('Error fetching sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch sheet mapping',
        message: error.message,
      });
    }
  });

  // Update sheet mapping
  app.post('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;
      const updates = req.body;

      // Validate sheetType
      if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
        });
      }

      const updated = await storage.updateSheetMapping(sheetType as any, updates);

      res.json({
        success: true,
        data: updated,
      });
    } catch (error: any) {
      console.error('Error updating sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update sheet mapping',
        message: error.message,
      });
    }
  });

  // Reset sheet mapping to default
  app.delete('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;

      // Validate sheetType
      if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
        });
      }

      const reset = await storage.resetSheetMapping(sheetType as any);

      res.json({
        success: true,
        data: reset,
      });
    } catch (error: any) {
      console.error('Error resetting sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reset sheet mapping',
        message: error.message,
      });
    }
  });

  // ===== Total Report API Routes =====

  // Validate trial class KPIs
  app.post('/api/reports/trial-class/validate-kpis', isAuthenticated, async (req, res) => {
    try {
      const { trialClassKPIRuleEngine } = await import('./services/kpi-rule-engine');
      const { directSqlRepository } = await import('./services/reporting/direct-sql-repository');

      // ç²å–åŸå§‹æ•¸æ“š
      const dateRange = { start: '1970-01-01', end: '2099-12-31' };
      const [purchases, attendance, deals] = await Promise.all([
        directSqlRepository.getPurchases(dateRange),
        directSqlRepository.getAttendance(dateRange),
        directSqlRepository.getDeals(dateRange),
      ]);

      // é©—è­‰ KPI
      const validationReport = trialClassKPIRuleEngine.validateAllKPIs(
        req.body.currentMetrics,
        { purchases, attendance, deals }
      );

      res.json({
        success: true,
        data: validationReport,
      });
    } catch (error) {
      console.error('Error validating KPIs:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
      });
    }
  });

  // Auto-fix trial class KPIs
  app.post('/api/reports/trial-class/auto-fix-kpis', isAuthenticated, async (req, res) => {
    try {
      const { trialClassKPIRuleEngine } = await import('./services/kpi-rule-engine');
      const { directSqlRepository } = await import('./services/reporting/direct-sql-repository');

      // ç²å–åŸå§‹æ•¸æ“š
      const dateRange = { start: '1970-01-01', end: '2099-12-31' };
      const [purchases, attendance, deals] = await Promise.all([
        directSqlRepository.getPurchases(dateRange),
        directSqlRepository.getAttendance(dateRange),
        directSqlRepository.getDeals(dateRange),
      ]);

      // é©—è­‰ä¸¦è‡ªå‹•ä¿®æ­£
      const validationReport = trialClassKPIRuleEngine.validateAllKPIs(
        req.body.currentMetrics,
        { purchases, attendance, deals }
      );

      const fixedMetrics = trialClassKPIRuleEngine.autoFixKPIs(
        req.body.currentMetrics,
        validationReport
      );

      res.json({
        success: true,
        data: {
          validationReport,
          fixedMetrics,
        },
      });
    } catch (error) {
      console.error('Error auto-fixing KPIs:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
      });
    }
  });

  // Get trial class report data
  app.get('/api/reports/trial-class', isAuthenticated, requireModulePermission('trial_class_report'), async (req, res) => {
    try{
      const period = (req.query.period as 'daily' | 'weekly' | 'lastWeek' | 'monthly') || 'daily';
      const baseDate = req.query.baseDate as string | undefined;
      const noCache = req.query.noCache === 'true'; // æ”¯æ´å¼·åˆ¶åˆ·æ–°

      // Validate period
      if (!['daily', 'weekly', 'lastWeek', 'monthly', 'all'].includes(period)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid period. Must be one of: daily, weekly, lastWeek, monthly, all',
        });
      }

      // Validate baseDate if provided
      if (baseDate) {
        const date = new Date(baseDate);
        if (isNaN(date.getTime())) {
          return res.status(400).json({
            success: false,
            error: 'Invalid baseDate. Must be ISO date string',
          });
        }
      }

      // Generate reportï¼ˆå‚³éç•¶å‰ç”¨æˆ¶ ID é€²è¡Œæ¬Šé™éæ¿¾ï¼‰
      // æ”¯æ´ debug æ¨¡å¼ï¼šå¯é€é query parameter æŒ‡å®š userId é€²è¡Œæ¸¬è©¦
      let userId = (req as any).user?.id;

      // ğŸ”§ SKIP_AUTH æ¨¡å¼ï¼šä¸å‚³é userIdï¼ˆè®“ filterDataByPermission è·³éæ¬Šé™æª¢æŸ¥ï¼‰
      if (process.env.SKIP_AUTH === 'true') {
        if (req.query.debugUserId) {
          userId = req.query.debugUserId as string;
          console.log(`[DEBUG] Using debugUserId: ${userId}`);
        } else {
          userId = undefined; // ä¸å‚³é userIdï¼Œè®“æ¬Šé™éæ¿¾è·³é
        }
      }

      // ğŸš€ å¿«å–æ©Ÿåˆ¶ï¼šæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™
      const cacheKey = APICache.generateKey(CACHE_KEYS.TRIAL_CLASS_REPORT, {
        period,
        baseDate,
        userId: userId || 'all', // userId ä¹Ÿç´å…¥å¿«å–éµ
      });

      // å¦‚æœä¸æ˜¯å¼·åˆ¶åˆ·æ–°ï¼Œå…ˆæª¢æŸ¥å¿«å–
      if (!noCache) {
        const cachedData = apiCache.get(cacheKey);
        if (cachedData) {
          return res.json({
            success: true,
            data: cachedData,
            cached: true, // æ¨™è¨˜é€™æ˜¯å¿«å–è³‡æ–™
          });
        }
      }

      // å¿«å–æœªå‘½ä¸­æˆ–å¼·åˆ¶åˆ·æ–°ï¼ŒåŸ·è¡Œå¯¦éš›æŸ¥è©¢
      const startTime = Date.now();
      const reportData = await totalReportService.generateReport({
        period,
        baseDate,
        userId, // æ–°å¢ï¼šç”¨æ–¼æ¬Šé™éæ¿¾
      });
      const queryTime = Date.now() - startTime;
      console.log(`[API] /api/reports/trial-class query took ${queryTime}ms`);

      if (!reportData) {
        return res.json({
          success: false,
          error: 'No data available',
          message: 'ç„¡æ³•ç”¢ç”Ÿå ±è¡¨ï¼šè³‡æ–™ä¾†æºä¸è¶³æˆ–ç„¡è³‡æ–™ã€‚',
        });
      }

      // ğŸ’¾ å­˜å…¥å¿«å–ï¼ˆTTL: 5 åˆ†é˜ï¼‰
      apiCache.set(cacheKey, reportData, CACHE_TTL.MEDIUM);

      res.json({
        success: true,
        data: reportData,
        cached: false,
        queryTime: `${queryTime}ms`,
      });
    } catch (error: any) {
      console.error('Error generating total report:', error);

      // ğŸ›¡ï¸ ç‰¹åˆ¥è™•ç† Supabase pooler æ–·ç·šéŒ¯èª¤
      const errorMessage = error?.message || String(error);
      const isPoolerTimeout = errorMessage.includes('termination') ||
                             errorMessage.includes('shutdown') ||
                             errorMessage.includes('db_termination');

      if (isPoolerTimeout) {
        console.error('âš ï¸  Supabase Transaction Pooler timeout detected!');
        console.error('   This query took too long for the Transaction Pooler.');
        console.error('   Recommendation: Switch to Session Pooler (port 6543) in SUPABASE_URL');

        return res.status(503).json({
          success: false,
          error: 'Database query timeout',
          message: 'è³‡æ–™åº«æŸ¥è©¢è¶…æ™‚ã€‚è«‹ç¨å¾Œå†è©¦ï¼Œæˆ–è¯çµ¡ç®¡ç†å“¡åˆ‡æ›åˆ° Session Pooler ä»¥æ”¯æ´æ›´é•·çš„æŸ¥è©¢æ™‚é–“ã€‚',
        });
      }

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'ç”¢ç”Ÿå ±è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤',
      });
    }
  });

  // ğŸ§¹ æ¸…é™¤å ±è¡¨å¿«å– API
  app.post('/api/reports/clear-cache', isAuthenticated, async (req, res) => {
    try {
      const { type } = req.body;

      if (type === 'trial-class') {
        apiCache.clearByPattern(CACHE_KEYS.TRIAL_CLASS_REPORT);
      } else if (type === 'all') {
        apiCache.clear();
      } else {
        // é è¨­æ¸…é™¤æ‰€æœ‰å ±è¡¨å¿«å–
        apiCache.clearByPattern(CACHE_KEYS.TRIAL_CLASS_REPORT);
        apiCache.clearByPattern(CACHE_KEYS.OVERVIEW_REPORT);
        apiCache.clearByPattern(CACHE_KEYS.CONSULTANT_REPORT);
      }

      const stats = apiCache.getStats();
      res.json({
        success: true,
        message: 'å¿«å–å·²æ¸…é™¤',
        remainingCacheSize: stats.size,
      });
    } catch (error) {
      console.error('Error clearing cache:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to clear cache',
      });
    }
  });

  // ğŸ“Š å–å¾—å¿«å–ç‹€æ…‹ API
  app.get('/api/reports/cache-stats', isAuthenticated, async (req, res) => {
    const stats = apiCache.getStats();
    res.json({
      success: true,
      data: stats,
    });
  });

  // Consultant Report API - è«®è©¢å¸«å ±è¡¨
  app.get('/api/reports/consultants', isAuthenticated, requireModulePermission('consultant_report'), async (req, res) => {
    try {
      // è§£ææŸ¥è©¢åƒæ•¸
      const params: ConsultantReportParams = {
        period: (req.query.period as PeriodType) || 'month',
        startDate: req.query.startDate as string | undefined,
        endDate: req.query.endDate as string | undefined,
        consultantName: req.query.consultantName as string | undefined,
        leadSource: req.query.leadSource
          ? (req.query.leadSource as string).split(',').filter(s => s.trim())
          : undefined,
        planType: req.query.planType
          ? (req.query.planType as string).split(',').filter(s => s.trim())
          : undefined,
        dealStatus: (req.query.dealStatus as DealStatus) || 'all',
        compareWithPrevious: req.query.compareWithPrevious === 'true',
        compareWithLastYear: req.query.compareWithLastYear === 'true',
        trendGrouping: req.query.trendGrouping as TrendGrouping | undefined,
      };

      // é©—è­‰ period åƒæ•¸
      const validPeriods: PeriodType[] = ['today', 'week', 'month', 'quarter', 'year', 'all', 'custom'];
      if (!validPeriods.includes(params.period)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid period',
          message: `æœŸé–“é¡å‹ç„¡æ•ˆã€‚å¿…é ˆç‚º: ${validPeriods.join(', ')}`,
        });
      }

      // é©—è­‰ custom æœŸé–“å¿…é ˆæä¾›æ—¥æœŸ
      if (params.period === 'custom' && (!params.startDate || !params.endDate)) {
        return res.status(400).json({
          success: false,
          error: 'Missing date range',
          message: 'è‡ªè¨‚æœŸé–“å¿…é ˆæä¾› startDate å’Œ endDate åƒæ•¸',
        });
      }

      // é©—è­‰ dealStatus åƒæ•¸
      const validStatuses: DealStatus[] = ['all', 'closed', 'in_progress', 'lost'];
      if (!validStatuses.includes(params.dealStatus)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid deal status',
          message: `æˆäº¤ç‹€æ…‹ç„¡æ•ˆã€‚å¿…é ˆç‚º: ${validStatuses.join(', ')}`,
        });
      }

      console.log('[Consultant Report] Generating report with params:', params);

      // ç”Ÿæˆå ±è¡¨
      const report = await generateConsultantReport(params);

      res.json({
        success: true,
        data: report,
      });
    } catch (error: any) {
      console.error('[Consultant Report] Error generating report:', error);

      // è™•ç† PostgreSQL é€£ç·šéŒ¯èª¤
      const errorMessage = error?.message || String(error);
      const isDbError = errorMessage.includes('database') ||
                       errorMessage.includes('connection') ||
                       errorMessage.includes('ECONNREFUSED');

      if (isDbError) {
        return res.status(503).json({
          success: false,
          error: 'Database connection error',
          message: 'è³‡æ–™åº«é€£ç·šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦',
        });
      }

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'ç”¢ç”Ÿè«®è©¢å¸«å ±è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      });
    }
  });

  // Consultant Report - è¶¨å‹¢åœ–è³‡æ–™ API (ç¨ç«‹ endpoint é¿å…æ•´é é‡æ–°è¼‰å…¥)
  app.get('/api/reports/consultants/trend', isAuthenticated, requireModulePermission('consultant_report'), async (req, res) => {
    try {
      const params: ConsultantReportParams = {
        period: (req.query.period as PeriodType) || 'month',
        consultantName: req.query.consultantName as string | undefined,
        trendGrouping: req.query.trendGrouping as TrendGrouping | undefined,
        dealStatus: 'all',
        compareWithPrevious: false,
        compareWithLastYear: false,
      };

      // è¶¨å‹¢åœ–é¡¯ç¤ºå…¨éƒ¨æ­·å²æ•¸æ“šï¼Œæ‰€ä»¥ dateRange åªæ˜¯å½¢å¼åƒæ•¸
      const dateRange = { start: '', end: '' };

      const trendData = await getTrendData(params, dateRange);

      res.json({
        success: true,
        data: trendData,
      });
    } catch (error: any) {
      console.error('[Consultant Report Trend] Error:', error);

      const errorMessage = error?.message || String(error);
      const isDbError = errorMessage.includes('database') ||
                       errorMessage.includes('connection') ||
                       errorMessage.includes('ECONNREFUSED');

      if (isDbError) {
        return res.status(503).json({
          success: false,
          error: 'Database connection error',
          message: 'è³‡æ–™åº«é€£ç·šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦',
        });
      }

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'å–å¾—è¶¨å‹¢è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      });
    }
  });

  // Consultant Report - è«®è©¢åå–®è©³æƒ… API
  app.get('/api/reports/consultants/consultation-list', isAuthenticated, requireModulePermission('consultant_report'), async (req, res) => {
    try {
      // è§£ææŸ¥è©¢åƒæ•¸ï¼ˆæ“´å±•æ”¯æ´æ–°ç¯©é¸å’Œæ’åºï¼‰
      const params: ConsultantReportParams & {
        setterName?: string;
        leadSourceFilter?: string;
        statusFilter?: string;
        sortBy?: string;
        sortOrder?: 'ASC' | 'DESC';
      } = {
        period: (req.query.period as PeriodType) || 'month',
        startDate: req.query.startDate as string | undefined,
        endDate: req.query.endDate as string | undefined,
        consultantName: req.query.consultantName as string | undefined,
        setterName: req.query.setterName as string | undefined,
        dealStatus: (req.query.dealStatus as DealStatus) || 'all',
        leadSourceFilter: req.query.leadSourceFilter as string | undefined,
        statusFilter: req.query.statusFilter as string | undefined,
        sortBy: req.query.sortBy as string | undefined,
        sortOrder: (req.query.sortOrder as 'ASC' | 'DESC') || 'DESC',
      };

      console.log('[Consultation List] Fetching consultation list with params:', params);

      // æŸ¥è©¢è«®è©¢åå–®
      const consultationList = await getConsultationList(params);

      // èª¿è©¦ï¼šæª¢æŸ¥è¿”å›çš„è³‡æ–™
      if (consultationList.length > 0) {
        console.log('[Consultation List] Sample data:', JSON.stringify(consultationList[0], null, 2));
      }

      res.json({
        success: true,
        data: consultationList,
      });
    } catch (error: any) {
      console.error('[Consultation List] Error fetching consultation list:', error);

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'æŸ¥è©¢è«®è©¢åå–®æ™‚ç™¼ç”ŸéŒ¯èª¤',
      });
    }
  });

  // Consultant Report - ä¾†æºå¹³å‡å€¼è©³ç´°è³‡æ–™ API
  app.get('/api/reports/consultants/lead-source-average-details', isAuthenticated, requireModulePermission('consultant_report'), async (req, res) => {
    try {
      const leadSource = req.query.leadSource as string;

      if (!leadSource) {
        return res.status(400).json({
          success: false,
          message: 'ç¼ºå°‘å¿…è¦åƒæ•¸: leadSource',
        });
      }

      const params: ConsultantReportParams = {
        period: (req.query.period as PeriodType) || 'month',
        startDate: req.query.startDate as string,
        endDate: req.query.endDate as string,
        consultantName: req.query.consultantName as string,
      };

      console.log('[Lead Source Average Details] Fetching details:', { leadSource, params });

      const details = await getLeadSourceAverageDetails(leadSource, params);

      res.json({
        success: true,
        data: details,
      });
    } catch (error: any) {
      console.error('[Lead Source Average Details] Error:', error);

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'æŸ¥è©¢ä¾†æºå¹³å‡å€¼è©³ç´°è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤',
      });
    }
  });

  // Consultant AI Report - ç”Ÿæˆ AI åˆ†æå ±å‘Š
  // å¿«å–æ©Ÿåˆ¶ï¼šåŒä¸€å¤©åŒæœŸé–“åªç”Ÿæˆä¸€æ¬¡ï¼Œé™¤éä½¿ç”¨ forceRefresh
  app.post('/api/reports/consultants/ai-report', isAuthenticated, requireModulePermission('consultant_report'), async (req, res) => {
    try {
      const params: ConsultantReportParams = {
        period: (req.body.period as PeriodType) || 'month',
        startDate: req.body.startDate as string,
        endDate: req.body.endDate as string,
        consultantName: req.body.consultantName as string,
        leadSource: req.body.leadSource,
        planType: req.body.planType,
        dealStatus: (req.body.dealStatus as DealStatus) || 'all',
        compareWithPrevious: req.body.compareWithPrevious === true,
        trendGrouping: (req.body.trendGrouping as TrendGrouping) || 'day',
      };

      // æ˜¯å¦å¼·åˆ¶é‡æ–°ç”Ÿæˆï¼ˆè·³éå¿«å–ï¼‰
      const forceRefresh = req.body.forceRefresh === true;

      console.log('[AI Report] Request with params:', { ...params, forceRefresh });

      // Get the full report data first
      const report = await generateConsultantReport(params);

      // Prepare AI report input
      const aiReportInput: AIReportInput = {
        kpiData: report.kpiData,
        ranking: report.ranking,
        setterRanking: report.setterRanking,
        leadSourceTable: report.leadSourceTable,
        charts: report.charts,
        period: params.period,
        dateRange: report.metadata.dateRange,
      };

      // Get or generate AI report (with caching)
      const aiReport = await getOrGenerateConsultantAIReport(aiReportInput, forceRefresh);

      console.log(`[AI Report] Report ${aiReport.fromCache ? 'retrieved from cache' : 'generated'} successfully`);

      res.json({
        success: true,
        data: aiReport,
      });
    } catch (error: any) {
      console.error('[AI Report] Error generating report:', error);

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: error.message || 'AI å ±å‘Šç”Ÿæˆæ™‚ç™¼ç”ŸéŒ¯èª¤',
      });
    }
  });

  // Slack Integration - Send AI Report to Slack
  app.post('/api/slack/send-ai-report', isAuthenticated, async (req, res) => {
    try {
      const { report, period, dateRange } = req.body;

      if (!report) {
        return res.status(400).json({
          success: false,
          error: 'Missing report data',
        });
      }

      const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;
      if (!slackWebhookUrl) {
        console.error('[Slack] SLACK_WEBHOOK_URL not configured');
        return res.status(500).json({
          success: false,
          error: 'Slack webhook not configured',
          message: 'è«‹åœ¨ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š SLACK_WEBHOOK_URL',
        });
      }

      // è½‰æ›æœŸé–“é¡¯ç¤ºåç¨±
      const periodLabel: Record<string, string> = {
        today: 'ä»Šæ—¥',
        yesterday: 'æ˜¨æ—¥',
        week: 'éå»ä¸ƒå¤©',
        month: 'æœ¬æœˆ',
        quarter: 'æœ¬å­£',
        year: 'æœ¬å¹´',
        all: 'å…¨éƒ¨',
        custom: 'è‡ªè¨‚æœŸé–“',
      };

      // å»ºç«‹ Slack è¨Šæ¯æ ¼å¼
      const blocks = [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: `ğŸ“Š è«®è©¢å¸«æ¥­ç¸¾å ±å‘Š - ${periodLabel[period] || period}`,
            emoji: true,
          },
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `ğŸ“… ${dateRange.start} ~ ${dateRange.end} | â° ${new Date(report.generatedAt).toLocaleString('zh-TW')}`,
            },
          ],
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*ğŸ“ ç¸½è¦½*\n${report.summary}`,
          },
        },
        { type: 'divider' },
      ];

      // æ·»åŠ å„å€å¡Š
      report.sections.forEach((section: { title: string; content: string }) => {
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*ğŸ“Œ ${section.title}*\n${section.content.substring(0, 2900)}`, // Slack é™åˆ¶æ¯å€‹ block 3000 å­—å…ƒ
          },
        });
      });

      // ç™¼é€åˆ° Slack
      const response = await fetch(slackWebhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ blocks }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('[Slack] Failed to send message:', errorText);
        throw new Error(`Slack API error: ${response.status}`);
      }

      console.log('[Slack] AI report sent successfully');

      res.json({
        success: true,
        message: 'å·²æˆåŠŸå‚³é€è‡³ Slack',
      });
    } catch (error: any) {
      console.error('[Slack] Error sending report:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to send to Slack',
        message: error.message,
      });
    }
  });

  // Dashboard Overview API - å„€è¡¨æ¿ç¸½è¦½æ•¸æ“š
  app.get('/api/reports/overview', isAuthenticated, async (req, res) => {
    try {
      const userId = (req as any).user?.id;

      // 1. å–å¾—æœ¬æœˆæ•¸æ“š
      const monthlyReport = await totalReportService.generateReport({
        period: 'monthly',
        userId,
      });

      // 2. å–å¾—æœ¬é€±æ•¸æ“š
      const weeklyReport = await totalReportService.generateReport({
        period: 'weekly',
        userId,
      });

      // 3. å–å¾—ä¸Šé€±æ•¸æ“š
      const lastWeekReport = await totalReportService.generateReport({
        period: 'lastWeek',
        userId,
      });

      // 4. å¾ eods_for_closers è¨ˆç®—è²¡å‹™æ•¸æ“š
      // æœ¬æœˆç‡Ÿæ”¶å’Œæ¯›åˆ©ç‡
      const monthlyFinancialQuery = `
        SELECT
          COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as monthly_revenue,
          COALESCE(AVG(
            CASE
              WHEN CAST(actual_amount AS NUMERIC) > 0 AND CAST(package_price AS NUMERIC) > 0
              THEN ((CAST(actual_amount AS NUMERIC) - (CAST(package_price AS NUMERIC) * 0.7)) / CAST(actual_amount AS NUMERIC) * 100)
              ELSE 0
            END
          ), 0) as profit_margin
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('month', CURRENT_DATE)
          AND deal_date < date_trunc('month', CURRENT_DATE) + interval '1 month'
          AND consultation_result = 'æˆäº¤'
      `;

      const monthlyFinancialResult = await queryDatabase(monthlyFinancialQuery);

      // æœ¬é€±ç‡Ÿæ”¶
      const weeklyRevenueQuery = `
        SELECT COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as weekly_revenue
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('week', CURRENT_DATE)
          AND deal_date < date_trunc('week', CURRENT_DATE) + interval '1 week'
          AND consultation_result = 'æˆäº¤'
      `;

      const weeklyRevenueResult = await queryDatabase(weeklyRevenueQuery);

      // ä¸Šé€±ç‡Ÿæ”¶
      const lastWeekRevenueQuery = `
        SELECT COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as last_week_revenue
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('week', CURRENT_DATE) - interval '1 week'
          AND deal_date < date_trunc('week', CURRENT_DATE)
          AND consultation_result = 'æˆäº¤'
      `;

      const lastWeekRevenueResult = await queryDatabase(lastWeekRevenueQuery);

      // 5. è¨ˆç®—å­¸ç”Ÿæ•¸æ“š
      const studentsQuery = `
        SELECT
          COUNT(DISTINCT student_email) as total_students,
          COUNT(DISTINCT CASE
            WHEN purchase_date >= date_trunc('month', CURRENT_DATE)
            THEN student_email
          END) as new_students_this_month
        FROM trial_class_purchases
        WHERE student_email IS NOT NULL
      `;

      const studentsResult = await queryDatabase(studentsQuery);

      // 6. çµ„è£å›æ‡‰
      const responseData = {
        // æœ¬æœˆç‡Ÿæ”¶æ¦‚æ³
        monthlyRevenue: parseFloat(monthlyFinancialResult.rows[0]?.monthly_revenue || 0),
        monthlyTarget: 2000000, // NT$ 2,000,000
        yearlyTarget: 20000000, // NT$ 20,000,000
        profitMargin: parseFloat(monthlyFinancialResult.rows[0]?.profit_margin || 0),

        // é«”é©—èª²æ•¸æ“š
        trialConversionRate: monthlyReport?.summaryMetrics?.conversionRate || 0,
        pendingStudents: monthlyReport?.summaryMetrics?.pendingStudents || 0,
        weeklyTrials: weeklyReport?.summaryMetrics?.totalTrials || 0,

        // å­¸ç”Ÿæ•¸æ“š
        totalStudents: parseInt(studentsResult.rows[0]?.total_students || 0),
        newStudentsThisMonth: parseInt(studentsResult.rows[0]?.new_students_this_month || 0),

        // æœ¬é€±è¶¨å‹¢ (vs ä¸Šé€±)
        weeklyTrends: {
          trials: {
            current: weeklyReport?.summaryMetrics?.totalTrials || 0,
            previous: lastWeekReport?.summaryMetrics?.totalTrials || 0,
          },
          conversions: {
            current: weeklyReport?.summaryMetrics?.totalConversions || 0,
            previous: lastWeekReport?.summaryMetrics?.totalConversions || 0,
          },
          revenue: {
            current: parseFloat(weeklyRevenueResult.rows[0]?.weekly_revenue || 0),
            previous: parseFloat(lastWeekRevenueResult.rows[0]?.last_week_revenue || 0),
          },
        },

        // æ•¸æ“šä¾†æºå…ƒæ•¸æ“š
        dataSourceMeta: monthlyReport?.dataSourceMeta || null,
      };

      res.json({
        success: true,
        data: responseData,
      });
    } catch (error) {
      console.error('Error generating overview:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate overview',
        details: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  });

  // ===== Debug API Routes =====

  // Debug: Check worksheet and data status
  app.get('/api/debug/worksheets/:id', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      console.log(`ğŸ” Debug request for worksheet: ${worksheetId}`);

      // Get worksheet info
      const worksheet = await storage.getWorksheet(worksheetId);
      if (!worksheet) {
        return res.status(404).json({
          error: 'Worksheet not found',
          worksheetId
        });
      }

      // Get worksheet data (all data, no pagination)
      const worksheetData = await storage.getWorksheetData(worksheetId, 1, 10000);

      // Get spreadsheet data
      const spreadsheetData = await storage.getSheetData(worksheet.spreadsheetId, 1, 10000);

      // Get all data for debugging
      const allSheetData = Array.from((storage as any).sheetData.values());

      // Filter data by various criteria for debugging
      const dataWithWorksheetId = allSheetData.filter((item: any) => item.worksheetId === worksheetId);
      const dataWithSpreadsheetId = allSheetData.filter((item: any) => item.spreadsheetId === worksheet.spreadsheetId);
      const dataWithoutWorksheetId = allSheetData.filter((item: any) => !item.worksheetId && item.spreadsheetId === worksheet.spreadsheetId);

      res.json({
        worksheet: {
          id: worksheet.id,
          name: worksheet.worksheetName,
          spreadsheetId: worksheet.spreadsheetId,
          isEnabled: worksheet.isEnabled,
          headers: worksheet.headers,
          rowCount: worksheet.rowCount
        },
        data: {
          worksheetData: {
            count: worksheetData.length,
            sample: worksheetData.slice(0, 3)
          },
          spreadsheetData: {
            count: spreadsheetData.length,
            sample: spreadsheetData.slice(0, 3)
          },
          allDataStats: {
            total: allSheetData.length,
            withWorksheetId: dataWithWorksheetId.length,
            withSpreadsheetId: dataWithSpreadsheetId.length,
            withoutWorksheetId: dataWithoutWorksheetId.length
          },
          sampleDataWithoutWorksheetId: dataWithoutWorksheetId.slice(0, 3)
        },
        recommendation: worksheetData.length === 0 && dataWithoutWorksheetId.length > 0
          ? 'Found data without worksheetId - this might be the issue'
          : worksheetData.length === 0
            ? 'No data found - worksheet needs to be synced'
            : 'Data found successfully'
      });

    } catch (error) {
      console.error('Debug error:', error);
      res.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Debug: List all worksheets in a spreadsheet
  app.get('/api/debug/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const spreadsheetId = req.params.id;
      console.log(`ğŸ” Debug request for spreadsheet worksheets: ${spreadsheetId}`);

      const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
      const worksheets = await storage.getWorksheets(spreadsheetId);

      const worksheetDetails = [];
      for (const worksheet of worksheets) {
        const worksheetData = await storage.getWorksheetData(worksheet.id, 1, 10000);
        worksheetDetails.push({
          id: worksheet.id,
          name: worksheet.worksheetName,
          isEnabled: worksheet.isEnabled,
          headers: worksheet.headers,
          dataRowCount: worksheetData.length,
          hasData: worksheetData.length > 0
        });
      }

      res.json({
        spreadsheet: spreadsheet ? {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId
        } : null,
        worksheets: worksheetDetails,
        summary: {
          total: worksheets.length,
          enabled: worksheets.filter(w => w.isEnabled).length,
          withData: worksheetDetails.filter(w => w.hasData).length
        }
      });

    } catch (error) {
      console.error('Debug error:', error);
      res.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ===== æˆ°åŠ›å ±è¡¨ API =====

  // ç”Ÿæˆæˆ°åŠ›å ±è¡¨
  app.post('/api/reports/generate', async (req, res) => {
    try {
      const { type, date } = req.body;

      if (!type || !['daily', 'weekly'].includes(type)) {
        return res.status(400).json({ success: false, error: 'Invalid report type. Must be "daily" or "weekly"' });
      }

      if (!date) {
        return res.status(400).json({ success: false, error: 'Date is required' });
      }

      // èª¿ç”¨å ±è¡¨ç”Ÿæˆæœå‹™
      const reportService = await import('./services/deprecated/integrated-report-service');
      const report = await reportService.integratedReportService.generateReport({ type, date });

      res.json({ success: true, data: report });
    } catch (error: any) {
      console.error('Error generating report:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to generate report' });
    }
  });

  // ç²å–å ±è¡¨åˆ—è¡¨
  app.get('/api/reports', async (req, res) => {
    try {
      const type = req.query.type as string | undefined;
      const limit = parseInt(req.query.limit as string) || 10;

      const reportService = await import('./services/deprecated/integrated-report-service');
      const reports = await reportService.integratedReportService.getReports(type, limit);

      res.json({ success: true, data: reports });
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch reports' });
    }
  });

  // ç²å–ç‰¹å®šå ±è¡¨
  app.get('/api/reports/:id', async (req, res) => {
    try {
      const reportService = await import('./services/deprecated/integrated-report-service');
      const report = await reportService.integratedReportService.getReport(req.params.id);

      if (!report) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json({ success: true, data: report });
    } catch (error) {
      console.error('Error fetching report:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch report' });
    }
  });

  // æ›´æ–°å ±è¡¨ AI å»ºè­°
  app.put('/api/reports/:id/insights', async (req, res) => {
    try {
      const { insights } = req.body;

      if (!insights || typeof insights !== 'string') {
        return res.status(400).json({ success: false, error: 'Insights text is required' });
      }

      const reportService = await import('./services/deprecated/integrated-report-service');
      const updatedReport = await reportService.integratedReportService.updateReportInsights(req.params.id, insights);

      if (!updatedReport) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json({ success: true, data: updatedReport });
    } catch (error: any) {
      console.error('Error updating report insights:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to update insights' });
    }
  });

  // ===== AI KPI å®šç¾© API =====

  // è§£æè‡ªç„¶èªè¨€ KPI å®šç¾©
  app.post('/api/kpi/parse-definition', async (req, res) => {
    try {
      const { kpiName, definition } = req.body;

      if (!kpiName || !definition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName and definition are required'
        });
      }

      const { parseKPIDefinition } = await import('./services/ai-kpi-definition-parser');
      const result = await parseKPIDefinition(kpiName, definition);

      if (!result.success) {
        return res.status(400).json({
          success: false,
          error: result.error
        });
      }

      res.json({
        success: true,
        parsed: result.parsed
      });
    } catch (error: any) {
      console.error('Error parsing KPI definition:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to parse definition'
      });
    }
  });

  // é è¦½ KPI è¨ˆç®—çµæœ
  app.post('/api/kpi/preview-calculation', async (req, res) => {
    try {
      const { kpiName, definition, parameters } = req.body;

      if (!kpiName || !definition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName and definition are required'
        });
      }

      const supabase = getSupabaseClient();
      const { calculatePreview } = await import('./services/ai-kpi-definition-parser');

      const preview = await calculatePreview(
        kpiName,
        definition,
        parameters || {},
        supabase
      );

      res.json({
        success: true,
        preview
      });
    } catch (error: any) {
      console.error('Error calculating preview:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to calculate preview'
      });
    }
  });

  // å„²å­˜ KPI å®šç¾©
  app.post('/api/kpi/save-definition', async (req, res) => {
    try {
      const { kpiName, naturalLanguage, parsedDefinition, parameters } = req.body;

      if (!kpiName || !naturalLanguage || !parsedDefinition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName, naturalLanguage, and parsedDefinition are required'
        });
      }

      // Store the custom definition in report metric config
      await reportMetricConfigService.updateConfig(kpiName, {
        manualFormula: naturalLanguage, // Store natural language as manual formula
        description: `è‡ªè¨‚å®šç¾©ï¼š${parsedDefinition.numerator.label} / ${parsedDefinition.denominator.label}`,
        metadata: {
          parsedDefinition,
          parameters: parameters || {},
          updatedAt: new Date().toISOString()
        }
      });

      res.json({
        success: true,
        message: 'KPI definition saved successfully'
      });
    } catch (error: any) {
      console.error('Error saving KPI definition:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to save definition'
      });
    }
  });

  // ===== AI æ¬„ä½å°æ‡‰ API =====

  // åˆ†æå·¥ä½œè¡¨æ¬„ä½ä¸¦å»ºè­°å°æ‡‰
  app.post('/api/worksheets/:id/analyze-fields', async (req, res) => {
    try {
      const { id } = req.params;
      const { googleColumns, supabaseTable } = req.body;

      if (!googleColumns || !Array.isArray(googleColumns)) {
        return res.status(400).json({
          success: false,
          error: 'googleColumns array is required'
        });
      }

      if (!supabaseTable) {
        return res.status(400).json({
          success: false,
          error: 'supabaseTable is required'
        });
      }

      // å–å¾—ç›®æ¨™è¡¨çš„æ¬„ä½
      const { SUPABASE_SCHEMAS } = await import('./services/ai-field-mapper');
      const schema = SUPABASE_SCHEMAS[supabaseTable];

      if (!schema) {
        return res.status(400).json({
          success: false,
          error: `Unknown table: ${supabaseTable}. Available: ${Object.keys(SUPABASE_SCHEMAS).join(', ')}`
        });
      }

      const supabaseColumns = schema.columns.map(col => col.name);

      // å»ºç«‹ AI Field Mapper ä¸¦åˆ†æ
      const { createAIFieldMapper } = await import('./services/ai-field-mapper');
      const mapper = createAIFieldMapper();

      const worksheet = await storage.getWorksheet(id);
      const worksheetName = worksheet?.worksheetName || 'Unknown';

      const analysis = await mapper.analyzeAndSuggest(
        googleColumns,
        supabaseColumns,
        supabaseTable,
        worksheetName
      );

      res.json({
        success: true,
        data: analysis
      });

    } catch (error: any) {
      console.error('Error analyzing fields:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to analyze fields'
      });
    }
  });

  // å–å¾—å¯ç”¨çš„è¡¨ schemas
  app.get('/api/field-mapping/schemas', async (req, res) => {
    try {
      const { SUPABASE_SCHEMAS } = await import('./services/ai-field-mapper');
      const schemas = Object.keys(SUPABASE_SCHEMAS);

      res.json({
        success: true,
        data: schemas
      });
    } catch (error: any) {
      console.error('Error fetching schemas:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch schemas'
      });
    }
  });

  // å–å¾—ç‰¹å®šè¡¨çš„ schema
  app.get('/api/field-mapping/schemas/:tableName', async (req, res) => {
    try {
      const { tableName } = req.params;
      const { getTableColumns } = await import('./services/reporting/introspect-service');

      // å‹•æ…‹è®€å–è³‡æ–™åº«æ¬„ä½ï¼ˆæ”¯æ´ä¸­æ–‡æ¬„ä½åç¨±ï¼‰
      const columns = await getTableColumns(tableName);

      if (!columns || columns.length === 0) {
        return res.status(404).json({
          success: false,
          error: `Table not found or has no columns: ${tableName}`
        });
      }

      // è½‰æ›ç‚ºå‰ç«¯éœ€è¦çš„æ ¼å¼
      const schema = {
        tableName: tableName,
        columns: columns.map(col => ({
          name: col.column_name,
          type: col.data_type,
          required: col.is_nullable === 'NO',
          description: col.column_comment || ''
        }))
      };

      res.json({
        success: true,
        data: schema
      });
    } catch (error: any) {
      console.error('Error fetching schema:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch schema'
      });
    }
  });

  // å„²å­˜æ¬„ä½å°æ‡‰
  app.post('/api/worksheets/:id/save-mapping', async (req, res) => {
    try {
      const { id } = req.params;
      const { supabaseTable, mappings } = req.body;

      if (!supabaseTable || !mappings || !Array.isArray(mappings)) {
        return res.status(400).json({
          success: false,
          error: 'supabaseTable and mappings array are required'
        });
      }

      const supabase = getSupabaseClient();
      if (!supabase) {
        return res.status(503).json({
          success: false,
          error: 'Supabase not available'
        });
      }

      // åˆªé™¤èˆŠçš„å°æ‡‰ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      await supabase
        .from('field_mappings')
        .delete()
        .eq('worksheet_id', id);

      // æ’å…¥æ–°çš„å°æ‡‰
      const mappingRecords = mappings.map((m: any) => ({
        worksheet_id: id,
        google_column: m.googleColumn,
        supabase_column: m.supabaseColumn,
        data_type: m.dataType,
        transform_function: m.transformFunction || null,
        is_required: m.isRequired || false,
        ai_confidence: m.confidence,
        ai_reasoning: m.reasoning,
        is_confirmed: true,
        confirmed_by: 'user',
        confirmed_at: new Date().toISOString()
      }));

      const { error: insertError } = await supabase
        .from('field_mappings')
        .insert(mappingRecords);

      if (insertError) {
        throw insertError;
      }

      res.json({
        success: true,
        data: {
          worksheetId: id,
          supabaseTable,
          mappingsCount: mappings.length
        }
      });

    } catch (error: any) {
      console.error('Error saving mappings:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to save mappings'
      });
    }
  });

  // å–å¾—å·²å„²å­˜çš„æ¬„ä½å°æ‡‰
  app.get('/api/worksheets/:id/mapping', async (req, res) => {
    try {
      const { id } = req.params;

      const supabase = getSupabaseClient();
      if (!supabase) {
        return res.status(503).json({
          success: false,
          error: 'Supabase not available'
        });
      }

      const { data, error } = await supabase
        .from('field_mappings')
        .select('*')
        .eq('worksheet_id', id)
        .eq('is_active', true);

      if (error) {
        throw error;
      }

      res.json({
        success: true,
        data: data || []
      });

    } catch (error: any) {
      console.error('Error fetching mappings:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch mappings'
      });
    }
  });
  // ===== AI Insights API Routes =====

  // AI å¡ç‰‡è³‡æ–™ API
  app.get('/api/ai/insights', isAuthenticated, async (req, res) => {
    try {
      // å‹•æ…‹ import AI Chat Service
      const { aiChatService } = await import('./services/ai-chat-service');

      // å–å¾—æœ¬æœˆè³‡æ–™
      const today = new Date();
      const dateRange = {
        start: `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`,
        end: `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`,
      };

      const warnings: string[] = [];
      const { totalReportService } = await import('./services/reporting/total-report-service');
      const { attendanceData, purchaseData, eodsData } = await totalReportService.fetchRawData(
        dateRange,
        warnings
      );

      // è¨ˆç®—å„ç¨®çµ±è¨ˆè³‡æ–™
      const teachers = (aiChatService as any).calculateTeacherStats(attendanceData, purchaseData, eodsData);
      const consultants = (aiChatService as any).calculateConsultantStats(eodsData);
      const revenue = (aiChatService as any).calculateRevenue(eodsData);
      const students = (aiChatService as any).calculateStudentStats(attendanceData, purchaseData, eodsData);

      res.json({
        success: true,
        data: {
          topTeachers: teachers.slice(0, 3),
          topConsultants: consultants.slice(0, 3),
          revenue,
          students,
          dataQuality: {
            warnings,
            attendanceCount: attendanceData.length,
            purchaseCount: purchaseData.length,
            dealsCount: eodsData.length,
          },
        },
      });
    } catch (error: any) {
      console.error('AI Insights error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI æ´å¯Ÿå¤±æ•—',
      });
    }
  });

  // ===== AI Chat API Routes =====

  // AI å°è©± API
  app.post('/api/ai/chat', isAuthenticated, async (req, res) => {
    try {
      const { question, history } = req.body;

      if (!question || typeof question !== 'string') {
        return res.status(400).json({
          success: false,
          error: 'Invalid question',
        });
      }

      // å‹•æ…‹ import AI Chat Service
      const { aiChatService } = await import('./services/ai-chat-service');

      const response = await aiChatService.chat(question, history || []);

      res.json({
        success: true,
        data: response,
      });
    } catch (error: any) {
      console.error('AI Chat error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI å°è©±å¤±æ•—',
      });
    }
  });

  // ===== Raw Data MVP API Routes =====

  // MVP ç¸½å ±è¡¨ APIï¼ˆä½¿ç”¨ raw_dataï¼‰
  app.get('/api/reports/raw-data-mvp', async (req, res) => {
    try {
      const { period = 'monthly' } = req.query;
      const rawDataService = await import('./services/raw-data-query-service');

      const [kpis, teacherStats, pipeline] = await Promise.all([
        rawDataService.calculateKPIs(period as any),
        rawDataService.getTeacherStats(),
        rawDataService.getStudentPipeline()
      ]);

      res.json({
        success: true,
        data: {
          kpis,
          teacherStats: teacherStats.slice(0, 3), // TOP 3
          pipeline
        },
        metadata: {
          dataSource: 'raw_data',
          queryTime: Date.now(),
          period
        }
      });
    } catch (error: any) {
      console.error('Raw data MVP error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // è·¨è¡¨æŸ¥è©¢ API
  app.post('/api/raw-data/cross-table-query', async (req, res) => {
    try {
      const { teacher, status, month, package: pkg, minIntention } = req.body;
      const rawDataService = await import('./services/raw-data-query-service');

      const result = await rawDataService.crossTableQuery({
        teacher,
        status,
        month,
        package: pkg,
        minIntention
      });

      res.json({
        success: true,
        data: result,
        count: result.length
      });
    } catch (error: any) {
      console.error('Cross table query error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // AI å°è©± APIï¼ˆé‡å° raw_data å„ªåŒ–ï¼‰
  app.post('/api/ai/chat-raw-data', async (req, res) => {
    try {
      const { question, context } = req.body;

      if (!question) {
        return res.status(400).json({
          success: false,
          error: 'è«‹è¼¸å…¥å•é¡Œ'
        });
      }

      const rawDataService = await import('./services/raw-data-query-service');

      // åˆ†æå•é¡Œï¼Œæ±ºå®šä½¿ç”¨å“ªç¨®æŸ¥è©¢æ–¹å¼
      const lowerQ = question.toLowerCase();
      let data: any = {};
      let queryType = 'simple';

      // æª¢æ¸¬ä¸Šèª²è¨˜éŒ„æŸ¥è©¢
      if (lowerQ.includes('ä¸Šèª²') || lowerQ.includes('å¹¾ä½å­¸ç”Ÿ')) {
        queryType = 'attendance';

        // æå–æ™‚é–“ç¯„åœ
        let timeFilter = undefined;
        if (lowerQ.includes('æœ¬é€±') || lowerQ.includes('é€™é€±')) {
          const now = new Date();
          const dayOfWeek = now.getDay();
          const startOfWeek = new Date(now);
          startOfWeek.setDate(now.getDate() - dayOfWeek);
          timeFilter = startOfWeek.toISOString().slice(0, 10);
        } else if (lowerQ.includes('æœ¬æœˆ') || lowerQ.includes('é€™å€‹æœˆ')) {
          timeFilter = new Date().toISOString().slice(0, 7);
        }

        const attendanceData = await rawDataService.fetchRawData('trial_class_attendance');

        // éæ¿¾æ™‚é–“ä¸¦æå–å­¸ç”Ÿè³‡è¨Š
        let filtered = attendanceData;
        if (timeFilter) {
          filtered = attendanceData.filter((row: any) => {
            const date = row.raw_data?.['ä¸Šèª²æ—¥æœŸ'] || row.raw_data?.['Date'] || row.class_date;
            return date && date.toString().startsWith(timeFilter);
          });
        }

        // çµ±è¨ˆå”¯ä¸€å­¸ç”Ÿ
        const uniqueStudents = new Set();
        data.students = filtered.map((row: any) => {
          const rawData = row.raw_data || {};
          const studentName = rawData['å­¸å“¡å§“å'] || rawData['Name'] || rawData['student_name'] || 'Unknown';
          const studentEmail = row.student_email || rawData['Email'] || rawData['email'];

          uniqueStudents.add(studentEmail || studentName);

          return {
            studentName,
            studentEmail,
            classDate: rawData['ä¸Šèª²æ—¥æœŸ'] || rawData['Date'] || row.class_date,
            teacher: rawData['è€å¸«'] || rawData['Teacher'] || row.teacher,
            package: rawData['èª²ç¨‹'] || rawData['Course'],
            rawData
          };
        });

        data.uniqueCount = uniqueStudents.size;
      }
      // æª¢æ¸¬è·¨è¡¨æŸ¥è©¢é—œéµå­—
      else if (lowerQ.includes('å‡é«˜éš') || lowerQ.includes('è½‰æ›') ||
          (lowerQ.includes('è€å¸«') && (lowerQ.includes('å­¸ç”Ÿ') || lowerQ.includes('æˆäº¤'))) ||
          lowerQ.includes('è²·èª²') || lowerQ.includes('æœ‰è²·') || lowerQ.includes('è³¼è²·')) {
        queryType = 'cross-table';

        // æå–åƒæ•¸
        const teacherMatch = question.match(/(vicky|karen|elena)/i);
        const teacher = teacherMatch ? teacherMatch[1].charAt(0).toUpperCase() + teacherMatch[1].slice(1) : undefined;
        const month = lowerQ.includes('æœ¬æœˆ') ? new Date().toISOString().slice(0, 7) : undefined;

        data.students = await rawDataService.crossTableQuery({
          teacher,
          status: lowerQ.includes('å‡é«˜éš') ? 'å·²è½‰é«˜' : undefined,
          month
        });
      } else {
        // ç°¡å–®æŸ¥è©¢ï¼Œå–ç›¸é—œè¡¨è³‡æ–™
        queryType = 'simple';

        if (lowerQ.includes('è€å¸«') || lowerQ.includes('æ•™å¸«')) {
          data.teacherStats = await rawDataService.getTeacherStats();
        }

        if (lowerQ.includes('kpi') || lowerQ.includes('è½‰æ›') || lowerQ.includes('ç‡Ÿæ”¶')) {
          data.kpis = await rawDataService.calculateKPIs();
        }
      }

      // ç°¡åŒ–çš„å›ç­”ï¼ˆç›´æ¥å›å‚³è³‡æ–™ï¼‰
      let answer = '';

      if (data.students && queryType === 'attendance') {
        const total = data.students.length;
        const uniqueCount = data.uniqueCount || total;

        answer = `æ ¹æ“šè³‡æ–™åˆ†æï¼Œå…±æœ‰ ${uniqueCount} ä½å­¸ç”Ÿä¸Šèª²ï¼ˆ${total} å ‚èª²ï¼‰ï¼š\n\n`;

        data.students.slice(0, 10).forEach((s: any) => {
          answer += `â€¢ ${s.studentName}`;
          if (s.teacher) answer += ` - ${s.teacher} è€å¸«`;
          if (s.classDate) answer += ` (${s.classDate})`;
          answer += `\n`;
        });

        if (total > 10) {
          answer += `\n... é‚„æœ‰ ${total - 10} å ‚èª²\n`;
        }

        answer += `\nç¸½è¨ˆï¼š${uniqueCount} ä½å­¸ç”Ÿï¼Œ${total} å ‚èª²`;
      } else if (data.students) {
        const total = data.students.length;
        const totalAmount = data.students.reduce((sum: number, s: any) => sum + (s.amount || 0), 0);

        answer = `æ ¹æ“šè³‡æ–™åˆ†æï¼Œå…±æœ‰ ${total} ä½å­¸ç”Ÿç¬¦åˆæ¢ä»¶ï¼š\n\n`;

        data.students.slice(0, 10).forEach((s: any) => {
          answer += `â€¢ ${s.studentName} - ${s.package} (NT$ ${s.amount?.toLocaleString() || 0})\n`;
        });

        if (total > 10) {
          answer += `\n... é‚„æœ‰ ${total - 10} ä½å­¸ç”Ÿ\n`;
        }

        answer += `\nç¸½è¨ˆï¼š${total} ä½ï¼Œç¸½é‡‘é¡ NT$ ${totalAmount.toLocaleString()}`;
      } else if (data.kpis) {
        answer = `ç›®å‰ KPI æ•¸æ“šï¼š\n`;
        answer += `â€¢ è½‰æ›ç‡ï¼š${data.kpis.conversionRate.toFixed(1)}%\n`;
        answer += `â€¢ é«”é©—èª²å®Œæˆç‡ï¼š${data.kpis.trialCompletionRate.toFixed(1)}%\n`;
        answer += `â€¢ ç¸½ç‡Ÿæ”¶ï¼šNT$ ${data.kpis.totalRevenue.toLocaleString()}`;
      } else if (data.teacherStats) {
        answer = `æ•™å¸«ç¸¾æ•ˆçµ±è¨ˆï¼š\n\n`;
        data.teacherStats.slice(0, 3).forEach((t: any, i: number) => {
          answer += `${i + 1}. ${t.name}\n`;
          answer += `   æˆèª²æ•¸ï¼š${t.classCount}\n`;
          answer += `   å­¸ç”Ÿæ•¸ï¼š${t.studentCount}\n\n`;
        });
      } else {
        answer = 'æŠ±æ­‰ï¼Œæˆ‘ç„¡æ³•ç†è§£æ‚¨çš„å•é¡Œã€‚è«‹å˜—è©¦æ›´å…·é«”çš„å•æ³•ã€‚';
      }

      res.json({
        success: true,
        answer,
        data: data.students || data.kpis || data.teacherStats || [],
        queryType,
        dataUsed: Object.keys(data).length
      });

    } catch (error: any) {
      console.error('AI chat raw data error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // AI æ™ºèƒ½å­¸ç¿’æŸ¥è©¢ç«¯é»
  app.post('/api/ai/smart-query', async (req, res) => {
    try {
      const { question, teacherId } = req.body;

      if (!question) {
        return res.status(400).json({
          success: false,
          error: 'è«‹è¼¸å…¥å•é¡Œ'
        });
      }

      const aiLearning = await import('./services/ai-query-learning-service');

      console.log('ğŸ¯ Smart Query:', { question, teacherId });

      // 1. æª¢æŸ¥æ˜¯å¦å·²ç¶“å­¸éé¡ä¼¼å•é¡Œ
      const learned = await aiLearning.checkLearnedPattern(question, teacherId);

      if (learned) {
        // å·²å­¸éï¼Œç›´æ¥åŸ·è¡ŒæŸ¥è©¢
        console.log('âœ… ä½¿ç”¨å­¸ç¿’è¨˜éŒ„');
        console.log('ğŸ” åŸ·è¡ŒæŸ¥è©¢:', learned.query_config);

        // ç¢ºä¿ query_config æ˜¯ç‰©ä»¶ï¼ˆå¦‚æœæ˜¯å­—ä¸²å‰‡è§£æï¼‰
        const queryConfig = typeof learned.query_config === 'string'
          ? JSON.parse(learned.query_config)
          : learned.query_config;

        const queryResult = await aiLearning.executeQueryFromAnalysis(
          queryConfig,
          teacherId
        );

        const answer = aiLearning.formatAnswer(queryResult, queryConfig);

        return res.json({
          success: true,
          answer,
          data: queryResult.students || queryResult.data || [],
          learned: true,
          usageCount: learned.usage_count,
          intent: learned.intent
        });
      }

      // 2. æ–°å•é¡Œï¼Œä½¿ç”¨ AI åˆ†æ
      console.log('ğŸ¤– æ–°å•é¡Œï¼Œå‘¼å« OpenAI åˆ†æ...');
      const analysis = await aiLearning.analyzeQuestion(question, teacherId);

      // 3. åŸ·è¡ŒæŸ¥è©¢
      const queryResult = await aiLearning.executeQueryFromAnalysis(analysis, teacherId);
      const answer = aiLearning.formatAnswer(queryResult, analysis);

      // 4. è¿”å›çµæœï¼Œä½†éœ€è¦ä½¿ç”¨è€…ç¢ºèª
      res.json({
        success: true,
        answer,
        data: queryResult.students || queryResult.data || [],
        needConfirmation: true,
        analysis: {
          intent: analysis.intent,
          explanation: analysis.explanation,
          confidence: analysis.confidence
        },
        queryResult
      });

    } catch (error: any) {
      console.error('âŒ Smart query error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI æŸ¥è©¢å¤±æ•—'
      });
    }
  });

  // ç¢ºèªä¸¦å„²å­˜å­¸ç¿’
  app.post('/api/ai/confirm-learning', async (req, res) => {
    try {
      const { question, analysis, teacherId, confirmed } = req.body;

      if (!question || !analysis) {
        return res.status(400).json({
          success: false,
          error: 'ç¼ºå°‘å¿…è¦åƒæ•¸'
        });
      }

      const aiLearning = await import('./services/ai-query-learning-service');

      if (confirmed) {
        // å„²å­˜å­¸ç¿’çµæœ
        await aiLearning.saveLearnedQuery(question, analysis, teacherId);

        return res.json({
          success: true,
          message: 'âœ… å·²è¨˜ä½ï¼ä¸‹æ¬¡é‡åˆ°é¡ä¼¼å•é¡Œå°±ä¸ç”¨å†ç¢ºèªäº†'
        });
      } else {
        return res.json({
          success: true,
          message: 'è«‹é‡æ–°æè¿°æ‚¨çš„å•é¡Œ'
        });
      }
    } catch (error: any) {
      console.error('âŒ Confirm learning error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'å„²å­˜å­¸ç¿’å¤±æ•—'
      });
    }
  });

  // ==================== æˆæœ¬ç²åˆ©åˆ†æ API ====================

  // å–å¾—æŒ‡å®šæœˆä»½è³‡æ–™
  app.get('/api/cost-profit/records', isAuthenticated, requireModulePermission('cost_profit'), async (req, res) => {
    try {
      const schema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
      });

      const parsed = schema.safeParse(req.query);
      if (!parsed.success) {
        return res.status(400).json({ error: 'ç¼ºå°‘æˆ–æ ¼å¼éŒ¯èª¤çš„ year / month åƒæ•¸' });
      }

      const { costProfitService } = await import('./services/cost-profit-service');
      const records = await costProfitService.getRecordsByPeriod(parsed.data.year, parsed.data.month);
      res.json({ success: true, data: records });
    } catch (error: any) {
      console.error('æˆæœ¬ç²åˆ©è³‡æ–™æŸ¥è©¢éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // ç”¢ç”Ÿ AI é æ¸¬
  app.get('/api/cost-profit/prediction', async (req, res) => {
    try {
      const schema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
      });

      const parsed = schema.safeParse(req.query);
      if (!parsed.success) {
        return res.status(400).json({ error: 'ç¼ºå°‘æˆ–æ ¼å¼éŒ¯èª¤çš„ year / month åƒæ•¸' });
      }

      try {
        const { generateCostProfitPrediction } = await import('./services/cost-profit-ai-service');
        const suggestions = await generateCostProfitPrediction({
          year: parsed.data.year,
          month: parsed.data.month,
        });
        res.json({ success: true, data: suggestions });
      } catch (error: any) {
        console.error('æˆæœ¬ç²åˆ© AI é æ¸¬éŒ¯èª¤:', error);
        res.status(200).json({
          success: true,
          data: [],
          warning: 'AI é æ¸¬å¤±æ•—æˆ–æœªè¨­å®šï¼Œå·²è¿”å›ç©ºçµæœ',
        });
      }
    } catch (error: any) {
      console.error('æˆæœ¬ç²åˆ© AI é æ¸¬éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // å„²å­˜æŒ‡å®šæœˆä»½è³‡æ–™
  app.post('/api/cost-profit/save', async (req, res) => {
    try {
      const recordSchema = z.object({
        category_name: z.string().min(1),
        item_name: z.string().min(1),
        amount: z
          .union([z.number(), z.string(), z.null()])
          .transform((value) => {
            if (value === null || value === '') return null;
            const num = Number(value);
            return Number.isFinite(num) ? num : null;
          }),
        currency: z.enum(['TWD', 'USD', 'RMB']).optional().default('TWD'),
        exchange_rate_used: z.number().optional(),
        amount_in_twd: z.number().optional(),
        notes: z.union([z.string(), z.null()]).optional(),
        is_confirmed: z.coerce.boolean().optional(),
      });

      const bodySchema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
        records: z.array(recordSchema),
      });

      const parsed = bodySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: 'æäº¤å…§å®¹æ ¼å¼éŒ¯èª¤', details: parsed.error.format() });
      }

      const { costProfitService } = await import('./services/cost-profit-service');
      await costProfitService.saveMonthlyRecords({
        year: parsed.data.year,
        month: parsed.data.month,
        records: parsed.data.records.map((record) => ({
          category_name: record.category_name,
          item_name: record.item_name,
          amount: record.amount,
          currency: record.currency ?? 'TWD',
          exchange_rate_used: record.exchange_rate_used ?? null,
          amount_in_twd: record.amount_in_twd ?? null,
          notes: record.notes ?? null,
          is_confirmed: record.is_confirmed ?? false,
        })),
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error('æˆæœ¬ç²åˆ©å„²å­˜éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // ç²å–æ‰€æœ‰æˆæœ¬ç²åˆ©æ•¸æ“š
  app.get('/api/cost-profit', async (req, res) => {
    try {
      const { costProfitService } = await import('./services/cost-profit-service');
      const data = await costProfitService.getAllRecords();
      res.json(data);
    } catch (error: any) {
      console.error('æˆæœ¬ç²åˆ© API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ç²å–æˆæœ¬ç²åˆ©æ‘˜è¦çµ±è¨ˆ
  app.get('/api/cost-profit/summary', async (req, res) => {
    try {
      const { month, year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const summary = await costProfitService.getSummary(
        year ? parseInt(year as string) : undefined,
        month as string | undefined
      );

      res.json(summary);
    } catch (error: any) {
      console.error('æˆæœ¬ç²åˆ©æ‘˜è¦ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ç²å–æœˆåº¦å°æ¯”
  app.get('/api/cost-profit/monthly-comparison', async (req, res) => {
    try {
      const { year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const result = await costProfitService.getMonthlyComparison(
        year ? parseInt(year as string) : undefined
      );

      res.json(result);
    } catch (error: any) {
      console.error('æœˆåº¦å°æ¯” API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ç²å–åˆ†é¡çµ±è¨ˆ
  app.get('/api/cost-profit/category-stats', async (req, res) => {
    try {
      const { month, year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const stats = await costProfitService.getCategoryStats(
        year ? parseInt(year as string) : undefined,
        month as string | undefined
      );

      res.json(stats);
    } catch (error: any) {
      console.error('åˆ†é¡çµ±è¨ˆ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // è¡¨å–®å¡«å¯« API
  // ========================================

  // å–å¾—è€å¸«åå–®ï¼ˆå¾ users è¡¨æŸ¥è©¢ roles åŒ…å« 'teacher'ï¼‰- æ”¯æ´å¤šé‡è§’è‰²
  app.get('/api/teachers', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'teacher' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      // çµ„åˆå§“åï¼ˆåªç”¨ first_nameï¼Œä¸åŒ…å« last_nameã€Œè€å¸«ã€ï¼‰
      const teachers = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles  // è¿”å›æ‰€æœ‰è§’è‰²è³‡è¨Š
      }));

      res.json(teachers);
    } catch (error: any) {
      console.error('è€å¸«åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—é›»è¨ªäººå“¡åå–®ï¼ˆå¾ users è¡¨æŸ¥è©¢ roles åŒ…å« 'setter'ï¼‰
  app.get('/api/setters', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'setter' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const setters = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(setters);
    } catch (error: any) {
      console.error('é›»è¨ªäººå“¡åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—è«®è©¢äººå“¡åå–®ï¼ˆå¾ users è¡¨æŸ¥è©¢ roles åŒ…å« 'consultant'ï¼‰
  app.get('/api/consultants', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'consultant' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const consultants = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(consultants);
    } catch (error: any) {
      console.error('è«®è©¢äººå“¡åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—çœŸå·¥åå–®ï¼ˆå¾ users è¡¨æŸ¥è©¢ roles åŒ…å« 'employee'ï¼‰
  app.get('/api/staff', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'employee' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const staff = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(staff);
    } catch (error: any) {
      console.error('çœŸå·¥åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // é«”é©—èª²æ‰“å¡è¨˜éŒ„ API - å·²é·ç§»è‡³ Form Builder ç³»çµ±
  // è«‹ä½¿ç”¨ /api/forms/custom/trial-class-form-001 ç³»åˆ— API
  // ========================================

  // ========================================
  // è«®è©¢è¨˜éŒ„è¡¨å–® API
  // ========================================

  // POST - Submit new consultation record
  app.post('/api/forms/consultation', async (req, res) => {
    try {
      const {
        studentName,
        studentEmail,
        callerName,
        closerName,
        isOnline,
        leadSource,
        consultationResult,
        dealPackage,
        packageQuantity,
        paymentMethod,
        installmentPeriods,
        packagePrice,
        actualAmount,
        consultationDate,
        dealDate,
        notes,
      } = req.body;

      // Validate required fields
      if (!studentName || !closerName || !consultationResult || !consultationDate) {
        return res.status(400).json({ error: 'ç¼ºå°‘å¿…å¡«æ¬„ä½' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      // Calculate month, year, week number
      const consultDate = new Date(consultationDate);
      const month = consultDate.getMonth() + 1;
      const year = consultDate.getFullYear();

      // Calculate week number (ISO week)
      const firstDayOfYear = new Date(year, 0, 1);
      const pastDaysOfYear = (consultDate.getTime() - firstDayOfYear.getTime()) / 86400000;
      const weekNumber = Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);

      // Insert into eods_for_closers table
      const { data, error } = await supabase
        .from('eods_for_closers')
        .insert({
          student_name: studentName,
          student_email: studentEmail || null,
          setter_name: callerName || null,
          closer_name: closerName,
          is_show: isOnline || null,
          lead_source: leadSource || null,
          consultation_result: consultationResult,
          plan: dealPackage || null,
          package_quantity: packageQuantity ? parseFloat(packageQuantity) : null,
          payment_method: paymentMethod || null,
          installment_periods: installmentPeriods ? parseInt(installmentPeriods) : null,
          package_price: packagePrice ? parseFloat(packagePrice) : null,
          actual_amount: actualAmount ? parseFloat(actualAmount) : null,
          consultation_date: new Date(consultationDate).toISOString(),
          deal_date: dealDate ? new Date(dealDate).toISOString() : null,
          notes: notes || null,
          submitted_at: new Date().toISOString(),
          month,
          year,
          week_number: weekNumber,
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase æ’å…¥éŒ¯èª¤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: 'è«®è©¢è¨˜éŒ„å·²æˆåŠŸæäº¤',
        data,
      });
    } catch (error: any) {
      console.error('è«®è©¢è¡¨å–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - List consultation records with pagination
  app.get('/api/forms/consultation', async (req, res) => {
    try {
      const { page = '1', limit = '10' } = req.query;
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data, error, count } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact' })
        .order('consultation_date', { ascending: false })
        .order('created_at', { ascending: false })
        .range((pageNum - 1) * limitNum, pageNum * limitNum - 1);

      if (error) {
        console.error('Supabase æŸ¥è©¢éŒ¯èª¤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('è«®è©¢æŸ¥è©¢ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - Statistics (today/week/month counts)
  app.get('/api/forms/consultation/stats', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      const { count: todayCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', today);

      const { count: weekCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', weekAgo);

      const { count: monthCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', monthAgo);

      res.json({
        today: todayCount || 0,
        week: weekCount || 0,
        month: monthCount || 0,
      });
    } catch (error: any) {
      console.error('è«®è©¢çµ±è¨ˆ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // é›»è¨ªè¨˜éŒ„è¡¨å–® API
  // ========================================

  // POST - Submit new telemarketing call record
  app.post('/api/forms/telemarketing', async (req, res) => {
    try {
      const {
        studentName,
        studentPhone,
        studentEmail,
        callerName,
        callDate,
        callTime,
        callDuration,
        callResult,
        contactStatus,
        scheduledCallbackDate,
        interestLevel,
        interestedPackage,
        budgetRange,
        forwardedToConsultant,
        consultantName,
        notes,
      } = req.body;

      // Validate required fields
      if (!studentName || !studentPhone || !callerName || !callResult || !callDate) {
        return res.status(400).json({ error: 'ç¼ºå°‘å¿…å¡«æ¬„ä½' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      // Convert call duration from minutes to seconds
      const durationInSeconds = callDuration ? parseInt(callDuration) * 60 : null;

      // Insert into telemarketing_calls table
      const { data, error } = await supabase
        .from('telemarketing_calls')
        .insert({
          student_name: studentName,
          student_phone: studentPhone,
          student_email: studentEmail || null,
          caller_name: callerName,
          call_date: new Date(callDate).toISOString(),
          call_time: callTime || null,
          call_duration: durationInSeconds,
          call_result: callResult,
          contact_status: contactStatus || null,
          scheduled_callback_date: scheduledCallbackDate
            ? new Date(scheduledCallbackDate).toISOString()
            : null,
          interest_level: interestLevel || null,
          interested_package: interestedPackage || null,
          budget_range: budgetRange || null,
          forwarded_to_consultant: forwardedToConsultant || false,
          consultant_name: consultantName || null,
          notes: notes || null,
          raw_data: {
            source: 'form_submission',
            submitted_at: new Date().toISOString(),
          },
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase æ’å…¥éŒ¯èª¤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: 'é›»è¨ªè¨˜éŒ„å·²æˆåŠŸæäº¤',
        data,
      });
    } catch (error: any) {
      console.error('é›»è¨ªè¡¨å–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - List telemarketing call records with pagination
  app.get('/api/forms/telemarketing', async (req, res) => {
    try {
      const { page = '1', limit = '10' } = req.query;
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data, error, count } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact' })
        .order('call_date', { ascending: false })
        .order('created_at', { ascending: false })
        .range((pageNum - 1) * limitNum, pageNum * limitNum - 1);

      if (error) {
        console.error('Supabase æŸ¥è©¢éŒ¯èª¤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('é›»è¨ªæŸ¥è©¢ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - Statistics (today/week/month counts)
  app.get('/api/forms/telemarketing/stats', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      const { count: todayCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', today);

      const { count: weekCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', weekAgo);

      const { count: monthCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', monthAgo);

      res.json({
        today: todayCount || 0,
        week: weekCount || 0,
        month: monthCount || 0,
      });
    } catch (error: any) {
      console.error('é›»è¨ªçµ±è¨ˆ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // é›»è¨ªè¨˜éŒ„ç®¡ç† API
  // ========================================

  // GET - æŸ¥è©¢æ‰€æœ‰é›»è¨ªè¨˜éŒ„
  app.get('/api/telemarketing/calls', isAuthenticated, requireModulePermission('telemarketing_system'), async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data: calls, error } = await supabase
        .from('telemarketing_calls')
        .select('*')
        .order('call_date', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) {
        console.error('æŸ¥è©¢é›»è¨ªè¨˜éŒ„å¤±æ•—:', error);
        throw error;
      }

      res.json(calls || []);
    } catch (error: any) {
      console.error('é›»è¨ªè¨˜éŒ„ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - é›»è¨ªè¨˜éŒ„çµ±è¨ˆè³‡æ–™
  app.get('/api/telemarketing/calls/stats', isAuthenticated, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      // ç¸½è¨˜éŒ„æ•¸
      const { count: total } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true });

      // ä»Šæ—¥è¨˜éŒ„
      const { count: todayCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', today);

      // æœ¬é€±è¨˜éŒ„
      const { count: weekCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', weekAgo);

      // å·²æ¥é€šæ•¸
      const { count: connected } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('call_result', 'å·²æ¥é€š');

      // æœ‰æ„é¡˜æ•¸
      const { count: interested } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('interest_level', 'é«˜');

      // å·²è½‰è«®è©¢æ•¸
      const { count: forwarded } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('forwarded_to_consultant', true);

      res.json({
        total: total || 0,
        today: todayCount || 0,
        this_week: weekCount || 0,
        connected: connected || 0,
        interested: interested || 0,
        forwarded: forwarded || 0,
      });
    } catch (error: any) {
      console.error('é›»è¨ªçµ±è¨ˆ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // å»£å‘Šåå–®ç³»çµ± API (Facebook Lead Ads)
  // ========================================

  // Webhook - æ¥æ”¶ Facebook Lead Ads åå–®
  app.post('/api/webhooks/facebook-leads', async (req, res) => {
    try {
      const { object, entry } = req.body;

      // é©—è­‰æ˜¯å¦ç‚º Facebook page webhook
      if (object !== 'page') {
        return res.status(400).json({ error: 'Invalid webhook object type' });
      }

      if (!isSupabaseAvailable()) {
        console.error('âš ï¸  Supabase æœªé€£ç·šï¼Œç„¡æ³•å„²å­˜ Facebook åå–®');
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();
      const insertedLeads = [];

      // è™•ç†æ¯å€‹ entryï¼ˆå¯èƒ½æœ‰å¤šå€‹åå–®ï¼‰
      for (const entryItem of entry) {
        const changes = entryItem.changes || [];

        for (const change of changes) {
          if (change.field === 'leadgen') {
            const leadgenData = change.value;
            const {
              leadgen_id,
              ad_id,
              ad_name,
              form_id,
              form_name,
              campaign_id,
              campaign_name,
              created_time,
              field_data,
            } = leadgenData;

            // è§£æè¡¨å–®æ¬„ä½è³‡æ–™
            const fieldMap: Record<string, string> = {};
            if (field_data && Array.isArray(field_data)) {
              field_data.forEach((field: any) => {
                fieldMap[field.name] = field.values?.[0] || '';
              });
            }

            // æå–å§“åã€é›»è©±ã€Email
            const studentName = fieldMap['å§“å'] || fieldMap['full_name'] || fieldMap['name'] || '';
            const studentPhone = fieldMap['é›»è©±'] || fieldMap['phone_number'] || fieldMap['phone'] || '';
            const studentEmail = fieldMap['Email'] || fieldMap['email'] || '';

            // é©—è­‰å¿…å¡«æ¬„ä½
            if (!studentName || !studentPhone) {
              console.warn('âš ï¸  åå–®ç¼ºå°‘å§“åæˆ–é›»è©±ï¼Œè·³é:', leadgen_id);
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé˜²æ­¢é‡è¤‡ï¼‰
            const { data: existingLead } = await supabase
              .from('ad_leads')
              .select('id')
              .eq('leadgen_id', leadgen_id)
              .single();

            if (existingLead) {
              console.log(`â„¹ï¸  åå–®å·²å­˜åœ¨ï¼Œè·³é: ${leadgen_id}`);
              continue;
            }

            // æ’å…¥æ–°åå–®
            const { data: newLead, error } = await supabase
              .from('ad_leads')
              .insert({
                leadgen_id,
                ad_id,
                ad_name,
                campaign_id,
                campaign_name,
                form_id,
                form_name,
                student_name: studentName,
                student_phone: studentPhone,
                student_email: studentEmail || null,
                claim_status: 'unclaimed',
                contact_status: 'pending',
                stage1_status: 'pending',
                stage2_status: 'pending',
                stage3_status: 'pending',
                raw_data: {
                  facebook_data: leadgenData,
                  field_map: fieldMap,
                  received_at: new Date().toISOString(),
                },
              })
              .select()
              .single();

            if (error) {
              console.error('âŒ æ’å…¥åå–®å¤±æ•—:', error);
              continue;
            }

            insertedLeads.push(newLead);
            console.log(`âœ… æ–°å¢å»£å‘Šåå–®: ${studentName} (${studentPhone})`);
          }
        }
      }

      res.json({
        success: true,
        message: `æˆåŠŸæ¥æ”¶ ${insertedLeads.length} ç­†åå–®`,
        count: insertedLeads.length,
      });
    } catch (error: any) {
      console.error('Facebook webhook éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Webhook é©—è­‰ç«¯é»ï¼ˆFacebook è¨‚é–±é©—è­‰ï¼‰
  app.get('/api/webhooks/facebook-leads', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    // é©—è­‰ tokenï¼ˆéœ€è¦åœ¨ç’°å¢ƒè®Šæ•¸è¨­å®š FACEBOOK_VERIFY_TOKENï¼‰
    const VERIFY_TOKEN = process.env.FACEBOOK_VERIFY_TOKEN || 'singple_webhook_2024';

    if (mode === 'subscribe' && token === VERIFY_TOKEN) {
      console.log('âœ… Facebook webhook é©—è­‰æˆåŠŸ');
      res.status(200).send(challenge);
    } else {
      console.error('âŒ Facebook webhook é©—è­‰å¤±æ•—');
      res.sendStatus(403);
    }
  });

  // GET - å–å¾—å»£å‘Šåå–®åˆ—è¡¨ï¼ˆæ”¯æ´ç¯©é¸ï¼‰
  app.get('/api/leads/ad-leads', isAuthenticated, async (req, res) => {
    try {
      const {
        claim_status,
        stage1_status,
        stage2_status,
        claimed_by,
        start_date,
        end_date,
        page = '1',
        limit = '20',
      } = req.query;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();
      let query = supabase.from('ad_leads').select('*', { count: 'exact' });

      // ç¯©é¸æ¢ä»¶
      if (claim_status) query = query.eq('claim_status', claim_status);
      if (stage1_status) query = query.eq('stage1_status', stage1_status);
      if (stage2_status) query = query.eq('stage2_status', stage2_status);
      if (claimed_by) query = query.eq('claimed_by', claimed_by);
      if (start_date) query = query.gte('created_at', start_date);
      if (end_date) query = query.lte('created_at', end_date);

      // åˆ†é 
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);
      const offset = (pageNum - 1) * limitNum;
      query = query.range(offset, offset + limitNum - 1);

      // æ’åºï¼ˆæœ€æ–°å„ªå…ˆï¼‰
      query = query.order('created_at', { ascending: false });

      const { data, error, count } = await query;

      if (error) {
        console.error('æŸ¥è©¢åå–®å¤±æ•—:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('å»£å‘Šåå–®åˆ—è¡¨ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // PATCH - èªé ˜åå–®
  app.patch('/api/leads/ad-leads/:id/claim', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = (req as any).user;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      // æª¢æŸ¥åå–®æ˜¯å¦å­˜åœ¨ä¸”æœªè¢«èªé ˜
      const { data: lead } = await supabase
        .from('ad_leads')
        .select('id, claim_status')
        .eq('id', id)
        .single();

      if (!lead) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°æ­¤åå–®' });
      }

      if (lead.claim_status === 'claimed') {
        return res.status(400).json({ error: 'æ­¤åå–®å·²è¢«èªé ˜' });
      }

      // èªé ˜åå–®
      const { data, error } = await supabase
        .from('ad_leads')
        .update({
          claim_status: 'claimed',
          claimed_by: user.first_name || user.email,
          claimed_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('èªé ˜åå–®å¤±æ•—:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: 'èªé ˜æˆåŠŸ',
        data,
      });
    } catch (error: any) {
      console.error('èªé ˜åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // PATCH - æ›´æ–°åå–®ç‹€æ…‹
  app.patch('/api/leads/ad-leads/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      // æ›´æ–°åå–®
      const { data, error } = await supabase
        .from('ad_leads')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('æ›´æ–°åå–®å¤±æ•—:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: 'æ›´æ–°æˆåŠŸ',
        data,
      });
    } catch (error: any) {
      console.error('æ›´æ–°åå–® API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - å»£å‘Šæˆæ•ˆå ±è¡¨ï¼ˆå…©éšæ®µè½‰æ›ç‡ï¼‰
  app.get('/api/reports/ad-performance', isAuthenticated, async (req, res) => {
    try {
      const {
        start_date,
        end_date,
        campaign_id,
        groupBy = 'campaign', // 'campaign' or 'daily'
      } = req.query;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      // å»ºç«‹åŸºæœ¬æŸ¥è©¢
      let query = supabase.from('ad_leads').select('*');

      // æ™‚é–“ç¯©é¸ï¼ˆé è¨­æœ¬é€±ï¼‰
      if (start_date) {
        query = query.gte('created_at', start_date);
      } else {
        // é è¨­æœ¬é€±ä¸€
        const monday = new Date();
        monday.setDate(monday.getDate() - monday.getDay() + 1);
        monday.setHours(0, 0, 0, 0);
        query = query.gte('created_at', monday.toISOString());
      }

      if (end_date) {
        query = query.lte('created_at', end_date);
      }

      if (campaign_id) {
        query = query.eq('campaign_id', campaign_id);
      }

      const { data: leads, error } = await query;

      if (error) {
        console.error('æŸ¥è©¢å»£å‘Šæˆæ•ˆå¤±æ•—:', error);
        return res.status(500).json({ error: error.message });
      }

      // è¨ˆç®—ç¸½è¦½æ•¸æ“šï¼ˆä¸‰éšæ®µè½‰æ›ï¼‰
      const totalLeads = leads?.length || 0;

      // éšæ®µ 1ï¼šé ç´„è«®è©¢ï¼ˆå‡ºç¾åœ¨ EODï¼‰
      const stage1Converted = leads?.filter(l => l.stage1_status === 'scheduled').length || 0;

      // éšæ®µ 2ï¼šæ˜¯å¦ä¸Šç·š
      const stage2Converted = leads?.filter(l => l.stage2_status === 'showed').length || 0;

      // éšæ®µ 3ï¼šé«˜éšèª²ç¨‹æˆäº¤
      const stage3Converted = leads?.filter(l => l.stage3_status === 'converted').length || 0;
      const trialOnlyCount = leads?.filter(l => l.stage3_status === 'trial_only').length || 0;

      const totalRevenue = leads?.reduce((sum, l) => sum + (parseFloat(l.deal_amount) || 0), 0) || 0;

      const stage1ConversionRate = totalLeads > 0 ? (stage1Converted / totalLeads) * 100 : 0;
      const stage2ConversionRate = stage1Converted > 0 ? (stage2Converted / stage1Converted) * 100 : 0;
      const stage3ConversionRate = stage2Converted > 0 ? (stage3Converted / stage2Converted) * 100 : 0;
      const overallConversionRate = totalLeads > 0 ? (stage3Converted / totalLeads) * 100 : 0;

      // æŒ‰å»£å‘Šæ´»å‹•åˆ†çµ„çµ±è¨ˆ
      const campaignStats: Record<string, any> = {};
      leads?.forEach(lead => {
        const campaignName = lead.campaign_name || 'æœªçŸ¥å»£å‘Šæ´»å‹•';
        if (!campaignStats[campaignName]) {
          campaignStats[campaignName] = {
            campaign_name: campaignName,
            campaign_id: lead.campaign_id,
            total_leads: 0,
            stage1_converted: 0,
            stage2_converted: 0,
            stage3_converted: 0,
            trial_only: 0,
            total_revenue: 0,
          };
        }

        campaignStats[campaignName].total_leads += 1;
        if (lead.stage1_status === 'scheduled') {
          campaignStats[campaignName].stage1_converted += 1;
        }
        if (lead.stage2_status === 'showed') {
          campaignStats[campaignName].stage2_converted += 1;
        }
        if (lead.stage3_status === 'converted') {
          campaignStats[campaignName].stage3_converted += 1;
          campaignStats[campaignName].total_revenue += parseFloat(lead.deal_amount) || 0;
        }
        if (lead.stage3_status === 'trial_only') {
          campaignStats[campaignName].trial_only += 1;
        }
      });

      // è¨ˆç®—å„å»£å‘Šæ´»å‹•çš„è½‰æ›ç‡
      const campaignList = Object.values(campaignStats).map((campaign: any) => ({
        ...campaign,
        stage1_conversion_rate: campaign.total_leads > 0
          ? ((campaign.stage1_converted / campaign.total_leads) * 100).toFixed(2)
          : '0.00',
        stage2_conversion_rate: campaign.stage1_converted > 0
          ? ((campaign.stage2_converted / campaign.stage1_converted) * 100).toFixed(2)
          : '0.00',
        stage3_conversion_rate: campaign.stage2_converted > 0
          ? ((campaign.stage3_converted / campaign.stage2_converted) * 100).toFixed(2)
          : '0.00',
        overall_conversion_rate: campaign.total_leads > 0
          ? ((campaign.stage3_converted / campaign.total_leads) * 100).toFixed(2)
          : '0.00',
      }));

      res.json({
        success: true,
        data: {
          summary: {
            total_leads: totalLeads,
            stage1_converted: stage1Converted,
            stage2_converted: stage2Converted,
            stage3_converted: stage3Converted,
            trial_only: trialOnlyCount,
            total_revenue: totalRevenue,
            stage1_conversion_rate: stage1ConversionRate.toFixed(2) + '%',
            stage2_conversion_rate: stage2ConversionRate.toFixed(2) + '%',
            stage3_conversion_rate: stage3ConversionRate.toFixed(2) + '%',
            overall_conversion_rate: overallConversionRate.toFixed(2) + '%',
          },
          campaigns: campaignList,
        },
      });
    } catch (error: any) {
      console.error('å»£å‘Šæˆæ•ˆå ±è¡¨ API éŒ¯èª¤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ================================================
  // Custom Forms API - è‡ªè¨‚è¡¨å–®ç³»çµ±
  // ================================================

  const customFormService = await import('./services/custom-form-service');
  const { listSupabaseTables, getTableColumns, getAllTablesInfo } = await import('./services/reporting/introspect-service');

  // å–å¾—æ‰€æœ‰ Supabase è¡¨ï¼ˆç”¨æ–¼ä¸‹æ‹‰é¸å–®ï¼‰
  app.get('/api/database/tables', async (_req, res) => {
    try {
      const tables = await listSupabaseTables();
      res.json({ success: true, tables });
    } catch (error: any) {
      console.error('åˆ—å‡ºè³‡æ–™è¡¨å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—æŒ‡å®šè¡¨çš„æ¬„ä½ï¼ˆç”¨æ–¼æ¬„ä½æ˜ å°„ï¼‰
  app.get('/api/database/tables/:tableName/columns', async (req, res) => {
    try {
      const { tableName } = req.params;
      const columns = await getTableColumns(tableName);
      res.json({ columns });
    } catch (error: any) {
      console.error('å–å¾—è¡¨æ¬„ä½å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—æ‰€æœ‰è¡¨å’Œæ¬„ä½è³‡è¨Š
  app.get('/api/database/schema', async (_req, res) => {
    try {
      const schema = await getAllTablesInfo();
      res.json({ schema });
    } catch (error: any) {
      console.error('å–å¾—è³‡æ–™åº« schema å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - æŸ¥è©¢è¡¨æ ¼è³‡æ–™
  app.get('/api/database/:tableName/data', async (req, res) => {
    try {
      const { tableName } = req.params;
      const {
        page = '1',
        limit = '50',
        search = '',
        searchColumn = 'email',
        sortBy = 'created_at',
        sortOrder = 'desc'
      } = req.query;

      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);
      const limitNum = parseInt(limit as string);

      let query = `SELECT * FROM ${tableName}`;
      const params: any[] = [];

      // æœå°‹åŠŸèƒ½
      if (search) {
        query += ` WHERE ${searchColumn}::text ILIKE $1`;
        params.push(`%${search}%`);
      }

      // æ’åºåŠŸèƒ½
      const validSortOrder = sortOrder === 'asc' ? 'ASC' : 'DESC';
      query += ` ORDER BY ${sortBy} ${validSortOrder}`;

      // åˆ†é 
      if (search) {
        query += ` LIMIT $2 OFFSET $3`;
        params.push(limitNum, offset);
      } else {
        query += ` LIMIT $1 OFFSET $2`;
        params.push(limitNum, offset);
      }

      const result = await queryDatabase(query, params);
      const data = result.rows;

      // å–å¾—ç¸½ç­†æ•¸
      let countQuery = `SELECT COUNT(*) as total FROM ${tableName}`;
      const countParams: any[] = [];
      if (search) {
        countQuery += ` WHERE ${searchColumn}::text ILIKE $1`;
        countParams.push(`%${search}%`);
      }
      const countResult = await queryDatabase(countQuery, countParams);
      const total = parseInt(countResult.rows[0]?.total || '0');

      res.json({
        success: true,
        data,
        pagination: {
          page: parseInt(page as string),
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum)
        }
      });
    } catch (error: any) {
      console.error('æŸ¥è©¢è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - æ›´æ–°å–®ç­†è³‡æ–™
  app.put('/api/database/:tableName/:id', async (req, res) => {
    try {
      const { tableName, id } = req.params;
      const updates = req.body;

      const setClause = Object.keys(updates)
        .map((key, index) => `${key} = $${index + 1}`)
        .join(', ');
      const values = Object.values(updates);

      // æª¢æŸ¥è¡¨æ ¼æ˜¯å¦æœ‰ updated_at æ¬„ä½
      const columnsQuery = `
        SELECT column_name
        FROM information_schema.columns
        WHERE table_name = $1 AND column_name = 'updated_at'
      `;
      const columnsResult = await queryDatabase(columnsQuery, [tableName]);
      const hasUpdatedAt = columnsResult.rows.length > 0;

      // å¦‚æœæœ‰ updated_at æ¬„ä½ï¼Œè‡ªå‹•æ›´æ–°å®ƒ
      const updatedAtClause = hasUpdatedAt ? ', updated_at = NOW()' : '';

      const query = `
        UPDATE ${tableName}
        SET ${setClause}${updatedAtClause}
        WHERE id = $${values.length + 1}
        RETURNING *
      `;

      const result = await queryDatabase(query, [...values, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°è©²ç­†è³‡æ–™' });
      }

      res.json({ success: true, data: result.rows[0] });
    } catch (error: any) {
      console.error('æ›´æ–°è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - æ–°å¢è³‡æ–™
  app.post('/api/database/:tableName/data', async (req, res) => {
    try {
      const { tableName } = req.params;
      const data = req.body;

      const result = await insertAndReturn(tableName, data);

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('æ–°å¢è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - åˆªé™¤è³‡æ–™
  app.delete('/api/database/:tableName/:id', async (req, res) => {
    try {
      const { tableName, id } = req.params;

      const query = `DELETE FROM ${tableName} WHERE id = $1 RETURNING *`;
      const result = await queryDatabase(query, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°è©²ç­†è³‡æ–™' });
      }

      res.json({ success: true, data: result.rows[0] });
    } catch (error: any) {
      console.error('åˆªé™¤è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - åŒ¯å‡ºè³‡æ–™ç‚º CSV
  app.get('/api/database/:tableName/export', async (req, res) => {
    try {
      const { tableName } = req.params;
      const { search = '', searchColumn = 'email', sortBy = 'created_at', sortOrder = 'desc' } = req.query;

      let query = `SELECT * FROM ${tableName}`;
      const params: any[] = [];

      // æœå°‹åŠŸèƒ½
      if (search) {
        query += ` WHERE ${searchColumn}::text ILIKE $1`;
        params.push(`%${search}%`);
      }

      // æ’åºåŠŸèƒ½
      const validSortOrder = sortOrder === 'asc' ? 'ASC' : 'DESC';
      query += ` ORDER BY ${sortBy} ${validSortOrder}`;

      const result = await queryDatabase(query, params);
      const data = result.rows;

      if (data.length === 0) {
        return res.status(404).json({ error: 'æ²’æœ‰è³‡æ–™å¯åŒ¯å‡º' });
      }

      // ç”Ÿæˆ CSV
      const columns = Object.keys(data[0]);
      const csvHeader = columns.join(',');
      const csvRows = data.map(row =>
        columns.map(col => {
          const value = row[col];
          // è™•ç†åŒ…å«é€—è™Ÿæˆ–æ›è¡Œçš„å€¼
          if (value === null || value === undefined) return '';
          const stringValue = String(value);
          if (stringValue.includes(',') || stringValue.includes('\n') || stringValue.includes('"')) {
            return `"${stringValue.replace(/"/g, '""')}"`;
          }
          return stringValue;
        }).join(',')
      );
      const csv = [csvHeader, ...csvRows].join('\n');

      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="${tableName}_${new Date().toISOString().split('T')[0]}.csv"`);
      res.send('\uFEFF' + csv); // BOM for UTF-8
    } catch (error: any) {
      console.error('åŒ¯å‡ºè³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - å¾ CSV åŒ¯å…¥è³‡æ–™
  app.post('/api/database/:tableName/import', async (req, res) => {
    try {
      const { tableName } = req.params;

      // ä½¿ç”¨ multer è™•ç†æª”æ¡ˆä¸Šå‚³
      const multer = require('multer');
      const upload = multer({ storage: multer.memoryStorage() });

      upload.single('file')(req, res, async (err: any) => {
        if (err) {
          return res.status(400).json({ error: 'æª”æ¡ˆä¸Šå‚³å¤±æ•—' });
        }

        if (!req.file) {
          return res.status(400).json({ error: 'æœªé¸æ“‡æª”æ¡ˆ' });
        }

        const csvContent = req.file.buffer.toString('utf-8');
        const lines = csvContent.split('\n').filter(line => line.trim());

        if (lines.length < 2) {
          return res.status(400).json({ error: 'CSV æª”æ¡ˆæ ¼å¼éŒ¯èª¤' });
        }

        // è§£ææ¨™é¡Œè¡Œ
        const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));

        // è§£æè³‡æ–™è¡Œ
        let imported = 0;
        let failed = 0;

        for (let i = 1; i < lines.length; i++) {
          try {
            const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
            const rowData: any = {};

            headers.forEach((header, index) => {
              if (values[index] && values[index] !== '') {
                rowData[header] = values[index];
              }
            });

            // æ’é™¤è‡ªå‹•ç”Ÿæˆçš„æ¬„ä½
            delete rowData.id;
            delete rowData.created_at;
            delete rowData.updated_at;

            await insertAndReturn(tableName, rowData);
            imported++;
          } catch (error) {
            console.error(`ç¬¬ ${i + 1} è¡ŒåŒ¯å…¥å¤±æ•—:`, error);
            failed++;
          }
        }

        res.json({
          success: true,
          imported,
          failed,
          total: lines.length - 1
        });
      });
    } catch (error: any) {
      console.error('åŒ¯å…¥è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å»ºç«‹è‡ªè¨‚è¡¨å–®
  app.post('/api/forms/custom', isAuthenticated, requireAdmin, requireModulePermission('form_builder'), async (req, res) => {
    try {
      const form = await customFormService.createCustomForm(req.body);
      res.json({ success: true, form });
    } catch (error: any) {
      console.error('å»ºç«‹è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—æ‰€æœ‰è¡¨å–®ï¼ˆå¯ç¯©é¸ç‹€æ…‹ï¼‰
  app.get('/api/forms/custom', async (req, res) => {
    try {
      const status = req.query.status as 'active' | 'archived' | undefined;
      const forms = await customFormService.getAllForms(status);
      res.json({ success: true, forms });
    } catch (error: any) {
      console.error('å–å¾—è¡¨å–®åˆ—è¡¨å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—å–®ä¸€è¡¨å–®
  app.get('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const form = await customFormService.getFormById(id);

      if (!form) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°æŒ‡å®šçš„è¡¨å–®' });
      }

      res.json({ success: true, form });
    } catch (error: any) {
      console.error('å–å¾—è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // æ›´æ–°è¡¨å–®
  app.put('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const form = await customFormService.updateCustomForm(id, req.body);
      res.json({ success: true, form });
    } catch (error: any) {
      console.error('æ›´æ–°è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å°å­˜è¡¨å–®ï¼ˆè»Ÿåˆªé™¤ï¼‰
  app.post('/api/forms/custom/:id/archive', async (req, res) => {
    try {
      const { id } = req.params;
      await customFormService.archiveForm(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error('å°å­˜è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // åˆªé™¤è¡¨å–®ï¼ˆæ°¸ä¹…åˆªé™¤ï¼‰
  app.delete('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      await customFormService.deleteForm(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error('åˆªé™¤è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // æäº¤è¡¨å–®è³‡æ–™
  app.post('/api/forms/custom/:id/submit', async (req, res) => {
    try {
      const { id } = req.params;
      const result = await customFormService.submitFormData({
        form_id: id,
        data: req.body.data,
        submitted_by: req.body.submitted_by
      });
      res.json({ success: true, ...result });
    } catch (error: any) {
      console.error('æäº¤è¡¨å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å–å¾—è¡¨å–®æäº¤è¨˜éŒ„
  app.get('/api/forms/custom/:id/submissions', async (req, res) => {
    try {
      const { id } = req.params;
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;

      const submissions = await customFormService.getFormSubmissions(id, { limit, offset });
      const total = await customFormService.countFormSubmissions(id);

      res.json({
        success: true,
        submissions,
        total,
        limit,
        offset
      });
    } catch (error: any) {
      console.error('å–å¾—æäº¤è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================================================
  // Public Form APIs (No Authentication Required)
  // å…¬é–‹è¡¨å–® APIï¼ˆä¸éœ€è¦ç™»å…¥ï¼‰
  // ============================================================================

  // å…¬é–‹æäº¤è¡¨å–®è³‡æ–™ï¼ˆä¸éœ€ç™»å…¥ï¼‰
  app.post('/api/forms/public/:id/submit', async (req, res) => {
    try {
      const { id } = req.params;
      const result = await customFormService.submitFormData({
        form_id: id,
        data: req.body.data,
        submitted_by: 'public' // å…¬é–‹è¡¨å–®æäº¤è€…æ¨™è¨˜ç‚º public
      });
      res.json({ success: true, ...result });
    } catch (error: any) {
      console.error('å…¬é–‹è¡¨å–®æäº¤å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å…¬é–‹çš„è€å¸«åˆ—è¡¨ï¼ˆä¸éœ€ç™»å…¥ï¼‰
  app.get('/api/teachers/public', async (req, res) => {
    try {
      const pool = createPool();
      const result = await queryDatabase(
        pool,
        `SELECT DISTINCT first_name as name
         FROM users
         WHERE 'teacher' = ANY(roles)
         AND status = 'active'
         AND first_name IS NOT NULL
         ORDER BY first_name ASC`
      );

      const teachers = result.rows.map(row => row.name);
      res.json({ success: true, teachers });
    } catch (error: any) {
      console.error('å–å¾—è€å¸«åˆ—è¡¨å¤±æ•—:', error);
      // è¿”å›å‚™ç”¨åˆ—è¡¨
      res.json({ success: true, teachers: ['Karen', 'Vicky', 'Orange', 'Elena'] });
    }
  });

  // ============================================================================
  // Teaching Quality Analysis API Endpoints
  // ============================================================================

  // Register authentication routes
  registerAuthRoutes(app);

  // Register new auto-analysis routes
  registerTeachingQualityRoutes(app, isAuthenticated);

  // Register consultation quality analysis routes (manual-trigger only)
  registerConsultationQualityRoutes(app, isAuthenticated, requireAdmin);

  // Register consultant AI conversation routes
  registerConsultantAIRoutes(app);

  // Register employee management routes
  registerEmployeeManagementRoutes(app);

  // Register Know-it-all AI Advisor routes
  registerKnowItAllRoutes(app);

  // Register permission management routes
  registerPermissionRoutes(app);

  // 0. Get attendance records (for creating new analysis) [DEPRECATED - use student-records instead]
  app.get('/api/teaching-quality/attendance-records', isAuthenticated, requireModulePermission('teaching_quality'), async (req: any, res) => {
    try {
      // å»ºç«‹æ¬Šé™éæ¿¾æ¢ä»¶ï¼ˆä½¿ç”¨æ–°çš„æ¥­å‹™èº«ä»½ç³»çµ±ï¼‰
      const permissionFilter = await buildPermissionFilter({
        userId: req.user.id,
        tableName: 'trial_class_attendance',
        additionalConditions: 'ai_analysis_id IS NULL'
      });

      const query = `
        SELECT
          tca.id,
          tca.student_name,
          tca.class_date,
          tca.teacher_name,
          tca.teacher_code,
          tca.status,
          tca.ai_analysis_id
        FROM trial_class_attendance tca
        WHERE ${permissionFilter}
        ORDER BY tca.class_date DESC
        LIMIT 100
      `;

      const result = await queryDatabase(query);

      res.json({
        success: true,
        data: result.rows
      });
    } catch (error: any) {
      console.error('Failed to fetch attendance records:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 1. Create new analysis (trigger AI analysis)
  app.post('/api/teaching-quality/analyze', isAuthenticated, async (req: any, res) => {
    try {
      const {
        attendanceId,
        transcriptText,
        transcriptFileUrl,
        classTopic
      } = req.body;

      if (!attendanceId || !transcriptText) {
        return res.status(400).json({
          error: 'Missing required fields: attendanceId, transcriptText'
        });
      }

      const pool = createPool();

      // Get attendance record
      const attendanceResult = await queryDatabase(pool, `
        SELECT tca.*, u.full_name as teacher_name
        FROM trial_class_attendance tca
        LEFT JOIN users u ON tca.teacher_id = u.id
        WHERE tca.id = $1
      `, [attendanceId]);

      if (attendanceResult.rows.length === 0) {
        return res.status(404).json({ error: 'Attendance record not found' });
      }

      const attendance = attendanceResult.rows[0];

      // Check permissions: teachers can only analyze their own classes
      if (req.user && req.user.role === 'teacher' && attendance.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Run AI analysis
      const analysis = await teachingQualityGPT.analyzeTeachingQuality(
        transcriptText,
        attendance.student_name,
        attendance.teacher_name || 'Unknown',
        classTopic
      );

      // Save to database
      const result = await insertAndReturn(pool, 'teaching_quality_analysis', {
        attendance_id: attendanceId,
        teacher_id: attendance.teacher_id,
        teacher_name: attendance.teacher_name,
        student_name: attendance.student_name,
        class_date: attendance.class_date,
        class_topic: classTopic || null,
        transcript_text: transcriptText,
        transcript_file_url: transcriptFileUrl || null,
        overall_score: analysis.overallScore,
        strengths: JSON.stringify(analysis.strengths),
        weaknesses: JSON.stringify(analysis.weaknesses),
        class_summary: analysis.summary,
        suggestions: JSON.stringify(analysis.suggestions),
        conversion_status: attendance.status === 'completed' ? 'converted' : 'not_converted',
        analyzed_by: req.user.id
      });

      // Update attendance record with analysis reference
      await queryDatabase(pool, `
        UPDATE trial_class_attendance
        SET ai_analysis_id = $1
        WHERE id = $2
      `, [result.id, attendanceId]);

      // Create suggestion execution log entries
      for (let i = 0; i < analysis.suggestions.length; i++) {
        await insertAndReturn(pool, 'suggestion_execution_log', {
          analysis_id: result.id,
          suggestion_index: i,
          suggestion_text: analysis.suggestions[i].suggestion,
          is_executed: false
        });
      }

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: {
          ...result,
          strengths: analysis.strengths,
          weaknesses: analysis.weaknesses,
          suggestions: analysis.suggestions
        }
      });
    } catch (error: any) {
      console.error('æ•™å­¸å“è³ªåˆ†æå¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 2. Get all analyses (with teacher filtering)
  app.get('/api/teaching-quality/analyses', isAuthenticated, async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      const teacherId = req.query.teacherId as string;

      // å»ºç«‹æ¬Šé™éæ¿¾æ¢ä»¶
      let additionalConditions = '';
      if (teacherId) {
        additionalConditions = `tqa.teacher_id = '${teacherId}'`;
      }

      const permissionFilter = await buildPermissionFilter({
        userId: req.user.id,
        tableName: 'teaching_quality_analysis',
        additionalConditions
      });

      const query = `
        SELECT
          tqa.*,
          COUNT(sel.id) as total_suggestions,
          COUNT(CASE WHEN sel.is_executed = true THEN 1 END) as executed_suggestions
        FROM teaching_quality_analysis tqa
        LEFT JOIN suggestion_execution_log sel ON tqa.id = sel.analysis_id
        WHERE ${permissionFilter}
        GROUP BY tqa.id
        ORDER BY tqa.class_date DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const result = await queryDatabase(query);

      // Parse JSONB fields
      const analyses = result.rows.map(row => ({
        ...row,
        strengths: typeof row.strengths === 'string' ? JSON.parse(row.strengths) : row.strengths,
        weaknesses: typeof row.weaknesses === 'string' ? JSON.parse(row.weaknesses) : row.weaknesses,
        suggestions: typeof row.suggestions === 'string' ? JSON.parse(row.suggestions) : row.suggestions,
        conversion_suggestions: row.conversion_suggestions && typeof row.conversion_suggestions === 'string'
          ? JSON.parse(row.conversion_suggestions)
          : row.conversion_suggestions
      }));

      res.json({
        success: true,
        data: analyses,
        limit,
        offset
      });
    } catch (error: any) {
      console.error('å–å¾—åˆ†æè¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 3. Get single analysis detail
  app.get('/api/teaching-quality/analyses/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(`
        SELECT tqa.*,
          (SELECT json_agg(sel ORDER BY sel.suggestion_index)
           FROM suggestion_execution_log sel
           WHERE sel.analysis_id = tqa.id) as suggestion_logs,
          tcp.package_name as purchased_package,
          tcp.student_email,
          tca.student_email as attendance_email,
          tca.student_email as student_email
        FROM teaching_quality_analysis tqa
        LEFT JOIN trial_class_attendance tca ON tqa.attendance_id = tca.id
        LEFT JOIN trial_class_purchases tcp ON tcp.student_email = tca.student_email
        WHERE tqa.id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Analysis not found' });
      }

      const analysis = result.rows[0];

      // Permission check for teachers
      if (req.user && req.user.role === 'teacher') {
        // Get teacher's name from user ID
        const userResult = await queryDatabase(`
          SELECT first_name, last_name FROM users WHERE id = $1
        `, [req.user.id]);

        if (userResult.rows.length > 0) {
          const teacherName = `${userResult.rows[0].first_name} ${userResult.rows[0].last_name}`.trim();
          if (teacherName !== analysis.teacher_name) {
            return res.status(403).json({ error: 'Permission denied' });
          }
        } else {
          return res.status(403).json({ error: 'Permission denied' });
        }
      }

      // Calculate remaining lessons dynamically based on class date
      let remaining_lessons = null;
      if (analysis.purchased_package && analysis.attendance_email) {
        // Determine total lessons from package name
        let totalLessons = 4; // é è¨­åˆå­¸å°ˆæ¡ˆ
        if (analysis.purchased_package.includes('pro')) {
          totalLessons = 2;
        } else if (analysis.purchased_package.includes('çµ‚æ¥µ')) {
          totalLessons = 1;
        } else if (analysis.purchased_package.includes('12å ‚')) {
          totalLessons = 12;
        }

        // Count classes BEFORE or ON this class date
        const attendanceCountResult = await queryDatabase(`
          SELECT COUNT(*) as count
          FROM trial_class_attendance
          WHERE student_email = $1
            AND class_date <= $2
        `, [analysis.attendance_email, analysis.class_date]);

        const classesBeforeOrOn = parseInt(attendanceCountResult.rows[0]?.count || '0', 10);
        remaining_lessons = Math.max(0, totalLessons - classesBeforeOrOn);
      }

      // Parse JSONB fields
      const parsedAnalysis = {
        ...analysis,
        remaining_lessons, // ä½¿ç”¨å‹•æ…‹è¨ˆç®—çš„å‰©é¤˜å ‚æ•¸
        strengths: typeof analysis.strengths === 'string' ? JSON.parse(analysis.strengths) : analysis.strengths,
        weaknesses: typeof analysis.weaknesses === 'string' ? JSON.parse(analysis.weaknesses) : analysis.weaknesses,
        suggestions: typeof analysis.suggestions === 'string' ? JSON.parse(analysis.suggestions) : analysis.suggestions,
        conversion_suggestions: analysis.conversion_suggestions && typeof analysis.conversion_suggestions === 'string'
          ? JSON.parse(analysis.conversion_suggestions)
          : analysis.conversion_suggestions
      };

      res.json({
        success: true,
        data: parsedAnalysis
      });
    } catch (error: any) {
      console.error('å–å¾—åˆ†æè©³æƒ…å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 4. Mark suggestion as executed
  app.post('/api/teaching-quality/suggestions/:logId/mark-executed', isAuthenticated, async (req: any, res) => {
    try {
      const { logId } = req.params;
      const { executionNotes } = req.body;

      const pool = createPool();

      // Get the suggestion log and check permissions
      const logResult = await queryDatabase(pool, `
        SELECT sel.*, tqa.teacher_id
        FROM suggestion_execution_log sel
        JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
        WHERE sel.id = $1
      `, [logId]);

      if (logResult.rows.length === 0) {
        return res.status(404).json({ error: 'Suggestion log not found' });
      }

      const log = logResult.rows[0];

      // Permission check
      if (req.user && req.user.role === 'teacher' && log.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Update execution status
      await queryDatabase(pool, `
        UPDATE suggestion_execution_log
        SET is_executed = true,
            executed_at = NOW(),
            execution_notes = $1,
            marked_by = $2,
            updated_at = NOW()
        WHERE id = $3
      `, [executionNotes || null, req.user.id, logId]);

      // pool.end() removed - using shared pool

      res.json({ success: true });
    } catch (error: any) {
      console.error('æ¨™è¨˜å»ºè­°åŸ·è¡Œç‹€æ…‹å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 5. Analyze suggestion effectiveness (compare with next class)
  app.post('/api/teaching-quality/suggestions/:logId/analyze-effectiveness', isAuthenticated, async (req: any, res) => {
    try {
      const { logId } = req.params;
      const { nextAnalysisId } = req.body;

      if (!nextAnalysisId) {
        return res.status(400).json({ error: 'Missing nextAnalysisId' });
      }

      const pool = createPool();

      // Get previous and current analysis
      const logResult = await queryDatabase(pool, `
        SELECT sel.*, tqa.transcript_text as prev_transcript, tqa.teacher_name, tqa.student_name
        FROM suggestion_execution_log sel
        JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
        WHERE sel.id = $1
      `, [logId]);

      if (logResult.rows.length === 0) {
        return res.status(404).json({ error: 'Suggestion log not found' });
      }

      const log = logResult.rows[0];

      // Get next analysis
      const nextResult = await queryDatabase(pool, `
        SELECT transcript_text, suggestions
        FROM teaching_quality_analysis
        WHERE id = $1
      `, [nextAnalysisId]);

      if (nextResult.rows.length === 0) {
        return res.status(404).json({ error: 'Next analysis not found' });
      }

      const nextAnalysis = nextResult.rows[0];

      // Parse the original suggestion
      const prevAnalysisResult = await queryDatabase(pool, `
        SELECT suggestions
        FROM teaching_quality_analysis
        WHERE id = $1
      `, [log.analysis_id]);

      const prevSuggestions = typeof prevAnalysisResult.rows[0].suggestions === 'string'
        ? JSON.parse(prevAnalysisResult.rows[0].suggestions)
        : prevAnalysisResult.rows[0].suggestions;

      const originalSuggestion = prevSuggestions[log.suggestion_index];

      // Run effectiveness analysis
      const effectiveness = await teachingQualityGPT.analyzeSuggestionEffectiveness(
        log.prev_transcript,
        nextAnalysis.transcript_text,
        originalSuggestion,
        log.teacher_name,
        log.student_name
      );

      // Update suggestion log
      await queryDatabase(pool, `
        UPDATE suggestion_execution_log
        SET next_analysis_id = $1,
            effectiveness_score = $2,
            effectiveness_evidence = $3,
            evaluated_at = NOW(),
            updated_at = NOW()
        WHERE id = $4
      `, [nextAnalysisId, effectiveness.effectivenessScore, effectiveness.evidence, logId]);

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: effectiveness
      });
    } catch (error: any) {
      console.error('åˆ†æå»ºè­°æ•ˆæœå¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 6. Generate conversion optimization suggestions
  app.post('/api/teaching-quality/analyses/:id/conversion-optimization', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { studentBackground } = req.body;

      const pool = createPool();

      // Get analysis
      const result = await queryDatabase(pool, `
        SELECT * FROM teaching_quality_analysis WHERE id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Analysis not found' });
      }

      const analysis = result.rows[0];

      // Permission check
      if (req.user && req.user.role === 'teacher' && analysis.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Generate conversion suggestion (now returns single object)
      const conversionSuggestion = await teachingQualityGPT.analyzeConversionOptimization(
        analysis.transcript_text,
        analysis.student_name,
        analysis.teacher_name,
        studentBackground
      );

      // Update analysis with conversion suggestions
      await queryDatabase(pool, `
        UPDATE teaching_quality_analysis
        SET conversion_suggestions = $1,
            updated_at = NOW()
        WHERE id = $2
      `, [JSON.stringify(conversionSuggestion), id]);

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: conversionSuggestion
      });
    } catch (error: any) {
      console.error('ç”Ÿæˆè½‰æ›å„ªåŒ–å»ºè­°å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 7. Get teacher statistics
  app.get('/api/teaching-quality/teachers/:teacherId/stats', isAuthenticated, async (req: any, res) => {
    try {
      const { teacherId } = req.params;

      // Permission check
      if (req.user && req.user.role === 'teacher' && teacherId !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      const pool = createPool();

      const result = await queryDatabase(pool, `
        SELECT
          COUNT(*) as total_classes,
          AVG(overall_score) as avg_score,
          COUNT(CASE WHEN conversion_status = 'converted' THEN 1 END) as converted_count,
          COUNT(CASE WHEN conversion_status = 'not_converted' THEN 1 END) as not_converted_count,
          (SELECT COUNT(*) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1 AND sel.is_executed = true) as executed_suggestions,
          (SELECT COUNT(*) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1) as total_suggestions,
          (SELECT AVG(effectiveness_score) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1 AND sel.effectiveness_score IS NOT NULL) as avg_effectiveness
        FROM teaching_quality_analysis
        WHERE teacher_id = $1
      `, [teacherId]);

      // Get score trend (last 10 classes)
      const trendResult = await queryDatabase(pool, `
        SELECT class_date, overall_score
        FROM teaching_quality_analysis
        WHERE teacher_id = $1
        ORDER BY class_date DESC
        LIMIT 10
      `, [teacherId]);

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: {
          ...result.rows[0],
          score_trend: trendResult.rows.reverse()
        }
      });
    } catch (error: any) {
      console.error('å–å¾—æ•™å¸«çµ±è¨ˆå¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 8. Delete analysis (admin only)
  app.delete('/api/teaching-quality/analyses/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const pool = createPool();

      await queryDatabase(pool, `DELETE FROM teaching_quality_analysis WHERE id = $1`, [id]);

      // pool.end() removed - using shared pool

      res.json({ success: true });
    } catch (error: any) {
      console.error('åˆªé™¤åˆ†æè¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 9. Estimate analysis cost
  app.post('/api/teaching-quality/estimate-cost', isAuthenticated, async (req, res) => {
    try {
      const { transcriptText } = req.body;

      if (!transcriptText) {
        return res.status(400).json({ error: 'Missing transcriptText' });
      }

      const cost = teachingQualityGPT.estimateAnalysisCost(transcriptText.length);

      res.json({
        success: true,
        data: {
          transcriptLength: transcriptText.length,
          estimatedCostUSD: cost.toFixed(4),
          estimatedCostNTD: (cost * 32).toFixed(2) // Assuming 1 USD = 32 TWD
        }
      });
    } catch (error: any) {
      console.error('ä¼°ç®—æˆæœ¬å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================
  // æ”¶æ”¯ç´€éŒ„è¡¨ API (Phase 18 - æ›´æ–°æ–¼ 2025-11-25)
  // ============================================
  const { incomeExpenseService } = await import('./services/income-expense-service');

  // æŸ¥è©¢æ”¶æ”¯è¨˜éŒ„ï¼ˆæ”¯æ´å¤šç¨®ç¯©é¸ï¼‰
  app.get('/api/income-expense/records', isAuthenticated, requireModulePermission('income_expense'), async (req: any, res) => {
    try {
      // ä½¿ç”¨ service çš„æŸ¥è©¢æ–¹æ³•ï¼ˆå°æ‡‰å¯¦éš›è¡¨çµæ§‹ - Migration 071ï¼‰
      const result = await incomeExpenseService.queryRecords({
        month: req.query.month as string,
        transaction_category: req.query.transaction_category as string,
        teacher_name: req.query.teacher_name as string,
        closer: req.query.closer as string,
        setter: req.query.setter as string,
        customer_email: req.query.customer_email as string,
        search: req.query.search as string,
        start_date: req.query.start_date as string,
        end_date: req.query.end_date as string,
        page: req.query.page ? parseInt(req.query.page as string) : 1,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 50,
      });

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('æŸ¥è©¢æ”¶æ”¯è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ–°å¢æ”¶æ”¯è¨˜éŒ„
  app.post('/api/income-expense/records', async (req, res) => {
    try {
      const record = await incomeExpenseService.createRecord(req.body);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('æ–°å¢æ”¶æ”¯è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å–®ç­†æ”¶æ”¯è¨˜éŒ„
  app.get('/api/income-expense/records/:id', async (req, res) => {
    try {
      const record = await incomeExpenseService.getRecordById(req.params.id);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('å–å¾—æ”¶æ”¯è¨˜éŒ„å¤±æ•—:', error);
      res.status(404).json({ success: false, error: error.message });
    }
  });

  // æ›´æ–°æ”¶æ”¯è¨˜éŒ„
  app.put('/api/income-expense/records/:id', async (req, res) => {
    try {
      const record = await incomeExpenseService.updateRecord(req.params.id, req.body);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('æ›´æ–°æ”¶æ”¯è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åˆªé™¤æ”¶æ”¯è¨˜éŒ„
  app.delete('/api/income-expense/records/:id', async (req, res) => {
    try {
      await incomeExpenseService.deleteRecord(req.params.id);
      res.json({ success: true, message: 'è¨˜éŒ„å·²åˆªé™¤' });
    } catch (error: any) {
      console.error('åˆªé™¤æ”¶æ”¯è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—æœˆåº¦çµ±è¨ˆ
  app.get('/api/income-expense/summary/:month', async (req, res) => {
    try {
      const summary = await incomeExpenseService.getMonthlySummary(req.params.month);
      res.json({ success: true, data: summary });
    } catch (error: any) {
      console.error('å–å¾—æœˆåº¦çµ±è¨ˆå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—æ•™å¸«ç›¸é—œè¨˜éŒ„ï¼ˆæ³¨æ„ï¼šæ­¤è¡¨ä½¿ç”¨ teacher_name å­—ä¸²ï¼Œé UUIDï¼‰
  app.get('/api/income-expense/by-teacher/:teacherName', isAuthenticated, async (req: any, res) => {
    try {
      const { teacherName } = req.params;

      // ä½¿ç”¨ service çš„æŸ¥è©¢æ–¹æ³•ï¼ˆä½¿ç”¨ teacher_name å­—ä¸²æ¬„ä½ï¼‰
      const result = await incomeExpenseService.queryRecords({
        teacher_name: teacherName,
        month: req.query.month as string,
        page: req.query.page ? parseInt(req.query.page as string) : 1,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 50,
      });

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('å–å¾—æ•™å¸«è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ‰¹æ¬¡åŒ¯å…¥è¨˜éŒ„
  app.post('/api/income-expense/bulk-import', async (req, res) => {
    try {
      const { records } = req.body;

      if (!Array.isArray(records)) {
        return res.status(400).json({ success: false, error: 'è«‹æä¾›è¨˜éŒ„é™£åˆ—' });
      }

      const result = await incomeExpenseService.bulkImport(records);
      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('æ‰¹æ¬¡åŒ¯å…¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åŒæ­¥åˆ°æˆæœ¬ç²åˆ©è¡¨ï¼ˆæš«æ™‚åœç”¨ - å¾…å¯¦ä½œï¼‰
  app.post('/api/income-expense/sync-to-cost-profit', async (req, res) => {
    res.status(501).json({ success: false, error: 'æ­¤åŠŸèƒ½æš«æ™‚åœç”¨' });
  });

  // ========================================
  // å“¡å·¥ç®¡ç† API
  // ========================================

  // å–å¾—æ‰€æœ‰å“¡å·¥åˆ—è¡¨ï¼ˆå«å®Œæ•´äººè³‡è³‡è¨Šï¼‰
  app.get('/api/employees', isAuthenticated, async (req, res) => {
    try {
      const result = await queryDatabase(`
        SELECT
          u.id,
          u.email,
          u.first_name,
          u.last_name,
          u.role,
          u.department,
          u.status,
          u.created_at,

          -- å“¡å·¥åŸºæœ¬è³‡æ–™
          ep.employee_number,
          ep.national_id,
          ep.nickname,
          ep.hire_date,
          ep.resign_date,
          ep.employment_type,
          ep.residential_address,
          ep.emergency_contact_name,
          ep.emergency_contact_phone,

          -- æ¥­å‹™èº«ä»½ï¼ˆJSON é™£åˆ—ï¼‰
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', bi.id,
                'identity_type', bi.identity_type,
                'identity_code', bi.identity_code,
                'display_name', bi.display_name,
                'is_active', bi.is_active,
                'is_primary', bi.is_primary
              )
            ) FILTER (WHERE bi.id IS NOT NULL),
            '[]'::json
          ) as business_identities,

          -- ç›®å‰è–ªè³‡ï¼ˆå¾ employee_salary_settings è®€å–ï¼‰
          ess.base_salary,
          ess.commission_rate,
          ess.commission_type,
          ess.tier1_max_revenue,
          ess.tier1_commission_amount,
          ess.tier2_max_revenue,
          ess.tier2_commission_amount,
          ess.other_revenue_rate,
          ess.role_type as salary_role_type,
          ess.employment_type as salary_employment_type,
          ess.hourly_rate,
          ess.point_commission_rate,
          ess.performance_bonus,
          ess.phone_bonus_rate,
          ess.original_bonus,
          ess.labor_insurance as salary_labor_insurance,
          ess.health_insurance as salary_health_insurance,
          ess.retirement_fund,
          ess.service_fee,

          -- ç›®å‰å‹å¥ä¿ï¼ˆä¿ç•™åŸæœ¬çš„ä¿éšªç­‰ç´šè³‡è¨Šï¼‰
          ei.labor_insurance_grade,
          ei.health_insurance_grade,
          ei.pension_employer_rate

        FROM users u
        LEFT JOIN employee_profiles ep ON ep.user_id = u.id
        LEFT JOIN business_identities bi ON bi.user_id = u.id AND bi.is_active = true
        LEFT JOIN employee_salary_settings ess ON ess.employee_name = CONCAT(u.first_name, ' ', u.last_name) AND ess.is_active = true
        LEFT JOIN employee_insurance ei ON ei.user_id = u.id AND ei.is_active = true
        GROUP BY u.id, ep.id, ess.id, ei.id
        ORDER BY u.created_at DESC
      `);

      // è½‰æ›è³‡æ–™æ ¼å¼ç‚ºå‰ç«¯éœ€è¦çš„æ ¼å¼
      const employeeList = result.rows.map(row => ({
        user: {
          id: row.id,
          email: row.email,
          first_name: row.first_name,
          last_name: row.last_name,
          role: row.role,
          department: row.department,
          status: row.status || 'active',
          created_at: row.created_at,
        },
        profile: row.employee_number || row.hire_date || row.nickname ? {
          employee_number: row.employee_number,
          national_id: row.national_id,
          nickname: row.nickname,
          hire_date: row.hire_date,
          resign_date: row.resign_date,
          employment_type: row.employment_type,
          residential_address: row.residential_address,
          emergency_contact_name: row.emergency_contact_name,
          emergency_contact_phone: row.emergency_contact_phone,
        } : null,
        identities: row.business_identities || [],
        compensation: [],
        insurance: [],
        latest_compensation: row.base_salary ? {
          base_salary: row.base_salary,
          commission_rate: row.commission_rate,
          commission_type: row.commission_type || 'fixed_rate',
          tier1_max_revenue: row.tier1_max_revenue,
          tier1_commission_amount: row.tier1_commission_amount,
          tier2_max_revenue: row.tier2_max_revenue,
          tier2_commission_amount: row.tier2_commission_amount,
          other_revenue_rate: row.other_revenue_rate,
        } : null,
      }));

      res.json({ success: true, data: employeeList });
    } catch (error: any) {
      console.error('å–å¾—å“¡å·¥åˆ—è¡¨å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å–®ä¸€å“¡å·¥è©³ç´°è³‡æ–™
  app.get('/api/employees/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(`
        SELECT
          u.*,
          ep.*,

          -- æ¥­å‹™èº«ä»½
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', bi.id,
                'identity_type', bi.identity_type,
                'identity_code', bi.identity_code,
                'display_name', bi.display_name,
                'effective_from', bi.effective_from,
                'effective_to', bi.effective_to,
                'is_active', bi.is_active,
                'is_primary', bi.is_primary
              )
            ) FILTER (WHERE bi.id IS NOT NULL),
            '[]'::json
          ) as business_identities,

          -- ç›®å‰è–ªè³‡è¨­å®šï¼ˆå¾ employee_salary_settingsï¼‰
          ess.id as salary_setting_id,
          ess.base_salary,
          ess.commission_rate,
          ess.role_type as salary_role_type,
          ess.employment_type as salary_employment_type,
          ess.hourly_rate,
          ess.point_commission_rate,
          ess.performance_bonus,
          ess.phone_bonus_rate,
          ess.original_bonus,
          ess.labor_insurance as salary_labor_insurance,
          ess.health_insurance as salary_health_insurance,
          ess.retirement_fund,
          ess.service_fee,
          ess.notes as salary_notes,
          ess.updated_at as salary_updated_at,

          -- è€å¸«æŠ½æˆè¦å‰‡
          ess.commission_type as salary_commission_type,
          ess.tier1_max_revenue,
          ess.tier1_commission_amount,
          ess.tier2_max_revenue,
          ess.tier2_commission_amount,
          ess.other_revenue_rate,

          -- å‹å¥ä¿æ­·å²
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', ei.id,
                'labor_insurance_grade', ei.labor_insurance_grade,
                'health_insurance_grade', ei.health_insurance_grade,
                'pension_employer_rate', ei.pension_employer_rate,
                'effective_from', ei.effective_from,
                'effective_to', ei.effective_to,
                'is_active', ei.is_active
              )
            ) FILTER (WHERE ei.id IS NOT NULL),
            '[]'::json
          ) as insurance_history

        FROM users u
        LEFT JOIN employee_profiles ep ON ep.user_id = u.id
        LEFT JOIN business_identities bi ON bi.user_id = u.id
        LEFT JOIN employee_salary_settings ess ON ess.employee_name = CONCAT(u.first_name, ' ', u.last_name) AND ess.is_active = true
        LEFT JOIN employee_insurance ei ON ei.user_id = u.id
        WHERE u.id = $1
        GROUP BY u.id, ep.id, ess.id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'æ‰¾ä¸åˆ°è©²å“¡å·¥' });
      }

      // å–å¾—æŒ‰è§’è‰²å€åˆ†çš„æŠ½æˆè¨­å®š
      const roleCommissionsResult = await queryDatabase(`
        SELECT
          id,
          role_type,
          commission_type,
          commission_rate,
          other_revenue_rate,
          tier1_max_revenue,
          tier1_commission_amount,
          tier2_max_revenue,
          tier2_commission_amount,
          effective_from,
          notes,
          is_active
        FROM employee_role_commission
        WHERE user_id = $1 AND is_active = true
        ORDER BY role_type
      `, [id]);

      // è½‰æ›ç‚º { teacher: {...}, consultant: {...}, setter: {...} } æ ¼å¼
      const roleCommissions: Record<string, any> = {};
      for (const rc of roleCommissionsResult.rows) {
        roleCommissions[rc.role_type] = {
          id: rc.id,
          commission_type: rc.commission_type,
          commission_rate: rc.commission_rate,
          other_revenue_rate: rc.other_revenue_rate,
          tier1_max_revenue: rc.tier1_max_revenue,
          tier1_commission_amount: rc.tier1_commission_amount,
          tier2_max_revenue: rc.tier2_max_revenue,
          tier2_commission_amount: rc.tier2_commission_amount,
          effective_from: rc.effective_from,
          notes: rc.notes,
        };
      }

      // è½‰æ›è³‡æ–™æ ¼å¼ç‚ºå‰ç«¯éœ€è¦çš„æ ¼å¼
      const row = result.rows[0];
      const employeeData = {
        user: {
          id: row.id,
          email: row.email,
          first_name: row.first_name,
          last_name: row.last_name,
          role: row.role,
          department: row.department,
          status: row.status || 'active',
          created_at: row.created_at,
          updated_at: row.updated_at,
        },
        profile: row.employee_number || row.hire_date || row.nickname ? {
          employee_number: row.employee_number,
          national_id: row.national_id,
          nickname: row.nickname,
          hire_date: row.hire_date,
          resign_date: row.resign_date,
          employment_type: row.employment_type,
          residential_address: row.residential_address,
          emergency_contact_name: row.emergency_contact_name,
          emergency_contact_phone: row.emergency_contact_phone,
        } : null,
        identities: row.business_identities || [],
        compensation: [],
        insurance: [],
        latest_compensation: row.base_salary || row.salary_commission_type ? {
          id: row.salary_setting_id,
          base_salary: row.base_salary,
          commission_type: row.salary_commission_type,
          commission_rate: row.commission_rate,
          effective_from: row.effective_from,
          // è€å¸«æŠ½æˆè¦å‰‡
          tier1_max_revenue: row.tier1_max_revenue,
          tier1_commission_amount: row.tier1_commission_amount,
          tier2_max_revenue: row.tier2_max_revenue,
          tier2_commission_amount: row.tier2_commission_amount,
          other_revenue_rate: row.other_revenue_rate,
        } : null,
        // è§’è‰²é¡å‹ï¼ˆç”¨æ–¼åˆ¤æ–·æ˜¯å¦é¡¯ç¤ºè€å¸«æŠ½æˆè¦å‰‡ï¼‰
        salary_role_type: row.salary_role_type,
        // æ–°å¢ï¼šæŒ‰è§’è‰²å€åˆ†çš„æŠ½æˆè¨­å®š
        role_commissions: roleCommissions,
      };

      res.json({ success: true, data: employeeData });
    } catch (error: any) {
      console.error('å–å¾—å“¡å·¥è©³ç´°è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ–°å¢å“¡å·¥åŸºæœ¬è³‡æ–™
  app.post('/api/employees', isAuthenticated, async (req, res) => {
    try {
      const {
        email,
        first_name,
        last_name,
        role,
        department,
        national_id,
        hire_date,
        employment_type,
        residential_address,
        emergency_contact_name,
        emergency_contact_phone
      } = req.body;

      // å…ˆå»ºç«‹ user
      const userResult = await queryDatabase(`
        INSERT INTO users (email, first_name, last_name, role, department)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
      `, [email, first_name || '', last_name || '', role || 'user', department || '']);

      const userId = userResult.rows[0].id;

      // å»ºç«‹ employee_profile
      if (national_id || hire_date || employment_type) {
        await queryDatabase(`
          INSERT INTO employee_profiles (
            user_id,
            national_id,
            hire_date,
            employment_type,
            residential_address,
            emergency_contact_name,
            emergency_contact_phone
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, [
          userId,
          national_id || null,
          hire_date || null,
          employment_type || 'full_time',
          residential_address || null,
          emergency_contact_name || null,
          emergency_contact_phone || null
        ]);
      }

      res.json({ success: true, employee: userResult.rows[0] });
    } catch (error: any) {
      console.error('æ–°å¢å“¡å·¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ›´æ–°å“¡å·¥è³‡æ–™
  app.put('/api/employees/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const {
        email,
        first_name,
        last_name,
        nickname,
        role,
        department,
        status,
        national_id,
        hire_date,
        resign_date,
        employment_type,
        residential_address,
        emergency_contact_name,
        emergency_contact_phone
      } = req.body;

      // æ›´æ–° user
      await queryDatabase(`
        UPDATE users
        SET
          email = COALESCE($1, email),
          first_name = COALESCE($2, first_name),
          last_name = COALESCE($3, last_name),
          role = COALESCE($4, role),
          department = COALESCE($5, department),
          status = COALESCE($6, status),
          updated_at = NOW()
        WHERE id = $7
      `, [email, first_name, last_name, role, department, status, id]);

      // æ›´æ–°æˆ–æ–°å¢ employee_profile
      const profileExists = await queryDatabase(
        'SELECT id FROM employee_profiles WHERE user_id = $1',
        [id]
      );

      if (profileExists.rows.length > 0) {
        await queryDatabase(`
          UPDATE employee_profiles
          SET
            nickname = COALESCE($1, nickname),
            national_id = COALESCE($2, national_id),
            hire_date = COALESCE($3, hire_date),
            resign_date = $4,
            employment_type = COALESCE($5, employment_type),
            residential_address = COALESCE($6, residential_address),
            emergency_contact_name = COALESCE($7, emergency_contact_name),
            emergency_contact_phone = COALESCE($8, emergency_contact_phone),
            updated_at = NOW()
          WHERE user_id = $9
        `, [nickname, national_id, hire_date, resign_date, employment_type, residential_address, emergency_contact_name, emergency_contact_phone, id]);
      } else {
        await queryDatabase(`
          INSERT INTO employee_profiles (
            user_id, nickname, national_id, hire_date, resign_date, employment_type,
            residential_address, emergency_contact_name, emergency_contact_phone
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, [id, nickname, national_id, hire_date, resign_date, employment_type, residential_address, emergency_contact_name, emergency_contact_phone]);
      }

      res.json({ success: true, message: 'å“¡å·¥è³‡æ–™æ›´æ–°æˆåŠŸ' });
    } catch (error: any) {
      console.error('æ›´æ–°å“¡å·¥è³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åˆªé™¤å“¡å·¥
  app.delete('/api/employees/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // åˆªé™¤ userï¼ˆæœƒç´šè¯åˆªé™¤ç›¸é—œè³‡æ–™ï¼‰
      await queryDatabase('DELETE FROM users WHERE id = $1', [id]);

      res.json({ success: true, message: 'å“¡å·¥å·²åˆªé™¤' });
    } catch (error: any) {
      console.error('åˆªé™¤å“¡å·¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // æ¥­å‹™èº«ä»½ç®¡ç† API
  // ========================================

  // ç‚ºå“¡å·¥æ–°å¢æ¥­å‹™èº«ä»½
  app.post('/api/employees/:id/business-identities', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { identity_type, display_name } = req.body;

      if (!identity_type) {
        return res.status(400).json({ success: false, error: 'è«‹æä¾›èº«ä»½é¡å‹' });
      }

      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒé¡å‹çš„å•Ÿç”¨èº«ä»½
      const existing = await queryDatabase(`
        SELECT id FROM business_identities
        WHERE user_id = $1 AND identity_type = $2 AND is_active = true
      `, [id, identity_type]);

      if (existing.rows.length > 0) {
        return res.status(400).json({
          success: false,
          error: `è©²å“¡å·¥å·²æœ‰å•Ÿç”¨çš„${identity_type}èº«ä»½`
        });
      }

      // æ–°å¢æ¥­å‹™èº«ä»½ï¼ˆidentity_code æœƒè‡ªå‹•ç”Ÿæˆï¼‰
      const result = await queryDatabase(`
        INSERT INTO business_identities (
          user_id,
          identity_type,
          display_name,
          effective_from,
          is_active
        )
        VALUES ($1, $2, $3, CURRENT_DATE, true)
        RETURNING *
      `, [id, identity_type, display_name || null]);

      res.json({ success: true, identity: result.rows[0] });
    } catch (error: any) {
      console.error('æ–°å¢æ¥­å‹™èº«ä»½å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åœç”¨æ¥­å‹™èº«ä»½ï¼ˆä¸åˆªé™¤ï¼Œåªæ¨™è¨˜ç‚ºåœç”¨ï¼‰
  app.delete('/api/employees/:userId/business-identities/:identityId', isAuthenticated, async (req, res) => {
    try {
      const { userId, identityId } = req.params;

      // åœç”¨èº«ä»½ï¼ˆè¨­å®š effective_to å’Œ is_activeï¼‰
      await queryDatabase(`
        UPDATE business_identities
        SET
          is_active = false,
          effective_to = CURRENT_DATE
        WHERE id = $1 AND user_id = $2
      `, [identityId, userId]);

      res.json({ success: true, message: 'æ¥­å‹™èº«ä»½å·²åœç”¨' });
    } catch (error: any) {
      console.error('åœç”¨æ¥­å‹™èº«ä»½å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // é‡æ–°å•Ÿç”¨æ¥­å‹™èº«ä»½
  app.put('/api/employees/:userId/business-identities/:identityId/activate', isAuthenticated, async (req, res) => {
    try {
      const { userId, identityId } = req.params;

      // é‡æ–°å•Ÿç”¨
      await queryDatabase(`
        UPDATE business_identities
        SET
          is_active = true,
          effective_to = NULL,
          effective_from = CURRENT_DATE
        WHERE id = $1 AND user_id = $2
      `, [identityId, userId]);

      res.json({ success: true, message: 'æ¥­å‹™èº«ä»½å·²é‡æ–°å•Ÿç”¨' });
    } catch (error: any) {
      console.error('é‡æ–°å•Ÿç”¨æ¥­å‹™èº«ä»½å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // è¨­å®šä¸»èº«ä»½
  app.put('/api/employees/:userId/business-identities/:identityId/set-primary', isAuthenticated, async (req, res) => {
    try {
      const { userId, identityId } = req.params;

      // å…ˆå°‡è©²å“¡å·¥æ‰€æœ‰èº«ä»½çš„ is_primary è¨­ç‚º false
      await queryDatabase(`
        UPDATE business_identities
        SET is_primary = false
        WHERE user_id = $1
      `, [userId]);

      // å†å°‡æŒ‡å®šçš„èº«ä»½è¨­ç‚ºä¸»èº«ä»½
      await queryDatabase(`
        UPDATE business_identities
        SET is_primary = true
        WHERE id = $1 AND user_id = $2
      `, [identityId, userId]);

      res.json({ success: true, message: 'å·²è¨­å®šç‚ºä¸»èº«ä»½' });
    } catch (error: any) {
      console.error('è¨­å®šä¸»èº«ä»½å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // è–ªè³‡ç®¡ç† API
  // ========================================

  // ç‚ºå“¡å·¥æ–°å¢è–ªè³‡è¨­å®š
  app.post('/api/employees/:userId/compensation', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const {
        base_salary,
        commission_type,
        commission_config,
        allowances,
        effective_from,
        adjustment_reason,
      } = req.body;

      // å…ˆå–å¾—å“¡å·¥å§“åå’Œè˜ç”¨é¡å‹ï¼ˆç”¨æ–¼ employee_salary_settingsï¼‰
      // å„ªå…ˆä½¿ç”¨ä¸»èº«ä»½ (is_primary = true)
      const userResult = await queryDatabase(`
        SELECT
          u.first_name,
          u.last_name,
          ep.employment_type,
          bi.identity_type
        FROM users u
        LEFT JOIN employee_profiles ep ON ep.user_id = u.id
        LEFT JOIN business_identities bi ON bi.user_id = u.id AND bi.is_active = true
        WHERE u.id = $1
        ORDER BY bi.is_primary DESC NULLS LAST
        LIMIT 1
      `, [userId]);

      if (userResult.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'æ‰¾ä¸åˆ°è©²å“¡å·¥' });
      }

      const user = userResult.rows[0];
      const employeeName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || userId;

      // æ ¹æ“šä¸»èº«ä»½åˆ¤æ–·è§’è‰²é¡å‹
      let roleType: string;
      switch (user.identity_type) {
        case 'consultant':
          roleType = 'closer';
          break;
        case 'setter':
          roleType = 'setter';
          break;
        case 'teacher':
          roleType = 'teacher';
          break;
        case 'employee':
          roleType = 'employee';
          break;
        default:
          roleType = user.identity_type || 'employee';  // ç›´æ¥ä½¿ç”¨èº«ä»½é¡å‹ï¼Œç„¡èº«ä»½å‰‡é è¨­ employee
      }

      // è¨ˆç®—æŠ½æˆæ¯”ä¾‹ï¼ˆå¾ commission_config æå–ï¼‰
      let commissionRate = 0;
      if (commission_config && typeof commission_config === 'object') {
        if (commission_config.rate) {
          commissionRate = commission_config.rate * 100; // è½‰æ›ç‚ºç™¾åˆ†æ¯”
        }
      }

      // å…ˆå°‡ç›®å‰çš„è–ªè³‡è¨­å®šæ¨™è¨˜ç‚ºæ­·å²
      await queryDatabase(`
        UPDATE employee_compensation
        SET
          is_active = false,
          effective_to = $1
        WHERE user_id = $2 AND is_active = true
      `, [effective_from || new Date().toISOString().split('T')[0], userId]);

      // æ–°å¢æ–°çš„è–ªè³‡è¨­å®š
      const result = await queryDatabase(`
        INSERT INTO employee_compensation (
          user_id,
          base_salary,
          commission_type,
          commission_config,
          allowances,
          effective_from,
          adjustment_reason,
          is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, true)
        RETURNING *
      `, [
        userId,
        base_salary || 0,
        commission_type || 'none',
        commission_config ? JSON.stringify(commission_config) : null,
        allowances ? JSON.stringify(allowances) : null,
        effective_from || new Date().toISOString().split('T')[0],
        adjustment_reason || null,
      ]);

      // === åŒæ­¥å¯«å…¥ employee_salary_settingsï¼ˆè–ªè³‡è¨ˆç®—å™¨ç”¨ï¼‰ ===
      await queryDatabase(`
        INSERT INTO employee_salary_settings (
          employee_name,
          role_type,
          employment_type,
          base_salary,
          commission_rate,
          is_active,
          notes,
          updated_at
        )
        VALUES ($1, $2, $3, $4, $5, true, $6, NOW())
        ON CONFLICT (employee_name)
        DO UPDATE SET
          role_type = EXCLUDED.role_type,
          employment_type = EXCLUDED.employment_type,
          base_salary = EXCLUDED.base_salary,
          commission_rate = EXCLUDED.commission_rate,
          is_active = true,
          notes = EXCLUDED.notes,
          updated_at = NOW()
      `, [
        employeeName,
        roleType,
        user.employment_type || 'full_time',
        base_salary || 0,
        commissionRate,
        adjustment_reason || `å¾å“¡å·¥ç®¡ç†åŒæ­¥ ${new Date().toLocaleDateString('zh-TW')}`,
      ]);

      console.log(`[è–ªè³‡è¨­å®š] å·²åŒæ­¥åˆ° employee_salary_settings: ${employeeName}`);

      res.json({ success: true, compensation: result.rows[0] });
    } catch (error: any) {
      console.error('æ–°å¢è–ªè³‡è¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å“¡å·¥è–ªè³‡æ­·å²
  app.get('/api/employees/:userId/compensation/history', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;

      const result = await queryDatabase(`
        SELECT *
        FROM employee_compensation
        WHERE user_id = $1
        ORDER BY effective_from DESC
      `, [userId]);

      res.json({ success: true, history: result.rows });
    } catch (error: any) {
      console.error('å–å¾—è–ªè³‡æ­·å²å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ç·¨è¼¯å“¡å·¥è–ªè³‡è¨­å®šï¼ˆåŒ…å«æŠ½æˆè¦å‰‡ï¼‰
  app.put('/api/employees/:userId/compensation/:compensationId', isAuthenticated, async (req, res) => {
    try {
      const { userId, compensationId } = req.params;
      const {
        base_salary,
        commission_type,
        commission_rate,
        // éšæ¢¯å¼æŠ½æˆæ¬„ä½
        tier1_max_revenue,
        tier1_commission_amount,
        tier2_max_revenue,
        tier2_commission_amount,
        other_revenue_rate,
        effective_from,
        adjustment_reason,
      } = req.body;

      // 1. å–å¾—å“¡å·¥å§“å
      const userResult = await queryDatabase(`
        SELECT u.first_name, u.last_name, bi.display_name
        FROM users u
        LEFT JOIN business_identities bi ON bi.user_id = u.id AND bi.identity_type = 'teacher' AND bi.is_active = true
        WHERE u.id = $1
      `, [userId]);

      if (userResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: 'æ‰¾ä¸åˆ°å“¡å·¥' });
      }

      const user = userResult.rows[0];
      const employeeName = `${user.first_name} ${user.last_name}`.trim();
      const nickname = user.display_name || '';

      // 2. æ›´æ–° employee_compensation è¡¨
      await queryDatabase(`
        UPDATE employee_compensation
        SET
          base_salary = COALESCE($1, base_salary),
          commission_type = COALESCE($2, commission_type),
          effective_from = COALESCE($3, effective_from),
          updated_at = NOW()
        WHERE id = $4 AND user_id = $5
      `, [
        base_salary,
        commission_type,
        effective_from,
        compensationId,
        userId,
      ]);

      // 3. åŒæ­¥æ›´æ–° employee_salary_settings è¡¨ï¼ˆè–ªè³‡è¨ˆç®—å™¨ç”¨ï¼‰
      // é€™æ˜¯æœ€é‡è¦çš„éƒ¨åˆ†ï¼Œå› ç‚ºè–ªè³‡è¨ˆç®—å™¨ä½¿ç”¨é€™å¼µè¡¨
      await queryDatabase(`
        UPDATE employee_salary_settings
        SET
          base_salary = COALESCE($1, base_salary),
          commission_type = COALESCE($2, commission_type),
          commission_rate = COALESCE($3, commission_rate),
          tier1_max_revenue = $4,
          tier1_commission_amount = $5,
          tier2_max_revenue = $6,
          tier2_commission_amount = $7,
          other_revenue_rate = COALESCE($8, other_revenue_rate),
          notes = COALESCE($9, notes),
          updated_at = NOW()
        WHERE employee_name = $10 OR nickname = $11 OR employee_name ILIKE $12
      `, [
        base_salary,
        commission_type,
        commission_rate,
        tier1_max_revenue || null,
        tier1_commission_amount || null,
        tier2_max_revenue || null,
        tier2_commission_amount || null,
        other_revenue_rate,
        adjustment_reason || `å¾å“¡å·¥ç®¡ç†æ›´æ–° ${new Date().toLocaleDateString('zh-TW')}`,
        employeeName,
        nickname,
        `%${nickname}%`,
      ]);

      console.log(`[è–ªè³‡è¨­å®š] å·²æ›´æ–° employee_salary_settings: ${employeeName} (${nickname})`);
      console.log(`[è–ªè³‡è¨­å®š] commission_type=${commission_type}, commission_rate=${commission_rate}, tier1_max=${tier1_max_revenue}, tier1_amount=${tier1_commission_amount}`);

      res.json({ success: true, message: 'è–ªè³‡è¨­å®šæ›´æ–°æˆåŠŸ' });
    } catch (error: any) {
      console.error('æ›´æ–°è–ªè³‡è¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // æŒ‰è§’è‰²å€åˆ†çš„æŠ½æˆè¨­å®š API
  // ========================================

  // æ›´æ–°æˆ–æ–°å¢è§’è‰²æŠ½æˆè¨­å®š
  app.put('/api/employees/:userId/role-commission/:roleType', isAuthenticated, async (req, res) => {
    try {
      const { userId, roleType } = req.params;
      const {
        commission_type,
        commission_rate,
        other_revenue_rate,
        tier1_max_revenue,
        tier1_commission_amount,
        tier2_max_revenue,
        tier2_commission_amount,
        notes,
      } = req.body;

      // é©—è­‰è§’è‰²é¡å‹
      if (!['teacher', 'consultant', 'setter'].includes(roleType)) {
        return res.status(400).json({ success: false, message: 'ç„¡æ•ˆçš„è§’è‰²é¡å‹' });
      }

      // æª¢æŸ¥æ˜¯å¦å·²æœ‰è©²è§’è‰²çš„æŠ½æˆè¨­å®š
      const existingResult = await queryDatabase(`
        SELECT id FROM employee_role_commission
        WHERE user_id = $1 AND role_type = $2 AND is_active = true
      `, [userId, roleType]);

      if (existingResult.rows.length > 0) {
        // æ›´æ–°ç¾æœ‰è¨­å®š
        await queryDatabase(`
          UPDATE employee_role_commission
          SET
            commission_type = COALESCE($1, commission_type),
            commission_rate = $2,
            other_revenue_rate = $3,
            tier1_max_revenue = $4,
            tier1_commission_amount = $5,
            tier2_max_revenue = $6,
            tier2_commission_amount = $7,
            notes = COALESCE($8, notes),
            updated_at = NOW()
          WHERE user_id = $9 AND role_type = $10 AND is_active = true
        `, [
          commission_type || 'fixed_rate',
          commission_rate,
          other_revenue_rate,
          tier1_max_revenue || null,
          tier1_commission_amount || null,
          tier2_max_revenue || null,
          tier2_commission_amount || null,
          notes,
          userId,
          roleType,
        ]);
        console.log(`[è§’è‰²æŠ½æˆ] å·²æ›´æ–°: userId=${userId}, role=${roleType}, rate=${commission_rate}%`);
      } else {
        // æ–°å¢è¨­å®š
        await queryDatabase(`
          INSERT INTO employee_role_commission (
            user_id, role_type, commission_type, commission_rate, other_revenue_rate,
            tier1_max_revenue, tier1_commission_amount, tier2_max_revenue, tier2_commission_amount,
            notes, effective_from
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, CURRENT_DATE)
        `, [
          userId,
          roleType,
          commission_type || 'fixed_rate',
          commission_rate,
          other_revenue_rate,
          tier1_max_revenue || null,
          tier1_commission_amount || null,
          tier2_max_revenue || null,
          tier2_commission_amount || null,
          notes,
        ]);
        console.log(`[è§’è‰²æŠ½æˆ] å·²æ–°å¢: userId=${userId}, role=${roleType}, rate=${commission_rate}%`);
      }

      // åŒæ­¥æ›´æ–° employee_salary_settingsï¼ˆåªåŒæ­¥æ•™å¸«è§’è‰²ï¼Œå› ç‚ºé€™æ˜¯è–ªè³‡è¨ˆç®—å™¨ä¸»è¦ä½¿ç”¨çš„ï¼‰
      if (roleType === 'teacher') {
        // å¾ users å’Œ business_identities å–å¾—å§“åè³‡è¨Š
        const userResult = await queryDatabase(`
          SELECT u.first_name, u.last_name, bi.display_name
          FROM users u
          LEFT JOIN business_identities bi ON bi.user_id = u.id AND bi.identity_type = 'teacher' AND bi.is_active = true
          WHERE u.id = $1
        `, [userId]);
        if (userResult.rows.length > 0) {
          const user = userResult.rows[0];
          const employeeName = `${user.first_name} ${user.last_name}`.trim();
          const displayName = user.display_name || '';
          await queryDatabase(`
            UPDATE employee_salary_settings
            SET
              commission_type = COALESCE($1, commission_type),
              commission_rate = $2,
              other_revenue_rate = COALESCE($3, other_revenue_rate),
              tier1_max_revenue = $4,
              tier1_commission_amount = $5,
              tier2_max_revenue = $6,
              tier2_commission_amount = $7,
              updated_at = NOW()
            WHERE employee_name = $8 OR employee_name = $9 OR employee_name ILIKE $10
          `, [
            commission_type || 'fixed_rate',
            commission_rate,
            other_revenue_rate,
            tier1_max_revenue || null,
            tier1_commission_amount || null,
            tier2_max_revenue || null,
            tier2_commission_amount || null,
            employeeName,
            displayName,
            `%${displayName}%`,
          ]);
          console.log(`[è§’è‰²æŠ½æˆ] å·²åŒæ­¥ employee_salary_settings: ${employeeName} (displayName: ${displayName})`);
        }
      }

      res.json({ success: true, message: `${roleType} è§’è‰²æŠ½æˆè¨­å®šæ›´æ–°æˆåŠŸ` });
    } catch (error: any) {
      console.error('æ›´æ–°è§’è‰²æŠ½æˆè¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // å‹å¥ä¿ç®¡ç† API
  // ========================================

  // ç‚ºå“¡å·¥æ–°å¢å‹å¥ä¿è¨­å®š
  app.post('/api/employees/:userId/insurance', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const {
        labor_insurance_grade,
        health_insurance_grade,
        pension_employer_rate,
        effective_from,
        adjustment_reason,
      } = req.body;

      // å…ˆå°‡ç›®å‰çš„å‹å¥ä¿è¨­å®šæ¨™è¨˜ç‚ºæ­·å²
      await queryDatabase(`
        UPDATE employee_insurance
        SET
          is_active = false,
          effective_to = $1
        WHERE user_id = $2 AND is_active = true
      `, [effective_from || new Date().toISOString().split('T')[0], userId]);

      // æ–°å¢æ–°çš„å‹å¥ä¿è¨­å®š
      const result = await queryDatabase(`
        INSERT INTO employee_insurance (
          user_id,
          labor_insurance_grade,
          health_insurance_grade,
          pension_employer_rate,
          effective_from,
          notes,
          is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, true)
        RETURNING *
      `, [
        userId,
        labor_insurance_grade || null,
        health_insurance_grade || null,
        pension_employer_rate || 0.06,
        effective_from || new Date().toISOString().split('T')[0],
        adjustment_reason || null,
      ]);

      res.json({ success: true, insurance: result.rows[0] });
    } catch (error: any) {
      console.error('æ–°å¢å‹å¥ä¿è¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å“¡å·¥å‹å¥ä¿æ­·å²
  app.get('/api/employees/:userId/insurance/history', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;

      const result = await queryDatabase(`
        SELECT *
        FROM employee_insurance
        WHERE user_id = $1
        ORDER BY effective_from DESC
      `, [userId]);

      res.json({ success: true, history: result.rows });
    } catch (error: any) {
      console.error('å–å¾—å‹å¥ä¿æ­·å²å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // Facebook Lead Ads API æ•´åˆ
  // ========================================

  const {
    generateFacebookAuthUrl,
    exchangeCodeForToken,
    getFacebookUser,
    getFacebookPages,
    getPageLeadForms,
    getFormLeads,
    parseFieldData,
    checkFacebookConfig,
  } = await import('./services/facebook-service.js');

  // 1. å–å¾— Facebook ç™»å…¥ URL
  app.get('/api/facebook/auth-url', requireAdmin, async (req, res) => {
    try {
      // æª¢æŸ¥ç’°å¢ƒè®Šæ•¸
      const configCheck = checkFacebookConfig();
      if (!configCheck.valid) {
        return res.status(500).json({
          success: false,
          error: 'Facebook ç’°å¢ƒè®Šæ•¸æœªè¨­å®š',
          missing: configCheck.missing,
        });
      }

      // ç”¢ç”Ÿéš¨æ©Ÿ state é˜²æ­¢ CSRF
      const state = Math.random().toString(36).substring(7);

      // å°‡ state å­˜åˆ° sessionï¼ˆä¾› callback é©—è­‰ç”¨ï¼‰
      if (req.session) {
        req.session.facebookOAuthState = state;
      }

      const authUrl = generateFacebookAuthUrl(state);

      res.json({ success: true, authUrl });
    } catch (error: any) {
      console.error('ç”¢ç”Ÿ Facebook ç™»å…¥ URL å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 2. Facebook OAuth Callback
  app.get('/api/facebook/callback', async (req, res) => {
    try {
      const { code, state, error, error_description } = req.query;

      // æª¢æŸ¥æ˜¯å¦æœ‰éŒ¯èª¤
      if (error) {
        console.error('Facebook OAuth éŒ¯èª¤:', error, error_description);
        return res.redirect(`/settings/facebook?error=${error}`);
      }

      // é©—è­‰ stateï¼ˆé˜²æ­¢ CSRFï¼‰
      if (req.session?.facebookOAuthState !== state) {
        console.error('State ä¸ç¬¦ï¼Œå¯èƒ½æ˜¯ CSRF æ”»æ“Š');
        return res.redirect('/settings/facebook?error=invalid_state');
      }

      if (!code || typeof code !== 'string') {
        return res.redirect('/settings/facebook?error=no_code');
      }

      // ç”¨ code æ›å– access_token
      const tokenData = await exchangeCodeForToken(code);
      const { access_token, expires_in } = tokenData;

      // å–å¾—ä½¿ç”¨è€…è³‡è¨Š
      const fbUser = await getFacebookUser(access_token);

      // å–å¾—ç²‰çµ²å°ˆé åˆ—è¡¨ï¼ˆåŒæ™‚å–å¾— page access tokenï¼‰
      const pages = await getFacebookPages(access_token);

      if (pages.length === 0) {
        return res.redirect('/settings/facebook?error=no_pages');
      }

      // é è¨­é¸ç¬¬ä¸€å€‹ç²‰çµ²å°ˆé 
      const firstPage = pages[0];

      // è¨ˆç®— token éæœŸæ™‚é–“
      const expiresAt = new Date(Date.now() + expires_in * 1000);

      if (!isSupabaseAvailable()) {
        return res.redirect('/settings/facebook?error=db_unavailable');
      }

      const supabase = getSupabaseClient();

      // æª¢æŸ¥æ˜¯å¦å·²æœ‰è¨­å®šï¼ˆSingletonï¼‰
      const { data: existingSettings } = await supabase
        .from('facebook_settings')
        .select('id')
        .single();

      if (existingSettings) {
        // æ›´æ–°ç¾æœ‰è¨­å®š
        await supabase
          .from('facebook_settings')
          .update({
            access_token,
            token_expires_at: expiresAt.toISOString(),
            facebook_user_id: fbUser.id,
            facebook_user_name: fbUser.name,
            page_id: firstPage.id,
            page_name: firstPage.name,
            page_access_token: firstPage.access_token,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingSettings.id);
      } else {
        // å»ºç«‹æ–°è¨­å®š
        await supabase.from('facebook_settings').insert({
          access_token,
          token_expires_at: expiresAt.toISOString(),
          facebook_user_id: fbUser.id,
          facebook_user_name: fbUser.name,
          page_id: firstPage.id,
          page_name: firstPage.name,
          page_access_token: firstPage.access_token,
          sync_enabled: true,
          sync_interval_minutes: 5,
        });
      }

      // æ¸…é™¤ session ä¸­çš„ state
      if (req.session) {
        delete req.session.facebookOAuthState;
      }

      // å½ˆå‡ºè¦–çª—æ¨¡å¼ï¼šè¿”å› HTML è‡ªå‹•é—œé–‰è¦–çª—
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Facebook æˆæ¬ŠæˆåŠŸ</title>
        </head>
        <body>
          <script>
            // é€šçŸ¥çˆ¶è¦–çª—æˆæ¬ŠæˆåŠŸ
            if (window.opener) {
              window.opener.postMessage({ type: 'facebook-auth-success' }, '*');
            }
            // è‡ªå‹•é—œé–‰è¦–çª—
            window.close();
            // å¦‚æœç„¡æ³•é—œé–‰ï¼ˆæŸäº›ç€è¦½å™¨é™åˆ¶ï¼‰ï¼Œé¡¯ç¤ºè¨Šæ¯
            setTimeout(() => {
              document.body.innerHTML = '<div style="text-align:center;padding:50px;font-family:sans-serif;"><h2>âœ… æˆæ¬ŠæˆåŠŸ</h2><p>è«‹é—œé–‰æ­¤è¦–çª—å›åˆ°ç³»çµ±</p></div>';
            }, 1000);
          </script>
        </body>
        </html>
      `);
    } catch (error: any) {
      console.error('Facebook OAuth callback å¤±æ•—:', error);
      res.redirect(`/settings/facebook?error=${encodeURIComponent(error.message)}`);
    }
  });

  // 3. å–å¾— Facebook è¨­å®šç‹€æ…‹
  app.get('/api/facebook/settings', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('*')
        .single();

      if (!settings) {
        return res.json({ success: true, connected: false, settings: null });
      }

      // ä¸è¿”å›æ•æ„Ÿçš„ access_token
      const safeSettings = {
        connected: true,
        facebook_user_name: settings.facebook_user_name,
        page_id: settings.page_id,
        page_name: settings.page_name,
        form_ids: settings.form_ids || [],
        form_names: settings.form_names || {},
        sync_enabled: settings.sync_enabled,
        sync_interval_minutes: settings.sync_interval_minutes,
        last_sync_at: settings.last_sync_at,
        last_sync_status: settings.last_sync_status,
        last_sync_count: settings.last_sync_count,
        last_sync_new_leads: settings.last_sync_new_leads,
        last_sync_error: settings.last_sync_error,
        token_expires_at: settings.token_expires_at,
      };

      res.json({ success: true, connected: true, settings: safeSettings });
    } catch (error: any) {
      console.error('å–å¾— Facebook è¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 4. å–å¾—ç²‰çµ²å°ˆé çš„è¡¨å–®åˆ—è¡¨
  app.get('/api/facebook/forms', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('page_id, page_access_token')
        .single();

      if (!settings) {
        return res.status(400).json({ success: false, error: 'å°šæœªé€£æ¥ Facebook' });
      }

      const forms = await getPageLeadForms(settings.page_id, settings.page_access_token);

      res.json({ success: true, forms });
    } catch (error: any) {
      console.error('å–å¾—è¡¨å–®åˆ—è¡¨å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 5. æ›´æ–° Facebook è¨­å®šï¼ˆé¸æ“‡è¦è¿½è¹¤çš„è¡¨å–®ï¼‰
  app.put('/api/facebook/settings', requireAdmin, async (req, res) => {
    try {
      const { form_ids, form_names, sync_enabled, sync_interval_minutes } = req.body;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const updateData: any = {};

      if (form_ids !== undefined) updateData.form_ids = form_ids;
      if (form_names !== undefined) updateData.form_names = form_names;
      if (sync_enabled !== undefined) updateData.sync_enabled = sync_enabled;
      if (sync_interval_minutes !== undefined)
        updateData.sync_interval_minutes = sync_interval_minutes;

      const { data, error } = await supabase
        .from('facebook_settings')
        .update(updateData)
        .eq('id', (await supabase.from('facebook_settings').select('id').single()).data.id)
        .select()
        .single();

      if (error) throw error;

      res.json({ success: true, settings: data });
    } catch (error: any) {
      console.error('æ›´æ–° Facebook è¨­å®šå¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 6. æ‰‹å‹•åŒæ­¥åå–®
  app.post('/api/facebook/sync', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase æœªé€£ç·š' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('*')
        .single();

      if (!settings || !settings.page_access_token) {
        return res.status(400).json({ success: false, error: 'å°šæœªé€£æ¥ Facebook' });
      }

      if (!settings.form_ids || settings.form_ids.length === 0) {
        return res.status(400).json({ success: false, error: 'å°šæœªé¸æ“‡è¦è¿½è¹¤çš„è¡¨å–®' });
      }

      let totalNewLeads = 0;
      let totalProcessed = 0;

      // å°æ¯å€‹è¡¨å–®æŠ“å–åå–®
      for (const formId of settings.form_ids) {
        try {
          // å–å¾—æœ€å¾Œä¸€æ¬¡åŒæ­¥æ™‚é–“ï¼ˆåªæŠ“æ–°çš„ï¼‰
          const sinceTimestamp = settings.last_sync_at
            ? Math.floor(new Date(settings.last_sync_at).getTime() / 1000)
            : undefined;

          const leads = await getFormLeads(formId, settings.page_access_token, {
            sinceTimestamp,
            limit: 100,
          });

          totalProcessed += leads.length;

          // æ’å…¥åˆ° ad_leads è¡¨
          for (const lead of leads) {
            // è§£ææ¬„ä½è³‡æ–™
            const { studentName, studentPhone, studentEmail, allFields } = parseFieldData(
              lead.field_data
            );

            // é©—è­‰å¿…å¡«æ¬„ä½
            if (!studentName || !studentPhone) {
              console.warn(`åå–®ç¼ºå°‘å§“åæˆ–é›»è©±ï¼Œè·³é: ${lead.id}`);
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            const { data: existingLead } = await supabase
              .from('ad_leads')
              .select('id')
              .eq('leadgen_id', lead.id)
              .single();

            if (existingLead) {
              console.log(`åå–®å·²å­˜åœ¨ï¼Œè·³é: ${lead.id}`);
              continue;
            }

            // æ’å…¥æ–°åå–®
            const { error } = await supabase.from('ad_leads').insert({
              leadgen_id: lead.id,
              ad_id: lead.ad_id || null,
              ad_name: lead.ad_name || null,
              form_id: lead.form_id,
              form_name: settings.form_names?.[lead.form_id] || null,
              student_name: studentName,
              student_phone: studentPhone,
              student_email: studentEmail || null,
              claim_status: 'unclaimed',
              contact_status: 'pending',
              stage1_status: 'pending',
              stage2_status: 'pending',
              stage3_status: 'pending',
              raw_data: {
                facebook_data: lead,
                field_map: allFields,
                synced_at: new Date().toISOString(),
              },
            });

            if (!error) {
              totalNewLeads++;
              console.log(`âœ… æ–°å¢å»£å‘Šåå–®: ${studentName} (${studentPhone})`);
            }
          }
        } catch (formError: any) {
          console.error(`æŠ“å–è¡¨å–® ${formId} å¤±æ•—:`, formError);
        }
      }

      // æ›´æ–°åŒæ­¥ç‹€æ…‹
      await supabase
        .from('facebook_settings')
        .update({
          last_sync_at: new Date().toISOString(),
          last_sync_status: 'success',
          last_sync_count: totalProcessed,
          last_sync_new_leads: totalNewLeads,
          last_sync_error: null,
        })
        .eq('id', settings.id);

      res.json({
        success: true,
        message: `åŒæ­¥å®Œæˆï¼Œè™•ç† ${totalProcessed} ç­†ï¼Œæ–°å¢ ${totalNewLeads} ç­†`,
        totalProcessed,
        totalNewLeads,
      });
    } catch (error: any) {
      console.error('åŒæ­¥åå–®å¤±æ•—:', error);

      // è¨˜éŒ„éŒ¯èª¤åˆ°è³‡æ–™åº«
      if (isSupabaseAvailable()) {
        const supabase = getSupabaseClient();
        const { data: settings } = await supabase
          .from('facebook_settings')
          .select('id')
          .single();

        if (settings) {
          await supabase
            .from('facebook_settings')
            .update({
              last_sync_at: new Date().toISOString(),
              last_sync_status: 'error',
              last_sync_error: error.message,
            })
            .eq('id', settings.id);
        }
      }

      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // GoHighLevel Webhook Integration
  // ========================================

  // Webhook - æ¥æ”¶ GoHighLevel Contact è³‡æ–™
  app.post('/api/webhooks/gohighlevel', async (req, res) => {
    try {
      console.log('ğŸ“¨ æ”¶åˆ° GoHighLevel webhook:', JSON.stringify(req.body, null, 2));

      const contactData = req.body;

      // é©—è­‰å¿…è¦æ¬„ä½
      if (!contactData.id && !contactData.contactId) {
        console.warn('âš ï¸  GoHighLevel webhook ç¼ºå°‘ contact ID');
        return res.status(400).json({ error: 'Missing contact ID' });
      }

      const pool = createPool();

      // æå–é—œéµæ¬„ä½
      const contactId = contactData.id || contactData.contactId;
      const firstName = contactData.firstName || contactData.first_name || '';
      const lastName = contactData.lastName || contactData.last_name || '';
      const name = contactData.name || contactData.fullName || `${firstName} ${lastName}`.trim();
      const email = contactData.email || '';
      const phone = contactData.phone || contactData.phoneNumber || '';
      const tags = contactData.tags || [];
      const source = contactData.source || contactData.leadSource || '';
      const locationId = contactData.locationId || contactData.location_id || '';
      const companyName = contactData.companyName || contactData.company || '';
      const address = contactData.address || '';
      const city = contactData.city || '';
      const state = contactData.state || '';
      const postalCode = contactData.postalCode || contactData.postal_code || '';
      const country = contactData.country || '';

      // æå–è‡ªè¨‚æ¬„ä½
      const customFields = contactData.customFields || contactData.customField || {};

      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé˜²æ­¢é‡è¤‡ï¼‰
      const existingContact = await queryDatabase(
        pool,
        'SELECT id FROM gohighlevel_contacts WHERE contact_id = $1',
        [contactId]
      );

      let result;

      if (existingContact.rows.length > 0) {
        // æ›´æ–°ç¾æœ‰è¯çµ¡äºº
        console.log(`â„¹ï¸  æ›´æ–°ç¾æœ‰è¯çµ¡äºº: ${contactId}`);
        result = await queryDatabase(
          pool,
          `UPDATE gohighlevel_contacts
           SET name = $1, first_name = $2, last_name = $3, email = $4, phone = $5,
               tags = $6, source = $7, location_id = $8, company_name = $9,
               address = $10, city = $11, state = $12, postal_code = $13, country = $14,
               custom_fields = $15, raw_data = $16, updated_at = NOW()
           WHERE contact_id = $17
           RETURNING *`,
          [
            name, firstName, lastName, email, phone,
            tags, source, locationId, companyName,
            address, city, state, postalCode, country,
            JSON.stringify(customFields), JSON.stringify(contactData), contactId
          ]
        );
      } else {
        // æ–°å¢è¯çµ¡äºº
        console.log(`âœ¨ æ–°å¢è¯çµ¡äºº: ${contactId}`);
        result = await queryDatabase(
          pool,
          `INSERT INTO gohighlevel_contacts
           (contact_id, name, first_name, last_name, email, phone, tags, source,
            location_id, company_name, address, city, state, postal_code, country,
            custom_fields, raw_data)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
           RETURNING *`,
          [
            contactId, name, firstName, lastName, email, phone, tags, source,
            locationId, companyName, address, city, state, postalCode, country,
            JSON.stringify(customFields), JSON.stringify(contactData)
          ]
        );
      }

      // pool.end() removed - using shared pool

      console.log('âœ… GoHighLevel contact å·²å„²å­˜:', contactId);

      res.json({
        success: true,
        message: 'Contact received and stored',
        contactId: contactId,
      });

    } catch (error: any) {
      console.error('âŒ GoHighLevel webhook è™•ç†å¤±æ•—:', error);
      res.status(500).json({
        error: 'Internal server error',
        message: error.message,
      });
    }
  });

  // GET - æŸ¥è©¢ GoHighLevel Contacts åˆ—è¡¨
  app.get('/api/gohighlevel/contacts', isAuthenticated, async (req, res) => {
    try {
      const {
        search,
        source,
        start_date,
        end_date,
        page = '1',
        limit = '20',
      } = req.query;

      const pool = createPool();

      // å»ºç«‹æŸ¥è©¢æ¢ä»¶
      const conditions: string[] = ['1=1'];
      const params: any[] = [];
      let paramIndex = 1;

      // æœå°‹æ¢ä»¶ï¼ˆå§“åã€é›»è©±ã€Emailï¼‰
      if (search && typeof search === 'string') {
        conditions.push(`(name ILIKE $${paramIndex} OR phone ILIKE $${paramIndex} OR email ILIKE $${paramIndex})`);
        params.push(`%${search}%`);
        paramIndex++;
      }

      // ä¾†æºç¯©é¸
      if (source && typeof source === 'string') {
        conditions.push(`source = $${paramIndex}`);
        params.push(source);
        paramIndex++;
      }

      // æ—¥æœŸç¯„åœ
      if (start_date && typeof start_date === 'string') {
        conditions.push(`created_at >= $${paramIndex}`);
        params.push(start_date);
        paramIndex++;
      }

      if (end_date && typeof end_date === 'string') {
        conditions.push(`created_at <= $${paramIndex}`);
        params.push(end_date);
        paramIndex++;
      }

      // è¨ˆç®—ç¸½æ•¸
      const countQuery = `SELECT COUNT(*) FROM gohighlevel_contacts WHERE ${conditions.join(' AND ')}`;
      const countResult = await queryDatabase(pool, countQuery, params);
      const total = parseInt(countResult.rows[0].count);

      // åˆ†é 
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);
      const offset = (pageNum - 1) * limitNum;

      // æŸ¥è©¢è³‡æ–™
      const dataQuery = `
        SELECT * FROM gohighlevel_contacts
        WHERE ${conditions.join(' AND ')}
        ORDER BY created_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      const dataResult = await queryDatabase(pool, dataQuery, [...params, limitNum, offset]);

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: dataResult.rows,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum),
        },
      });

    } catch (error: any) {
      console.error('æŸ¥è©¢ GoHighLevel contacts å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - å–å¾—å–®ä¸€ Contact è©³æƒ…
  app.get('/api/gohighlevel/contacts/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const pool = createPool();

      const result = await queryDatabase(
        pool,
        'SELECT * FROM gohighlevel_contacts WHERE id = $1',
        [id]
      );

      // pool.end() removed - using shared pool

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°æ­¤è¯çµ¡äºº' });
      }

      res.json({ success: true, data: result.rows[0] });

    } catch (error: any) {
      console.error('æŸ¥è©¢ contact è©³æƒ…å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - çµ±è¨ˆè³‡æ–™
  app.get('/api/gohighlevel/stats', isAuthenticated, async (req, res) => {
    try {
      const pool = createPool();

      // ç¸½è¯çµ¡äººæ•¸
      const totalResult = await queryDatabase(pool, 'SELECT COUNT(*) FROM gohighlevel_contacts');
      const total = parseInt(totalResult.rows[0].count);

      // ä»Šæ—¥æ–°å¢
      const todayResult = await queryDatabase(
        pool,
        `SELECT COUNT(*) FROM gohighlevel_contacts
         WHERE created_at >= CURRENT_DATE`
      );
      const today = parseInt(todayResult.rows[0].count);

      // æœ¬é€±æ–°å¢
      const weekResult = await queryDatabase(
        pool,
        `SELECT COUNT(*) FROM gohighlevel_contacts
         WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'`
      );
      const week = parseInt(weekResult.rows[0].count);

      // ä¾ä¾†æºåˆ†çµ„
      const sourceResult = await queryDatabase(
        pool,
        `SELECT source, COUNT(*) as count
         FROM gohighlevel_contacts
         WHERE source IS NOT NULL AND source != ''
         GROUP BY source
         ORDER BY count DESC`
      );

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: {
          total,
          today,
          week,
          bySources: sourceResult.rows,
        },
      });

    } catch (error: any) {
      console.error('æŸ¥è©¢çµ±è¨ˆè³‡æ–™å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================================================
  // Student Knowledge Base & AI Conversation API
  // ============================================================================

  // 1. Get student complete profile
  app.get('/api/teaching-quality/student/:email/profile', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const studentKnowledgeService = await import('./services/student-knowledge-service');

      const context = await studentKnowledgeService.getStudentFullContext(email);

      res.json({
        success: true,
        data: context
      });
    } catch (error: any) {
      console.error('å–å¾—å­¸å“¡æª”æ¡ˆå¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 2. Ask AI preset question
  app.post('/api/teaching-quality/student/:email/ask-preset', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { questionType } = req.body;
      const teacherId = req.user.id;

      if (!questionType) {
        return res.status(400).json({ error: 'Missing questionType' });
      }

      const aiConversationService = await import('./services/ai-conversation-service');

      const result = await aiConversationService.askPresetQuestion(teacherId, email, questionType);

      res.json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('AI é è¨­å•é¡ŒæŸ¥è©¢å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 3. Ask AI custom question
  app.post('/api/teaching-quality/student/:email/ask-custom', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { question } = req.body;
      const teacherId = req.user.id;

      if (!question || question.trim() === '') {
        return res.status(400).json({ error: 'Missing question' });
      }

      const aiConversationService = await import('./services/ai-conversation-service');

      const result = await aiConversationService.askCustomQuestion(teacherId, email, question);

      res.json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('AI è‡ªè¨‚å•é¡ŒæŸ¥è©¢å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 4. Get conversation history
  app.get('/api/teaching-quality/student/:email/conversations', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const teacherId = req.user.id;
      const limit = parseInt(req.query.limit as string) || 20;

      const aiConversationService = await import('./services/ai-conversation-service');

      const conversations = await aiConversationService.getConversationHistory(teacherId, email, limit);

      res.json({
        success: true,
        data: conversations
      });
    } catch (error: any) {
      console.error('å–å¾—å°è©±æ­·å²å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 5. Get preset questions list
  app.get('/api/teaching-quality/preset-questions', isAuthenticated, async (req: any, res) => {
    try {
      const aiConversationService = await import('./services/ai-conversation-service');

      res.json({
        success: true,
        data: aiConversationService.PRESET_QUESTIONS
      });
    } catch (error: any) {
      console.error('å–å¾—é è¨­å•é¡Œæ¸…å–®å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 6. Save insight to knowledge base
  app.post('/api/teaching-quality/student/:email/save-insight', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { conversationId, question, answer } = req.body;

      if (!conversationId || !question || !answer) {
        return res.status(400).json({ error: 'ç¼ºå°‘å¿…è¦åƒæ•¸' });
      }

      const studentKnowledgeService = await import('./services/student-knowledge-service');

      await studentKnowledgeService.saveInsightToKnowledgeBase(
        email,
        conversationId,
        question,
        answer
      );

      res.json({
        success: true,
        message: 'å·²å„²å­˜åˆ°çŸ¥è­˜åº«'
      });
    } catch (error: any) {
      console.error('å„²å­˜åˆ°çŸ¥è­˜åº«å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 6. Sync all students to knowledge base (manual trigger)
  app.post('/api/students/sync-all', isAuthenticated, requireAdmin, async (req: any, res) => {
    try {
      console.log('ğŸ”„ Manual student KB sync triggered by:', req.user.email);
      const studentKnowledgeService = await import('./services/student-knowledge-service');

      const result = await studentKnowledgeService.syncAllStudentsToKB();

      res.json({
        success: true,
        message: 'å­¸å“¡æª”æ¡ˆåŒæ­¥å®Œæˆ',
        data: result
      });
    } catch (error: any) {
      console.error('å­¸å“¡æª”æ¡ˆåŒæ­¥å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 7. Get all students list with filters
  app.get('/api/students/list', isAuthenticated, async (req: any, res) => {
    try {
      const { queryDatabase } = await import('./services/pg-client');

      // Get pagination params
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = (page - 1) * limit;
      const search = req.query.search as string || '';
      const showDeleted = req.query.showDeleted === 'true';

      // Get filter params
      const teacherFilter = req.query.teacher as string || '';
      const consultantFilter = req.query.consultant as string || '';
      const conversionFilter = req.query.conversionStatus as string || '';
      const consultationFilter = req.query.consultationStatus as string || '';
      const lastInteractionFilter = req.query.lastInteraction as string || '';

      // Build WHERE clause
      const whereConditions = ['1=1']; // Start with always true
      const havingConditions = [];
      const params: any[] = [];
      let paramIndex = 1;

      if (!showDeleted) {
        whereConditions.push(`(skb.is_deleted = false OR skb.is_deleted IS NULL)`);
      }

      if (search) {
        whereConditions.push(`(skb.student_name ILIKE $${paramIndex} OR skb.student_email ILIKE $${paramIndex})`);
        params.push(`%${search}%`);
        paramIndex++;
      }

      // Filter by teacher
      if (teacherFilter) {
        whereConditions.push(`EXISTS(
          SELECT 1 FROM trial_class_attendance
          WHERE student_email = skb.student_email
          AND teacher_name = $${paramIndex}
        )`);
        params.push(teacherFilter);
        paramIndex++;
      }

      // Filter by consultant
      if (consultantFilter) {
        whereConditions.push(`EXISTS(
          SELECT 1 FROM eods_for_closers
          WHERE student_email = skb.student_email
          AND closer_name = $${paramIndex}
        )`);
        params.push(consultantFilter);
        paramIndex++;
      }

      // Filter by conversion status (4 ç¨®ç‹€æ…‹)
      if (conversionFilter) {
        if (conversionFilter === 'renewed_high') {
          // å·²çºŒèª²é«˜åƒ¹ï¼šè³¼è²· 2 æ¬¡ä»¥ä¸Šé«˜åƒ¹æ–¹æ¡ˆ
          whereConditions.push(`
            (SELECT COUNT(*) FROM eods_for_closers
             WHERE student_email = skb.student_email
             AND plan LIKE '%é«˜éšä¸€å°ä¸€è¨“ç·´%'
             AND actual_amount IS NOT NULL
             AND actual_amount != ''
             AND REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') ~ '^[0-9.]+$'
             AND CAST(REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') AS NUMERIC) > 0) >= 2
          `);
        } else if (conversionFilter === 'purchased_high') {
          // å·²è³¼è²·é«˜åƒ¹ï¼šè³¼è²· 1 æ¬¡é«˜åƒ¹æ–¹æ¡ˆ
          whereConditions.push(`
            (SELECT COUNT(*) FROM eods_for_closers
             WHERE student_email = skb.student_email
             AND plan LIKE '%é«˜éšä¸€å°ä¸€è¨“ç·´%'
             AND actual_amount IS NOT NULL
             AND actual_amount != ''
             AND REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') ~ '^[0-9.]+$'
             AND CAST(REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') AS NUMERIC) > 0) = 1
          `);
        } else if (conversionFilter === 'purchased_trial') {
          // å·²è³¼è²·é«”é©—èª²
          whereConditions.push(`
            EXISTS(SELECT 1 FROM trial_class_purchases WHERE student_email = skb.student_email)
          `);
        } else if (conversionFilter === 'not_purchased') {
          // æœªè³¼è²·
          whereConditions.push(`
            NOT EXISTS(SELECT 1 FROM trial_class_purchases WHERE student_email = skb.student_email)
          `);
        }
      }

      // Filter by consultation status (3 ç¨®ç‹€æ…‹)
      if (consultationFilter) {
        if (consultationFilter === 'consulted') {
          // å·²è«®è©¢ï¼šæœ‰è«®è©¢è¨˜éŒ„ä¸” is_show = 'å·²ä¸Šç·š'
          whereConditions.push(`
            EXISTS(SELECT 1 FROM eods_for_closers WHERE student_email = skb.student_email AND is_show = 'å·²ä¸Šç·š')
          `);
        } else if (consultationFilter === 'no_show') {
          // æ”¾é³¥ï¼šæœ‰è«®è©¢è¨˜éŒ„ä¸” is_show != 'å·²ä¸Šç·š'
          whereConditions.push(`
            EXISTS(SELECT 1 FROM eods_for_closers WHERE student_email = skb.student_email AND is_show != 'å·²ä¸Šç·š')
          `);
        } else if (consultationFilter === 'not_consulted') {
          // æœªè«®è©¢ï¼šæ²’æœ‰è«®è©¢è¨˜éŒ„
          whereConditions.push(`
            NOT EXISTS(SELECT 1 FROM eods_for_closers WHERE student_email = skb.student_email)
          `);
        }
      }

      // Filter by last interaction date
      if (lastInteractionFilter) {
        const now = new Date();
        let daysAgo = 0;

        if (lastInteractionFilter === 'today') daysAgo = 0;
        else if (lastInteractionFilter === '3days') daysAgo = 3;
        else if (lastInteractionFilter === '7days') daysAgo = 7;
        else if (lastInteractionFilter === '30days') daysAgo = 30;
        else if (lastInteractionFilter === 'over30days') {
          whereConditions.push(`
            (
              SELECT MAX(latest_interaction)
              FROM (
                SELECT MAX(class_date) as latest_interaction
                FROM trial_class_attendance
                WHERE student_email = skb.student_email
                UNION ALL
                SELECT MAX(created_at)::date as latest_interaction
                FROM eods_for_closers
                WHERE student_email = skb.student_email
                UNION ALL
                SELECT MAX(purchase_date) as latest_interaction
                FROM trial_class_purchases
                WHERE student_email = skb.student_email
              ) as all_interactions
            ) < CURRENT_DATE - INTERVAL '30 days'
          `);
        }

        if (daysAgo >= 0 && lastInteractionFilter !== 'over30days') {
          whereConditions.push(`
            (
              SELECT MAX(latest_interaction)
              FROM (
                SELECT MAX(class_date) as latest_interaction
                FROM trial_class_attendance
                WHERE student_email = skb.student_email
                UNION ALL
                SELECT MAX(created_at)::date as latest_interaction
                FROM eods_for_closers
                WHERE student_email = skb.student_email
                UNION ALL
                SELECT MAX(purchase_date) as latest_interaction
                FROM trial_class_purchases
                WHERE student_email = skb.student_email
              ) as all_interactions
            ) >= CURRENT_DATE - INTERVAL '${daysAgo} days'
          `);
        }
      }

      const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
      const havingClause = havingConditions.length > 0 ? `HAVING ${havingConditions.join(' AND ')}` : '';

      // Get total count (need to use subquery for HAVING clause)
      const countQuery = `
        SELECT COUNT(*) as total
        FROM (
          SELECT skb.student_email
          FROM student_knowledge_base skb
          LEFT JOIN trial_class_attendance tca ON skb.student_email = tca.student_email
          LEFT JOIN eods_for_closers eods ON skb.student_email = eods.student_email
          LEFT JOIN trial_class_purchases tcp ON skb.student_email = tcp.student_email
          ${whereClause}
          GROUP BY skb.student_email
          ${havingClause}
        ) AS filtered_students
      `;

      const countResult = await queryDatabase(countQuery, params, 'session');
      const total = parseInt(countResult.rows[0].total);

      // Get students list with all required fields
      params.push(limit);
      const limitParam = paramIndex;
      paramIndex++;
      params.push(offset);
      const offsetParam = paramIndex;

      const studentsResult = await queryDatabase(`
        SELECT
          skb.id,
          skb.student_email,
          skb.student_name,
          skb.total_classes,
          skb.total_consultations,
          skb.total_interactions,
          skb.first_contact_date,
          skb.last_interaction_date,
          skb.is_deleted,

          -- Phone (å¾å¤šå€‹ä¾†æºå–å¾—æœ€æ–°çš„)
          COALESCE(
            (SELECT student_phone FROM eods_for_closers
             WHERE student_email = skb.student_email
             AND student_phone IS NOT NULL
             ORDER BY created_at DESC LIMIT 1),
            (SELECT student_phone FROM trial_class_attendance
             WHERE student_email = skb.student_email
             AND student_phone IS NOT NULL
             ORDER BY class_date DESC LIMIT 1),
            (SELECT student_phone FROM ad_leads
             WHERE student_email = skb.student_email
             AND student_phone IS NOT NULL
             ORDER BY created_at DESC LIMIT 1)
          ) as phone,

          -- Total spent (ç´¯ç©èŠ±è²» - ä½¿ç”¨ actual_amountï¼Œç§»é™¤è²¨å¹£ç¬¦è™Ÿå’Œé€—è™Ÿ)
          COALESCE(
            (SELECT SUM(
               CAST(
                 REGEXP_REPLACE(
                   REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g'),
                   '^\\.+|\\.+$', '', 'g'
                 ) AS NUMERIC
               )
             )
             FROM eods_for_closers
             WHERE student_email = skb.student_email
             AND actual_amount IS NOT NULL
             AND actual_amount != ''
             AND REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') ~ '^[0-9.]+$'),
            0
          ) as total_spent,

          -- Conversion status (è½‰æ›ç‹€æ…‹ - 4 ç¨®ç‹€æ…‹ï¼šå·²çºŒèª²é«˜åƒ¹ã€å·²è³¼è²·é«˜åƒ¹ã€å·²è³¼è²·é«”é©—èª²ã€æœªè³¼è²·)
          CASE
            -- å·²çºŒèª²é«˜åƒ¹ï¼šè³¼è²· 2 æ¬¡ä»¥ä¸Šé«˜åƒ¹æ–¹æ¡ˆ
            WHEN (
              SELECT COUNT(*) FROM eods_for_closers
              WHERE student_email = skb.student_email
              AND plan LIKE '%é«˜éšä¸€å°ä¸€è¨“ç·´%'
              AND actual_amount IS NOT NULL
              AND actual_amount != ''
              AND REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') ~ '^[0-9.]+$'
              AND CAST(REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') AS NUMERIC) > 0
            ) >= 2 THEN 'renewed_high'

            -- å·²è³¼è²·é«˜åƒ¹ï¼šè³¼è²· 1 æ¬¡é«˜åƒ¹æ–¹æ¡ˆ
            WHEN (
              SELECT COUNT(*) FROM eods_for_closers
              WHERE student_email = skb.student_email
              AND plan LIKE '%é«˜éšä¸€å°ä¸€è¨“ç·´%'
              AND actual_amount IS NOT NULL
              AND actual_amount != ''
              AND REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') ~ '^[0-9.]+$'
              AND CAST(REGEXP_REPLACE(actual_amount, '[^0-9.]', '', 'g') AS NUMERIC) > 0
            ) = 1 THEN 'purchased_high'

            -- å·²è³¼è²·é«”é©—èª²ï¼šåœ¨ trial_class_purchases æœ‰è¨˜éŒ„
            WHEN EXISTS(
              SELECT 1 FROM trial_class_purchases
              WHERE student_email = skb.student_email
            ) THEN 'purchased_trial'

            -- æœªè³¼è²·ï¼šæ²’æœ‰ä»»ä½•è³¼è²·è¨˜éŒ„
            ELSE 'not_purchased'
          END as conversion_status,

          -- Consultation status (è«®è©¢ç‹€æ…‹ - 3 ç¨®ç‹€æ…‹ï¼šå·²è«®è©¢ã€æ”¾é³¥ã€æœªè«®è©¢)
          CASE
            -- æ”¾é³¥ï¼šæœ‰è«®è©¢è¨˜éŒ„ä¸” is_show != 'å·²ä¸Šç·š'
            WHEN EXISTS(
              SELECT 1 FROM eods_for_closers
              WHERE student_email = skb.student_email
              AND is_show != 'å·²ä¸Šç·š'
            ) THEN 'no_show'

            -- å·²è«®è©¢ï¼šæœ‰è«®è©¢è¨˜éŒ„ä¸” is_show = 'å·²ä¸Šç·š'
            WHEN EXISTS(
              SELECT 1 FROM eods_for_closers
              WHERE student_email = skb.student_email
              AND is_show = 'å·²ä¸Šç·š'
            ) THEN 'consulted'

            -- æœªè«®è©¢ï¼šæ²’æœ‰è«®è©¢è¨˜éŒ„
            ELSE 'not_consulted'
          END as consultation_status,

          -- Teacher (æœ€è¿‘çš„è² è²¬è€å¸«)
          (SELECT teacher_name FROM trial_class_attendance
           WHERE student_email = skb.student_email
           ORDER BY class_date DESC LIMIT 1) as teacher,

          -- Consultant (æœ€è¿‘çš„è«®è©¢å¸« closer_name)
          (SELECT closer_name FROM eods_for_closers
           WHERE student_email = skb.student_email
           ORDER BY created_at DESC LIMIT 1) as consultant,

          -- Last interaction type and date (ä½¿ç”¨å¯¦éš›æ—¥æœŸè€Œé created_at)
          (
            SELECT json_build_object(
              'type', interaction_type,
              'date', interaction_date
            )
            FROM (
              SELECT 'class' as interaction_type, class_date::text as interaction_date
              FROM trial_class_attendance
              WHERE student_email = skb.student_email
              UNION ALL
              SELECT 'consultation' as interaction_type, consultation_date::text as interaction_date
              FROM eods_for_closers
              WHERE student_email = skb.student_email
              AND consultation_date IS NOT NULL
              UNION ALL
              SELECT 'purchase' as interaction_type, purchase_date::text as interaction_date
              FROM trial_class_purchases
              WHERE student_email = skb.student_email
              ORDER BY interaction_date DESC
              LIMIT 1
            ) as latest
          ) as last_interaction

        FROM student_knowledge_base skb
        ${whereClause}
        GROUP BY skb.id, skb.student_email, skb.student_name, skb.total_classes,
                 skb.total_consultations, skb.total_interactions, skb.first_contact_date,
                 skb.last_interaction_date, skb.is_deleted
        ${havingClause}
        ORDER BY (
          SELECT MAX(interaction_timestamp)
          FROM (
            SELECT
              CASE
                WHEN class_date IS NOT NULL THEN class_date::timestamp + (created_at::time)
                ELSE NULL
              END as interaction_timestamp
            FROM trial_class_attendance
            WHERE student_email = skb.student_email
            AND class_date IS NOT NULL
            UNION ALL
            SELECT
              CASE
                WHEN consultation_date IS NOT NULL THEN consultation_date::timestamp + (created_at::time)
                ELSE NULL
              END as interaction_timestamp
            FROM eods_for_closers
            WHERE student_email = skb.student_email
            AND consultation_date IS NOT NULL
            UNION ALL
            SELECT
              CASE
                WHEN purchase_date IS NOT NULL THEN purchase_date::timestamp + (created_at::time)
                ELSE NULL
              END as interaction_timestamp
            FROM trial_class_purchases
            WHERE student_email = skb.student_email
            AND purchase_date IS NOT NULL
          ) all_interactions
        ) DESC NULLS LAST
        LIMIT $${limitParam} OFFSET $${offsetParam}
      `, params, 'session');

      // Get filter options (teachers, consultants)
      const teachersResult = await queryDatabase(`
        SELECT DISTINCT teacher_name
        FROM trial_class_attendance
        WHERE teacher_name IS NOT NULL AND teacher_name != ''
        ORDER BY teacher_name
      `, [], 'session');

      const consultantsResult = await queryDatabase(`
        SELECT DISTINCT closer_name as consultant
        FROM eods_for_closers
        WHERE closer_name IS NOT NULL AND closer_name != ''
        ORDER BY closer_name
      `, [], 'session');

      res.json({
        success: true,
        data: {
          students: studentsResult.rows,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit)
          },
          filterOptions: {
            teachers: teachersResult.rows.map(r => r.teacher_name),
            consultants: consultantsResult.rows.map(r => r.consultant)
          }
        }
      });
    } catch (error: any) {
      console.error('å–å¾—å­¸å“¡åˆ—è¡¨å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ===================================
  // Google Sheets åŒæ­¥ API (Phase 39)
  // ===================================

  const { GoogleSheetsAPI } = await import('./services/sheets/google-sheets-api');
  const { SyncService } = await import('./services/sheets/sync-service');
  const { queryDatabase: qdb, insertAndReturn: iar } = await import('./services/pg-client');

  // å–å¾— Google Sheets æ†‘è­‰
  const getGoogleCredentials = () => {
    if (!process.env.GOOGLE_SHEETS_CREDENTIALS) {
      throw new Error('GOOGLE_SHEETS_CREDENTIALS not configured');
    }
    return process.env.GOOGLE_SHEETS_CREDENTIALS;
  };

  // ===================================
  // è³‡æ–™ä¾†æºç®¡ç†
  // ===================================

  // æ–°å¢è³‡æ–™ä¾†æº
  app.post('/api/sheets/sources', async (req, res) => {
    try {
      const { name, sheet_url } = req.body;

      if (!name || !sheet_url) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: name, sheet_url'
        });
      }

      // å¾ URL è§£æ Sheet ID
      const sheet_id = GoogleSheetsAPI.extractSheetId(sheet_url);

      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„ Sheet ID
      const existing = await qdb('SELECT * FROM google_sheets_sources WHERE sheet_id = $1', [sheet_id]);
      if (existing.rows.length > 0) {
        return res.status(400).json({
          success: false,
          error: `æ­¤ Google Sheets å·²ç¶“å­˜åœ¨æ–¼ç³»çµ±ä¸­ï¼ˆåç¨±: ${existing.rows[0].name}ï¼‰`
        });
      }

      const source = await iar('google_sheets_sources', {
        name,
        sheet_url,
        sheet_id
      });

      res.json({ success: true, data: source });
    } catch (error: any) {
      console.error('Error creating source:', error);

      // è™•ç†ç‰¹å®šè³‡æ–™åº«éŒ¯èª¤
      let errorMessage = error.message;
      if (error.code === '23505' && error.constraint === 'google_sheets_sources_sheet_id_key') {
        errorMessage = 'æ­¤ Google Sheets å·²ç¶“å­˜åœ¨æ–¼ç³»çµ±ä¸­';
      }

      res.status(500).json({ success: false, error: errorMessage });
    }
  });

  // åˆ—å‡ºæ‰€æœ‰è³‡æ–™ä¾†æº
  app.get('/api/sheets/sources', async (req, res) => {
    try {
      const result = await qdb('SELECT * FROM google_sheets_sources ORDER BY created_at DESC');
      res.json({ success: true, data: result.rows });
    } catch (error: any) {
      console.error('Error listing sources:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åˆªé™¤è³‡æ–™ä¾†æº
  app.delete('/api/sheets/sources/:id', async (req, res) => {
    try {
      const { id } = req.params;
      await qdb('DELETE FROM google_sheets_sources WHERE id = $1', [id]);
      res.json({ success: true });
    } catch (error: any) {
      console.error('Error deleting source:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ===================================
  // å·¥ä½œè¡¨ç®¡ç†
  // ===================================

  // åˆ—å‡ºå·¥ä½œè¡¨
  app.get('/api/sheets/:sourceId/worksheets', async (req, res) => {
    try {
      const { sourceId } = req.params;

      // å–å¾—è³‡æ–™ä¾†æº
      const result = await qdb('SELECT * FROM google_sheets_sources WHERE id = $1', [sourceId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'Source not found' });
      }

      const source = result.rows[0];
      const api = new GoogleSheetsAPI(getGoogleCredentials());
      const worksheets = await api.listWorksheets(source.sheet_id);

      // éæ¿¾æ‰ç©ºå­—ä¸²çš„å·¥ä½œè¡¨åç¨±ï¼ˆé¿å…å‰ç«¯ Select å…ƒä»¶éŒ¯èª¤ï¼‰
      const validWorksheets = worksheets.filter((name: string) => name && name.trim() !== '');

      res.json({ success: true, data: validWorksheets });
    } catch (error: any) {
      console.error('Error listing worksheets:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // è®€å–å·¥ä½œè¡¨æ¨™é¡Œ
  app.get('/api/sheets/:sourceId/worksheets/:worksheetName/headers', async (req, res) => {
    try {
      const { sourceId, worksheetName } = req.params;

      const result = await qdb('SELECT * FROM google_sheets_sources WHERE id = $1', [sourceId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'Source not found' });
      }

      const source = result.rows[0];
      const api = new GoogleSheetsAPI(getGoogleCredentials());
      const headers = await api.getWorksheetHeaders(source.sheet_id, worksheetName);

      res.json({ success: true, data: headers });
    } catch (error: any) {
      console.error('Error reading headers:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ===================================
  // æ˜ å°„ç®¡ç†
  // ===================================

  // å»ºç«‹æ˜ å°„
  app.post('/api/sheets/mappings', async (req, res) => {
    try {
      const { source_id, worksheet_name, target_table, field_mappings, is_enabled, sync_schedule, upsert_config } = req.body;

      if (!source_id || !worksheet_name || !target_table || !field_mappings) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      // ğŸ”‘ è™•ç† UPSERT é…ç½®
      const upsertConfigValue = upsert_config && upsert_config.uniqueKeys && upsert_config.uniqueKeys.length > 0
        ? JSON.stringify(upsert_config)
        : null;

      const mapping = await iar('sheet_mappings', {
        source_id,
        worksheet_name,
        target_table,
        field_mappings: JSON.stringify(field_mappings),
        is_enabled: is_enabled !== undefined ? is_enabled : true,
        sync_schedule: JSON.stringify(sync_schedule || ['02:00']),
        upsert_config: upsertConfigValue,
      });

      res.json({ success: true, data: mapping });
    } catch (error: any) {
      console.error('Error creating mapping:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åˆ—å‡ºæ‰€æœ‰æ˜ å°„
  app.get('/api/sheets/mappings', async (req, res) => {
    try {
      const result = await qdb(`
        SELECT
          sm.*,
          gs.name as source_name,
          gs.sheet_url
        FROM sheet_mappings sm
        JOIN google_sheets_sources gs ON sm.source_id = gs.id
        ORDER BY sm.created_at DESC
      `);
      res.json({ success: true, data: result.rows });
    } catch (error: any) {
      console.error('Error listing mappings:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // å–å¾—å–®ä¸€æ˜ å°„
  app.get('/api/sheets/mappings/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const result = await qdb(`
        SELECT
          sm.*,
          gs.name as source_name,
          gs.sheet_url,
          gs.sheet_id
        FROM sheet_mappings sm
        JOIN google_sheets_sources gs ON sm.source_id = gs.id
        WHERE sm.id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'Mapping not found' });
      }

      res.json({ success: true, data: result.rows[0] });
    } catch (error: any) {
      console.error('Error getting mapping:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ›´æ–°æ˜ å°„
  app.put('/api/sheets/mappings/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const { field_mappings, is_enabled, sync_schedule, upsert_config } = req.body;

      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (field_mappings !== undefined) {
        updates.push(`field_mappings = $${paramIndex}`);
        values.push(JSON.stringify(field_mappings));
        paramIndex++;
      }

      if (is_enabled !== undefined) {
        updates.push(`is_enabled = $${paramIndex}`);
        values.push(is_enabled);
        paramIndex++;
      }

      if (sync_schedule !== undefined) {
        updates.push(`sync_schedule = $${paramIndex}`);
        values.push(JSON.stringify(sync_schedule));
        paramIndex++;
      }

      // ğŸ”‘ æ”¯æ´æ›´æ–° UPSERT é…ç½®
      if (upsert_config !== undefined) {
        updates.push(`upsert_config = $${paramIndex}`);
        // å¦‚æœå‚³å…¥ null æˆ–ç©ºç‰©ä»¶ï¼Œè¨­ç‚º NULLï¼ˆä½¿ç”¨ DELETE + INSERTï¼‰
        const configValue = upsert_config && upsert_config.uniqueKeys && upsert_config.uniqueKeys.length > 0
          ? JSON.stringify(upsert_config)
          : null;
        values.push(configValue);
        paramIndex++;
      }

      updates.push(`updated_at = now()`);
      values.push(id);

      await qdb(`
        UPDATE sheet_mappings
        SET ${updates.join(', ')}
        WHERE id = $${paramIndex}
      `, values);

      res.json({ success: true });
    } catch (error: any) {
      console.error('Error updating mapping:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åˆªé™¤æ˜ å°„
  app.delete('/api/sheets/mappings/:id', async (req, res) => {
    try {
      const { id } = req.params;
      await qdb('DELETE FROM sheet_mappings WHERE id = $1', [id]);
      res.json({ success: true });
    } catch (error: any) {
      console.error('Error deleting mapping:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ===================================
  // åŒæ­¥åŠŸèƒ½
  // ===================================

  // æ‰‹å‹•åŒæ­¥ (with SSE progress) - GET for EventSource
  app.get('/api/sheets/sync/:mappingId', async (req, res) => {
    try {
      const { mappingId } = req.params;

      console.log('ğŸ”„ Starting SSE sync for mapping:', mappingId);

      // è¨­å®š SSE headers
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no', // ç¦ç”¨ Nginx ç·©è¡
      });

      // å»ºç«‹ SyncService ä¸¦å‚³å…¥é€²åº¦ callback
      const syncService = new SyncService(getGoogleCredentials(), (progress) => {
        // ç™¼é€é€²åº¦æ›´æ–°
        console.log('ğŸ“Š Progress:', progress.stage, progress.percentage + '%');
        res.write(`data: ${JSON.stringify(progress)}\n\n`);
      });

      try {
        await syncService.syncMapping(mappingId);
        console.log('âœ… Sync completed');
        res.write('data: {"stage":"completed"}\n\n');
        res.end();
      } catch (error: any) {
        console.error('âŒ Sync failed:', error);
        res.write(`data: ${JSON.stringify({ stage: 'failed', message: error.message })}\n\n`);
        res.end();
      }
    } catch (error: any) {
      console.error('Error in SSE sync:', error);
      if (!res.headersSent) {
        res.status(500).json({ success: false, error: error.message });
      }
    }
  });

  // æ‰‹å‹•åŒæ­¥ - POST fallback (ç„¡é€²åº¦)
  app.post('/api/sheets/sync/:mappingId', async (req, res) => {
    try {
      const { mappingId } = req.params;
      console.log('ğŸ”„ Starting standard sync for mapping:', mappingId);

      const syncService = new SyncService(getGoogleCredentials());
      await syncService.syncMapping(mappingId);

      res.json({ success: true, message: 'Sync completed successfully' });
    } catch (error: any) {
      console.error('Error syncing:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // åŒæ­¥æ­·å²è¨˜éŒ„
  app.get('/api/sheets/logs', async (req, res) => {
    try {
      const result = await qdb(`
        SELECT
          sl.*,
          sm.worksheet_name,
          sm.target_table,
          gs.name as source_name
        FROM sync_logs sl
        JOIN sheet_mappings sm ON sl.mapping_id = sm.id
        JOIN google_sheets_sources gs ON sm.source_id = gs.id
        ORDER BY sl.synced_at DESC
        LIMIT 100
      `);

      // æ ¼å¼åŒ–éŸ¿æ‡‰ï¼Œå°‡ mapping è³‡è¨Šæ•´ç†æˆç‰©ä»¶
      const formattedLogs = result.rows.map((row: any) => ({
        ...row,
        mapping: {
          worksheet_name: row.worksheet_name,
          target_table: row.target_table,
          source_name: row.source_name,
        },
      }));

      res.json({ success: true, data: formattedLogs });
    } catch (error: any) {
      console.error('Error fetching logs:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // æ³¨æ„: /api/database/tables/:tableName/columns ç«¯é»å·²ç¶“åœ¨ 5950 è¡Œå®šç¾©
  // å›å‚³æ ¼å¼: { columns: [{ column_name, data_type, ... }] }

  // ============================================================================
  // User Impersonation API (Admin only)
  // ============================================================================

  // Start impersonating a user
  app.post('/api/admin/impersonate/:userId', requireAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const adminUser = (req as any).user;

      // Store original user in session
      if (!(req as any).session.originalUser) {
        (req as any).session.originalUser = adminUser;
      }

      // Fetch target user
      const pool = createPool();
      const result = await pool.query(`
        SELECT id, email, first_name, last_name, role, roles, status
        FROM users
        WHERE id = $1
      `, [userId]);

      // pool.end() removed - using shared pool

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }

      const targetUser = result.rows[0];

      // Update session to impersonate target user
      (req as any).session.userId = targetUser.id;
      (req as any).session.user = {
        id: targetUser.id,
        email: targetUser.email,
        first_name: targetUser.first_name,
        last_name: targetUser.last_name,
        role: targetUser.role,
        roles: targetUser.roles || [targetUser.role],
        status: targetUser.status,
        isImpersonating: true,
      };

      (req as any).session.save((err: any) => {
        if (err) {
          console.error('Session save error:', err);
          return res.status(500).json({ error: 'Failed to save session' });
        }

        res.json({
          success: true,
          message: `Now impersonating ${targetUser.email}`,
          user: (req as any).session.user,
        });
      });
    } catch (error: any) {
      console.error('Impersonation error:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Stop impersonating and return to admin
  app.post('/api/admin/stop-impersonate', isAuthenticated, async (req: any, res) => {
    try {
      const originalUser = (req as any).session.originalUser;

      if (!originalUser) {
        return res.status(400).json({ error: 'Not currently impersonating' });
      }

      // Restore original admin user
      (req as any).session.userId = originalUser.id;
      (req as any).session.user = originalUser;
      delete (req as any).session.originalUser;

      (req as any).session.save((err: any) => {
        if (err) {
          console.error('Session save error:', err);
          return res.status(500).json({ error: 'Failed to save session' });
        }

        res.json({
          success: true,
          message: 'Stopped impersonation',
          user: (req as any).session.user,
        });
      });
    } catch (error: any) {
      console.error('Stop impersonation error:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get list of users for impersonation
  app.get('/api/admin/users-list', requireAdmin, async (req: any, res) => {
    try {
      const pool = createPool();
      const result = await pool.query(`
        SELECT
          id,
          email,
          first_name,
          last_name,
          role,
          roles,
          status
        FROM users
        WHERE status = 'active'
        ORDER BY
          CASE role
            WHEN 'admin' THEN 1
            WHEN 'manager' THEN 2
            WHEN 'teacher' THEN 3
            WHEN 'consultant' THEN 4
            WHEN 'setter' THEN 5
            ELSE 6
          END,
          first_name,
          last_name
      `);

      // pool.end() removed - using shared pool

      res.json({
        success: true,
        data: result.rows,
      });
    } catch (error: any) {
      console.error('Failed to fetch users list:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // =================================================================
  // è–ªè³‡è¨ˆç®—å™¨ API
  // =================================================================

  // ç²å–æ‰€æœ‰å“¡å·¥è¨­å®š
  app.get('/api/salary/employees', async (req, res) => {
    try {
      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      const employees = await salaryCalculatorService.getAllEmployeeSettings();
      res.json({ success: true, data: employees });
    } catch (error: any) {
      console.error('Failed to fetch employee settings:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ç²å–å–®ä¸€å“¡å·¥è¨­å®š
  app.get('/api/salary/employees/:name', async (req, res) => {
    try {
      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      const employee = await salaryCalculatorService.getEmployeeSetting(req.params.name);

      if (!employee) {
        return res.status(404).json({ error: 'æ‰¾ä¸åˆ°è©²å“¡å·¥' });
      }

      res.json({ success: true, data: employee });
    } catch (error: any) {
      console.error('Failed to fetch employee setting:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // è¨ˆç®—è–ªè³‡ (æ ¸å¿ƒåŠŸèƒ½)
  app.post('/api/salary/calculate', async (req, res) => {
    try {
      const { employee_name, period_start, period_end, performance_score, manual_adjustments } = req.body;

      if (!employee_name || !period_start || !period_end) {
        return res.status(400).json({ error: 'ç¼ºå°‘å¿…è¦åƒæ•¸' });
      }

      // å°‡ performance_score åˆä½µåˆ° manual_adjustments
      const adjustments = {
        ...manual_adjustments,
        performance_score: performance_score,
      };

      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      const result = await salaryCalculatorService.calculateSalary(
        employee_name,
        period_start,
        period_end,
        adjustments
      );

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('Failed to calculate salary:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // å„²å­˜è–ªè³‡è¨ˆç®—çµæœ
  app.post('/api/salary/save', async (req, res) => {
    try {
      const calculation = req.body;

      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      const id = await salaryCalculatorService.saveSalaryCalculation(calculation);

      res.json({ success: true, data: { id } });
    } catch (error: any) {
      console.error('Failed to save salary calculation:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // åˆ—å‡ºè–ªè³‡è¨˜éŒ„
  app.get('/api/salary/records', async (req, res) => {
    try {
      const { employee_name, status, limit = '50' } = req.query;

      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      const records = await salaryCalculatorService.getSalaryRecords({
        employeeName: employee_name as string,
        status: status as string,
        limit: parseInt(limit as string, 10),
      });

      res.json({ success: true, data: records });
    } catch (error: any) {
      console.error('Failed to fetch salary records:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // æ›´æ–°è–ªè³‡è¨˜éŒ„ç‹€æ…‹
  app.put('/api/salary/records/:id/status', async (req, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      if (!['draft', 'confirmed', 'paid'].includes(status)) {
        return res.status(400).json({ error: 'ç„¡æ•ˆçš„ç‹€æ…‹å€¼' });
      }

      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      await salaryCalculatorService.updateSalaryRecordStatus(id, status);

      res.json({ success: true, message: 'ç‹€æ…‹å·²æ›´æ–°' });
    } catch (error: any) {
      console.error('Failed to update salary record status:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // åˆªé™¤è–ªè³‡è¨˜éŒ„
  app.delete('/api/salary/records/:id', async (req, res) => {
    try {
      const { id } = req.params;

      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      await salaryCalculatorService.deleteSalaryRecord(id);

      res.json({ success: true, message: 'è¨˜éŒ„å·²åˆªé™¤' });
    } catch (error: any) {
      console.error('Failed to delete salary record:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // æ›´æ–°å“¡å·¥è¨­å®š
  app.put('/api/salary/employees/:name', async (req, res) => {
    try {
      const { salaryCalculatorService } = await import('./services/salary-calculator-service');
      await salaryCalculatorService.updateEmployeeSetting(req.params.name, req.body);

      res.json({ success: true, message: 'æ›´æ–°æˆåŠŸ' });
    } catch (error: any) {
      console.error('Failed to update employee setting:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ç²å–å­¸å“¡ä»˜æ¬¾æ­·å²è¨˜éŒ„
  app.get('/api/salary/student-history/:studentName', async (req, res) => {
    try {
      const { studentName } = req.params;
      const decodedName = decodeURIComponent(studentName);

      const { queryDatabase } = await import('./services/pg-client');

      // å¾ income_expense_records æŸ¥è©¢è©²å­¸å“¡çš„æ‰€æœ‰ä»˜æ¬¾è¨˜éŒ„
      const result = await queryDatabase(`
        SELECT
          transaction_date as date,
          income_item as item,
          payment_method,
          teacher_name,
          closer,
          COALESCE(amount_twd, 0) as amount
        FROM income_expense_records
        WHERE customer_name = $1
          AND amount_twd > 0
        ORDER BY transaction_date DESC
      `, [decodedName]);

      // è¨ˆç®—ç¸½é‡‘é¡
      const totalAmount = result.rows.reduce((sum, row) => sum + parseFloat(row.amount || 0), 0);

      // åˆ¤æ–·æ˜¯å¦ç‚ºã€Œé«˜éšä¸€å°ä¸€ã€é …ç›®ï¼ˆç”¨æ–¼å…©éšæ®µæŠ½æˆè¨ˆç®—ï¼‰
      const isAdvancedTraining = (item: string): boolean => {
        const itemLower = (item || '').toLowerCase();
        // é«”é©—èª²ä¸ç®—é«˜éšä¸€å°ä¸€
        if (itemLower.includes('é«”é©—èª²') || itemLower.includes('é«”é©—')) {
          return false;
        }
        // åªæœ‰åŒ…å«ã€Œé«˜éšä¸€å°ä¸€ã€æ‰ç®—
        return itemLower.includes('é«˜éšä¸€å°ä¸€');
      };

      // è¨ˆç®—ã€Œé«˜éšä¸€å°ä¸€è¨“ç·´ã€ç´¯ç©ç¸½é¡ï¼ˆç”¨æ–¼å…©éšæ®µæŠ½æˆï¼‰
      const advancedTrainingAmount = result.rows
        .filter(row => isAdvancedTraining(row.item))
        .reduce((sum, row) => sum + parseFloat(row.amount || 0), 0);

      res.json({
        success: true,
        data: {
          total_amount: totalAmount,
          advanced_training_amount: advancedTrainingAmount,  // é«˜éšä¸€å°ä¸€ç´¯ç©ç¸½é¡
          records: result.rows.map(row => ({
            date: row.date,
            item: row.item,
            payment_method: row.payment_method,
            teacher_name: row.teacher_name || row.closer || '-',
            amount: parseFloat(row.amount),
            is_advanced_training: isAdvancedTraining(row.item),  // æ¨™è¨˜æ˜¯å¦ç‚ºé«˜éšä¸€å°ä¸€
          })),
        },
      });
    } catch (error: any) {
      console.error('Failed to fetch student history:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ============================================================================
  // AI Usage Dashboard API
  // ============================================================================

  // GET - AI ä½¿ç”¨é‡çµ±è¨ˆ
  app.get('/api/ai-usage/summary', isAuthenticated, async (req, res) => {
    try {
      const { start_date, end_date } = req.query;

      // é è¨­æœ¬æœˆ
      const today = new Date();
      const defaultStart = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`;
      const defaultEnd = today.toISOString().split('T')[0];

      const startDate = (start_date as string) || defaultStart;
      const endDate = (end_date as string) || defaultEnd;

      const aiUsageService = await import('./services/ai-usage-service');
      const summary = await aiUsageService.getAIUsageSummary(startDate, endDate);

      res.json({
        success: true,
        data: summary,
      });
    } catch (error: any) {
      console.error('æŸ¥è©¢ AI ä½¿ç”¨é‡å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - æœ€è¿‘ N å¤©çš„æ¯æ—¥ AI ä½¿ç”¨é‡
  app.get('/api/ai-usage/daily', isAuthenticated, async (req, res) => {
    try {
      const days = parseInt(req.query.days as string) || 30;

      const aiUsageService = await import('./services/ai-usage-service');
      const daily = await aiUsageService.getDailyUsage(days);

      res.json({
        success: true,
        data: daily,
      });
    } catch (error: any) {
      console.error('æŸ¥è©¢æ¯æ—¥ AI ä½¿ç”¨é‡å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - æœˆåº¦ AI ä½¿ç”¨é‡
  app.get('/api/ai-usage/monthly', isAuthenticated, async (req, res) => {
    try {
      const today = new Date();
      const year = parseInt(req.query.year as string) || today.getFullYear();
      const month = parseInt(req.query.month as string) || today.getMonth() + 1;

      const aiUsageService = await import('./services/ai-usage-service');
      const monthly = await aiUsageService.getMonthlyUsage(year, month);

      res.json({
        success: true,
        data: monthly,
      });
    } catch (error: any) {
      console.error('æŸ¥è©¢æœˆåº¦ AI ä½¿ç”¨é‡å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - AI ä½¿ç”¨è©³ç´°è¨˜éŒ„ï¼ˆæ¯ç­†å‘¼å«ï¼‰
  app.get('/api/ai-usage/records', isAuthenticated, async (req, res) => {
    try {
      const { start_date, end_date, page, page_size, source } = req.query;

      // é è¨­æœ¬æœˆ
      const today = new Date();
      const defaultStart = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`;
      const defaultEnd = today.toISOString().split('T')[0];

      const startDate = (start_date as string) || defaultStart;
      const endDate = (end_date as string) || defaultEnd;
      const pageNum = parseInt(page as string) || 1;
      const pageSizeNum = parseInt(page_size as string) || 50;
      const sourceFilter = source as string | undefined;

      const aiUsageService = await import('./services/ai-usage-service');
      const records = await aiUsageService.getAIUsageRecords(
        startDate,
        endDate,
        pageNum,
        pageSizeNum,
        sourceFilter
      );

      res.json({
        success: true,
        data: records,
      });
    } catch (error: any) {
      console.error('æŸ¥è©¢ AI ä½¿ç”¨è¨˜éŒ„å¤±æ•—:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================================================
  // Trello åŒæ­¥ API (å­¸å“¡èª²ç¨‹é€²åº¦è¿½è¹¤)
  // ============================================================================

  // POST - æ‰‹å‹•è§¸ç™¼ Trello åŒæ­¥
  app.post('/api/trello/sync', isAuthenticated, async (req, res) => {
    try {
      console.log('ğŸ”„ æ‰‹å‹•è§¸ç™¼ Trello åŒæ­¥...');
      const trelloSyncService = await import('./services/trello-sync-service');
      const result = await trelloSyncService.syncAllBoards();

      res.json({
        success: result.success,
        message: `åŒæ­¥å®Œæˆï¼šè™•ç† ${result.boardsProcessed} å€‹çœ‹æ¿ï¼Œ${result.cardsCompleted} å¼µå¡ç‰‡å®Œæˆ`,
        data: result,
      });
    } catch (error: any) {
      console.error('Trello åŒæ­¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾— Trello åŒæ­¥ç‹€æ…‹
  app.get('/api/trello/status', isAuthenticated, async (req, res) => {
    try {
      const trelloSyncService = await import('./services/trello-sync-service');
      const status = await trelloSyncService.getSyncStatus();

      res.json({
        success: true,
        data: status,
      });
    } catch (error: any) {
      console.error('å–å¾— Trello åŒæ­¥ç‹€æ…‹å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾—æ‰€æœ‰å­¸å“¡çœ‹æ¿
  app.get('/api/trello/boards', isAuthenticated, async (req, res) => {
    try {
      const trelloSyncService = await import('./services/trello-sync-service');
      const boards = await trelloSyncService.getStudentBoards();

      res.json({
        success: true,
        data: boards,
        total: boards.length,
      });
    } catch (error: any) {
      console.error('å–å¾— Trello çœ‹æ¿å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾—å­¸å“¡èª²ç¨‹é€²åº¦åˆ—è¡¨
  app.get('/api/trello/progress', isAuthenticated, async (req, res) => {
    try {
      const { teacherId, limit, offset } = req.query;
      const trelloSyncService = await import('./services/trello-sync-service');

      const progress = await trelloSyncService.getStudentProgressList({
        teacherId: teacherId as string | undefined,
        limit: limit ? parseInt(limit as string) : 50,
        offset: offset ? parseInt(offset as string) : 0,
      });

      res.json({
        success: true,
        data: progress,
      });
    } catch (error: any) {
      console.error('å–å¾—å­¸å“¡é€²åº¦å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // POST - å•Ÿå‹•å®šæ™‚åŒæ­¥
  app.post('/api/trello/start-periodic-sync', isAuthenticated, async (req, res) => {
    try {
      const { intervalMinutes } = req.body;
      const trelloSyncService = await import('./services/trello-sync-service');

      const interval = (intervalMinutes || 60) * 60 * 1000; // é è¨­ 1 å°æ™‚
      trelloSyncService.startPeriodicSync(interval);

      res.json({
        success: true,
        message: `å®šæ™‚åŒæ­¥å·²å•Ÿå‹•ï¼Œé–“éš” ${intervalMinutes || 60} åˆ†é˜`,
      });
    } catch (error: any) {
      console.error('å•Ÿå‹•å®šæ™‚åŒæ­¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // POST - åœæ­¢å®šæ™‚åŒæ­¥
  app.post('/api/trello/stop-periodic-sync', isAuthenticated, async (req, res) => {
    try {
      const trelloSyncService = await import('./services/trello-sync-service');
      trelloSyncService.stopPeriodicSync();

      res.json({
        success: true,
        message: 'å®šæ™‚åŒæ­¥å·²åœæ­¢',
      });
    } catch (error: any) {
      console.error('åœæ­¢å®šæ™‚åŒæ­¥å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾—å­¸å“¡çš„å¡ç‰‡å®Œæˆæ˜ç´°
  app.get('/api/trello/progress/:progressId/cards', isAuthenticated, async (req, res) => {
    try {
      const { progressId } = req.params;
      const trelloSyncService = await import('./services/trello-sync-service');

      const cards = await trelloSyncService.getStudentCardCompletions(progressId);

      res.json({
        success: true,
        data: cards,
      });
    } catch (error: any) {
      console.error('å–å¾—å¡ç‰‡æ˜ç´°å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾—è€å¸«é€±é€²åº¦çµ±è¨ˆ
  app.get('/api/trello/teacher-weekly-progress', isAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      const trelloSyncService = await import('./services/trello-sync-service');

      const weeklyProgress = await trelloSyncService.getTeacherWeeklyProgress({
        startDate: startDate as string | undefined,
        endDate: endDate as string | undefined,
      });

      res.json({
        success: true,
        data: weeklyProgress,
      });
    } catch (error: any) {
      console.error('å–å¾—è€å¸«é€±é€²åº¦å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // GET - å–å¾—è€å¸«é€²åº¦ç¸½è¦½
  app.get('/api/trello/teacher-summary', isAuthenticated, async (req, res) => {
    try {
      const trelloSyncService = await import('./services/trello-sync-service');

      const summary = await trelloSyncService.getTeacherProgressSummary();

      res.json({
        success: true,
        data: summary,
      });
    } catch (error: any) {
      console.error('å–å¾—è€å¸«é€²åº¦ç¸½è¦½å¤±æ•—:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  return httpServer;
}
