import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./services/legacy/storage";
import { googleSheetsService } from "./services/legacy/google-sheets";
import { autoAnalysisService } from "./services/deprecated/auto-analysis";
import { totalReportService } from "./services/reporting/total-report-service";
import { introspectService } from "./services/reporting/introspect-service";
import { devSeedService } from "./services/deprecated/dev-seed-service";
import { reportMetricConfigService } from "./services/reporting/report-metric-config-service";
import { formulaEngine } from "./services/reporting/formula-engine";
import { getAvailableFormulaVariables } from "../configs/report-metric-defaults";
import { getSupabaseClient, isSupabaseAvailable } from "./services/supabase-client";
import { createPool, insertAndReturn, queryDatabase } from "./services/pg-client";
import {
  insertSpreadsheetSchema,
  insertWorksheetSchema,
  insertRoleSchema,
  insertCustomDashboardSchema,
  insertCalculationRuleSchema,
  insertDataSourceMappingSchema,
  insertDataSourceRelationshipSchema,
  insertPurchaseRecordSchema,
  insertConsultationRecordSchema,
  insertMultiSourceAnalyticSchema,
  updateDataSourceRelationshipSchema,
  updatePurchaseRecordSchema,
  updateConsultationRecordSchema,
  updateMultiSourceAnalyticSchema,
  enhancedInsertPurchaseRecordSchema,
  enhancedInsertConsultationRecordSchema,
  insertWorksheetAnalysisSchema,
  insertAutoGeneratedReportSchema,
  type WSMessage
} from "@shared/schema";
import { setupAuth, isAuthenticated, requireAdmin, requireActiveUser } from "./auth";
import { z } from "zod";
import * as teachingQualityGPT from "./services/teaching-quality-gpt-service";
import { registerTeachingQualityRoutes } from "./routes-teaching-quality-new";
import { registerEmployeeManagementRoutes } from "./routes-employee-management";
import { registerAuthRoutes } from "./routes-auth";
import { registerKnowItAllRoutes } from "./routes-know-it-all";
import { registerPermissionRoutes, requireModulePermission } from "./routes-permissions";
import { buildPermissionFilter } from "./services/permission-filter-service";

export async function registerRoutes(app: Express): Promise<Server> {
  // Health check endpoint for Zeabur
  app.get('/health', (req, res) => {
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: 'replit'
    });
  });

  // ======================
  // 使用者管理 API
  // ======================

  // 取得所有使用者
  app.get('/api/users', isAuthenticated, async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, email, first_name, last_name, role, department, status, created_at, last_login_at, updated_at
         FROM users
         ORDER BY created_at DESC`
      );

      // 處理多重角色（如果有 roles 欄位）
      const users = result.rows.map((user: any) => ({
        ...user,
        roles: user.role ? [user.role] : [], // 暫時用 role 作為 roles 陣列
      }));

      res.json({ success: true, users });
    } catch (error: any) {
      console.error('取得使用者列表失敗:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // 新增使用者
  app.post('/api/users', isAuthenticated, async (req, res) => {
    try {
      const { email, first_name, last_name, role, roles, department, status } = req.body;

      // 驗證必填欄位
      if (!email || !first_name) {
        return res.status(400).json({
          success: false,
          message: 'Email 和姓名為必填欄位',
        });
      }

      // 檢查 email 是否已存在
      const existingUser = await queryDatabase(
        `SELECT id FROM users WHERE email = $1`,
        [email]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: '此 Email 已被使用',
        });
      }

      // 新增使用者
      const result = await queryDatabase(
        `INSERT INTO users (email, first_name, last_name, role, department, status, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
         RETURNING id, email, first_name, last_name, role, department, status, created_at`,
        [email, first_name, last_name || '', role || 'user', department || '', status || 'active']
      );

      res.json({
        success: true,
        user: result.rows[0],
        message: '使用者新增成功',
      });
    } catch (error: any) {
      console.error('新增使用者失敗:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // 更新使用者
  app.put('/api/users/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { first_name, last_name, role, roles, department, status } = req.body;

      const result = await queryDatabase(
        `UPDATE users
         SET first_name = $1, last_name = $2, role = $3, department = $4, status = $5, updated_at = NOW()
         WHERE id = $6
         RETURNING id, email, first_name, last_name, role, department, status, created_at, updated_at`,
        [first_name, last_name || '', role || 'user', department || '', status || 'active', id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: '使用者不存在',
        });
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: '使用者更新成功',
      });
    } catch (error: any) {
      console.error('更新使用者失敗:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // 刪除使用者
  app.delete('/api/users/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(
        `DELETE FROM users WHERE id = $1 RETURNING id`,
        [id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: '使用者不存在',
        });
      }

      res.json({
        success: true,
        message: '使用者刪除成功',
      });
    } catch (error: any) {
      console.error('刪除使用者失敗:', error);
      res.status(500).json({ success: false, message: error.message });
    }
  });

  // Setup authentication first
  await setupAuth(app);
  
  const httpServer = createServer(app);
  
  app.get('/api/status', async (_req, res) => {
    try {
      const [spreadsheets, worksheets] = await Promise.all([
        storage.listSpreadsheets(),
        storage.getAllWorksheets(),
      ]);

      const worksheetsBySheetId = worksheets.reduce<Record<string, any[]>>((acc, worksheet) => {
        const list = acc[worksheet.spreadsheetId] || [];
        list.push(worksheet);
        acc[worksheet.spreadsheetId] = list;
        return acc;
      }, {});

      const dataSources = spreadsheets.map((sheet) => {
        const sheetWorksheets = worksheetsBySheetId[sheet.spreadsheetId] || [];
        const isActive = sheetWorksheets.some((worksheet) => worksheet.isEnabled);

        return {
          id: sheet.id,
          name: sheet.name,
          type: 'spreadsheet',
          isActive,
          lastSyncAt: toIsoString(sheet.lastSyncAt ?? sheet.createdAt ?? null) ?? new Date().toISOString(),
        };
      });

      const totalRowCount = spreadsheets.reduce(
        (total, sheet) => total + (sheet.rowCount ?? 0),
        0,
      );

      res.json({
        success: true,
        data: {
          status: 'healthy',
          lastUpdated: new Date().toISOString(),
          dataSourcesCount: dataSources.length,
          stats: {
            spreadsheetCount: spreadsheets.length,
            worksheetCount: worksheets.length,
            totalRowCount,
          },
          dataSources,
        },
      });
    } catch (error) {
      console.error('Error fetching system status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch system status',
      });
    }
  });

  // WebSocket server disabled for security - needs proper session parsing
  // TODO: Implement proper WebSocket authentication with session parsing
  const wss = null;

  // WebSocket functionality temporarily disabled for security
  const adminClients = new Map();

  // Broadcast disabled - WebSocket functionality needs security improvements
  function broadcast(message: WSMessage) {
    // TODO: Re-enable when WebSocket auth is properly implemented
    console.log('Broadcast message:', message.type, 
      'status' in message ? message.status : undefined,
      'message' in message ? message.message : undefined
    );
  }

  // ===== Dashboard API Routes =====
  
  // Dashboard Templates (admin only)
  app.get('/api/dashboards/templates', async (req, res) => {
    try {
      const templates = await storage.listActiveDashboardTemplates();
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error('Error fetching dashboard templates:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/templates/:id', async (req, res) => {
    try {
      const template = await storage.getDashboardTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }
      res.json({ success: true, data: template });
    } catch (error) {
      console.error('Error fetching dashboard template:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/templates/type/:type', async (req, res) => {
    try {
      const template = await storage.getDashboardTemplateByType(req.params.type);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }
      res.json({ success: true, data: template });
    } catch (error) {
      console.error('Error fetching dashboard template by type:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Custom Dashboards (admin only)
  app.get('/api/dashboards', async (req, res) => {
    try {
      const userId = req.query.userId as string;
      const dashboards = await storage.listCustomDashboards(userId);
      res.json({ success: true, data: dashboards });
    } catch (error) {
      console.error('Error fetching custom dashboards:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/dashboards/:id', async (req, res) => {
    try {
      const dashboard = await storage.getCustomDashboard(req.params.id);
      if (!dashboard) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Error fetching dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/dashboards', async (req, res) => {
    console.log('Dashboard creation request received:', {
      body: req.body,
      user: req.user ? { sub: (req.user as any).claims?.sub } : 'no user'
    });

    try {
      const user = req.user as any;
      if (!user || !user.claims || !user.claims.sub) {
        console.error('No authenticated user found for dashboard creation');
        return res.status(401).json({ success: false, error: 'User not authenticated' });
      }

      const userId = user.claims.sub;
      console.log('Creating dashboard for user:', userId);

      // Parse request body but override userId with authenticated user
      const { userId: _, ...requestData } = req.body;
      console.log('Request data before validation:', requestData);

      const parsedData = insertCustomDashboardSchema.parse({
        ...requestData,
        userId: userId
      });
      console.log('Parsed data after validation:', parsedData);

      const dashboard = await storage.createCustomDashboard(parsedData);
      console.log('Dashboard created successfully:', dashboard.id);
      res.status(201).json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Dashboard creation error:', error);
      if (error instanceof z.ZodError) {
        console.error('Validation errors:', error.errors);
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/dashboards/:id', async (req, res) => {
    try {
      const updates = req.body;
      const updatedDashboard = await storage.updateCustomDashboard(req.params.id, updates);
      if (!updatedDashboard) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.json({ success: true, data: updatedDashboard });
    } catch (error) {
      console.error('Error updating dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/dashboards/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteCustomDashboard(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Dashboard not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting dashboard:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Create dashboard from template
  app.post('/api/dashboards/from-template', async (req, res) => {
    try {
      const user = req.user as any;
      if (!user || !user.claims || !user.claims.sub) {
        return res.status(401).json({ success: false, error: 'User not authenticated' });
      }
      
      const { templateId } = req.body;
      if (!templateId) {
        return res.status(400).json({ success: false, error: 'Template ID is required' });
      }

      // 獲取模板
      const template = await storage.getDashboardTemplate(templateId);
      if (!template) {
        return res.status(404).json({ success: false, error: 'Template not found' });
      }

      // 從模板創建儀表板
      const dashboardData = {
        templateId: template.id,
        userId: user.claims.sub,
        name: `${template.displayName} - ${new Date().toLocaleDateString('zh-TW')}`,
        description: `基於${template.displayName}模板創建的儀表板`,
        config: {
          ...template.config,
          // 保持模板的配置但標記為用戶自定義
          isFromTemplate: true,
          originalTemplateId: template.id
        },
        isPublic: false
      };

      const dashboard = await storage.createCustomDashboard(dashboardData);
      res.status(201).json({ success: true, data: dashboard });
    } catch (error) {
      console.error('Error creating dashboard from template:', error);
      res.status(500).json({ success: false, error: 'Failed to create dashboard from template' });
    }
  });

  // Calculation Rules (admin only)
  app.get('/api/calculations', async (req, res) => {
    try {
      const category = req.query.category as string;
      const rules = await storage.listCalculationRules(category);
      res.json({ success: true, data: rules });
    } catch (error) {
      console.error('Error fetching calculation rules:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/calculations/active', async (req, res) => {
    try {
      const rules = await storage.listActiveCalculationRules();
      res.json({ success: true, data: rules });
    } catch (error) {
      console.error('Error fetching active calculation rules:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/calculations/:id', async (req, res) => {
    try {
      const rule = await storage.getCalculationRule(req.params.id);
      if (!rule) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.json({ success: true, data: rule });
    } catch (error) {
      console.error('Error fetching calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/calculations', async (req, res) => {
    try {
      const parsedData = insertCalculationRuleSchema.parse(req.body);
      const rule = await storage.createCalculationRule(parsedData);
      res.status(201).json({ success: true, data: rule });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/calculations/:id', async (req, res) => {
    try {
      const updates = req.body;
      const rule = await storage.updateCalculationRule(req.params.id, updates);
      if (!rule) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.json({ success: true, data: rule });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error updating calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/calculations/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteCalculationRule(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Calculation rule not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting calculation rule:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Data Source Mappings (admin only)
  app.get('/api/datasources', async (req, res) => {
    try {
      const mappings = await storage.listActiveDataSourceMappings();
      res.json({ success: true, data: mappings });
    } catch (error) {
      console.error('Error fetching data source mappings:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/datasources/:id', async (req, res) => {
    try {
      const mapping = await storage.getDataSourceMapping(req.params.id);
      if (!mapping) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.json({ success: true, data: mapping });
    } catch (error) {
      console.error('Error fetching data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/datasources', async (req, res) => {
    try {
      const parsedData = insertDataSourceMappingSchema.parse(req.body);
      const mapping = await storage.createDataSourceMapping(parsedData);
      res.status(201).json({ success: true, data: mapping });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error creating data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/datasources/:id', async (req, res) => {
    try {
      const parsedData = insertDataSourceMappingSchema.partial().parse(req.body);
      const mapping = await storage.updateDataSourceMapping(req.params.id, parsedData);
      if (!mapping) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.json({ success: true, data: mapping });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Validation failed', details: error.errors });
      }
      console.error('Error updating data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/datasources/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteDataSourceMapping(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Data source mapping not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting data source mapping:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Core Metrics API - 核心指標系統 (admin only)
  app.get('/api/analytics/core-metrics', async (req, res) => {
    try {
      // Get data from experience course records worksheet
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Calculate core business metrics
      const coreMetrics = {
        // 體驗中學生數量 (Total Experience Students)
        totalExperienceStudents: experienceData.length,
        
        // 上課中學生數量 (Students Currently in Class)
        activeStudents: experienceData.filter(row => 
          row.data['是否已確認'] === '是'
        ).length,
        
        // 未確認學生數量 (Unconfirmed Students)
        unconfirmedStudents: experienceData.filter(row => 
          row.data['是否已確認'] !== '是' && row.data['是否已確認'] !== ''
        ).length,
        
        // 待聯繫學生數量 (Students Pending Contact)
        pendingContactStudents: experienceData.filter(row => 
          row.data['未聯繫原因'] && row.data['未聯繫原因'] !== ''
        ).length,
        
        // 按授課老師分組統計
        teacherStats: experienceData.reduce((acc, row) => {
          const teacher = row.data['授課老師'] || '未分配';
          if (!acc[teacher]) {
            acc[teacher] = { total: 0, confirmed: 0 };
          }
          acc[teacher].total++;
          if (row.data['是否已確認'] === '是') {
            acc[teacher].confirmed++;
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number }>),
        
        // 月度趨勢分析
        monthlyTrend: experienceData.reduce((acc, row) => {
          const dateStr = row.data['上課日期'];
          if (dateStr) {
            try {
              const date = new Date(dateStr);
              const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
              if (!acc[monthKey]) {
                acc[monthKey] = { total: 0, confirmed: 0 };
              }
              acc[monthKey].total++;
              if (row.data['是否已確認'] === '是') {
                acc[monthKey].confirmed++;
              }
            } catch (error) {
              // Skip invalid dates
            }
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number }>),
        
        // 確認率統計
        confirmationRate: experienceData.length > 0 
          ? ((experienceData.filter(row => row.data['是否已確認'] === '是').length / experienceData.length) * 100).toFixed(1)
          : '0.0',
        
        // 最近更新時間
        lastUpdated: new Date(),
        
        // 數據源信息
        dataSource: {
          worksheetId: '110563615',
          worksheetName: '體驗課上課記錄表',
          totalRows: experienceData.length,
          lastSyncTime: new Date()
        }
      };

      res.json({ success: true, data: coreMetrics });
    } catch (error) {
      console.error('Error calculating core metrics:', error);
      res.status(500).json({ success: false, error: 'Failed to calculate core metrics' });
    }
  });

  // Executive Dashboard Summary - 管理層儀表板總覽 (admin only)
  app.get('/api/analytics/executive-summary', async (req, res) => {
    try {
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Calculate time-based comparisons
      const now = new Date();
      const last30Days = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const last7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      
      const recentData = experienceData.filter(row => {
        const dateStr = row.data['上課日期'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= last30Days;
        } catch {
          return false;
        }
      });
      
      const weeklyData = experienceData.filter(row => {
        const dateStr = row.data['上課日期'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= last7Days;
        } catch {
          return false;
        }
      });

      // Core metrics for executive summary
      const totalStudents = experienceData.length;
      const confirmedStudents = experienceData.filter(row => row.data['是否已確認'] === '是').length;
      const recentConfirmed = recentData.filter(row => row.data['是否已確認'] === '是').length;
      const weeklyConfirmed = weeklyData.filter(row => row.data['是否已確認'] === '是').length;
      
      // Calculate teacher performance rankings
      const teacherPerformance = Object.entries(
        experienceData.reduce((acc, row) => {
          const teacher = row.data['授課老師'] || '未分配';
          if (!acc[teacher]) {
            acc[teacher] = { total: 0, confirmed: 0, recent: 0, recentConfirmed: 0 };
          }
          acc[teacher].total++;
          if (row.data['是否已確認'] === '是') {
            acc[teacher].confirmed++;
          }
          
          // Check if this is recent data
          const dateStr = row.data['上課日期'];
          if (dateStr) {
            try {
              const rowDate = new Date(dateStr);
              if (rowDate >= last30Days) {
                acc[teacher].recent++;
                if (row.data['是否已確認'] === '是') {
                  acc[teacher].recentConfirmed++;
                }
              }
            } catch {
              // Skip invalid dates
            }
          }
          return acc;
        }, {} as Record<string, { total: number; confirmed: number; recent: number; recentConfirmed: number }>)
      ).map(([teacher, stats]) => ({
        teacher,
        totalStudents: stats.total,
        totalConfirmed: stats.confirmed,
        recentStudents: stats.recent,
        recentConfirmed: stats.recentConfirmed,
        overallRate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0.0',
        recentRate: stats.recent > 0 ? (stats.recentConfirmed / stats.recent * 100).toFixed(1) : '0.0'
      }));

      const executiveSummary = {
        // 核心業務指標 (Core Business Metrics)
        coreMetrics: {
          totalExperienceStudents: totalStudents,
          totalConfirmedStudents: confirmedStudents,
          overallConfirmationRate: totalStudents > 0 ? (confirmedStudents / totalStudents * 100).toFixed(1) : '0.0',
          
          // 成交學生數量 (預留待購買數據接入)
          totalPurchasingStudents: 0, // Will be calculated when purchase data is available
          
          // 總成交金額 (預留待購買數據接入)  
          totalRevenue: 0, // Will be calculated when purchase data is available
          
          // 近期表現 (Recent Performance)
          recentPerformance: {
            last30Days: {
              newStudents: recentData.length,
              confirmedStudents: recentConfirmed,
              confirmationRate: recentData.length > 0 ? (recentConfirmed / recentData.length * 100).toFixed(1) : '0.0'
            },
            last7Days: {
              newStudents: weeklyData.length,
              confirmedStudents: weeklyConfirmed,
              confirmationRate: weeklyData.length > 0 ? (weeklyConfirmed / weeklyData.length * 100).toFixed(1) : '0.0'
            }
          }
        },
        
        // 教師績效排行 (Teacher Performance Rankings)
        teacherRankings: {
          topPerformers: teacherPerformance
            .filter(t => t.totalStudents >= 3) // Only include teachers with significant data
            .sort((a, b) => parseFloat(b.overallRate) - parseFloat(a.overallRate))
            .slice(0, 5),
          
          recentTopPerformers: teacherPerformance
            .filter(t => t.recentStudents >= 2) // Recent activity threshold
            .sort((a, b) => parseFloat(b.recentRate) - parseFloat(a.recentRate))
            .slice(0, 5)
        },
        
        // 業務洞察 (Business Insights)
        businessInsights: {
          totalTeachers: teacherPerformance.length,
          activeTeachers: teacherPerformance.filter(t => t.recentStudents > 0).length,
          studentsNeedingAttention: experienceData.filter(row => 
            row.data['是否已確認'] !== '是' && 
            (!row.data['未聯繫原因'] || row.data['未聯繫原因'] === '')
          ).length,
          
          // 增長趨勢指標
          growthIndicators: {
            weeklyGrowth: weeklyData.length,
            monthlyGrowth: recentData.length,
            confirmationTrend: {
              improving: false, // Will be calculated with historical comparison
              stable: true,
              declining: false
            }
          }
        },
        
        // 系統狀態
        systemStatus: {
          dataFreshness: 'Live', // Real-time from Google Sheets
          lastSyncTime: new Date(),
          totalDataPoints: totalStudents,
          dataQuality: {
            completeName: experienceData.filter(row => row.data['姓名'] && row.data['姓名'] !== '').length,
            completeEmail: experienceData.filter(row => row.data['email'] && row.data['email'] !== '').length,
            completeDate: experienceData.filter(row => row.data['上課日期'] && row.data['上課日期'] !== '').length,
            dataIntegrityScore: ((
              experienceData.filter(row => row.data['姓名'] && row.data['姓名'] !== '').length +
              experienceData.filter(row => row.data['email'] && row.data['email'] !== '').length +
              experienceData.filter(row => row.data['上課日期'] && row.data['上課日期'] !== '').length
            ) / (totalStudents * 3) * 100).toFixed(1)
          }
        },
        
        lastUpdated: new Date()
      };

      res.json({ success: true, data: executiveSummary });
    } catch (error) {
      console.error('Error generating executive summary:', error);
      res.status(500).json({ success: false, error: 'Failed to generate executive summary' });
    }
  });

  // Enhanced Analytics for specific business needs
  app.get('/api/analytics/business-insights', async (req, res) => {
    try {
      const { timeRange = '30' } = req.query;
      const days = parseInt(timeRange as string) || 30;
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      
      const experienceData = await storage.getWorksheetData('110563615');
      
      // Filter data by time range
      const recentData = experienceData.filter(row => {
        const dateStr = row.data['上課日期'];
        if (!dateStr) return false;
        try {
          const rowDate = new Date(dateStr);
          return rowDate >= cutoffDate;
        } catch {
          return false;
        }
      });

      const insights = {
        timeRange: `Last ${days} days`,
        period: {
          from: cutoffDate.toISOString().split('T')[0],
          to: new Date().toISOString().split('T')[0]
        },
        
        // 核心指標 (Core Metrics)
        metrics: {
          newExperienceStudents: recentData.length,
          confirmedStudents: recentData.filter(row => row.data['是否已確認'] === '是').length,
          conversionRate: recentData.length > 0 
            ? ((recentData.filter(row => row.data['是否已確認'] === '是').length / recentData.length) * 100).toFixed(1)
            : '0.0'
        },
        
        // 授課老師績效 (Teacher Performance)
        teacherPerformance: Object.entries(
          recentData.reduce((acc, row) => {
            const teacher = row.data['授課老師'] || '未分配';
            if (!acc[teacher]) {
              acc[teacher] = { students: 0, confirmed: 0, conversionRate: 0 };
            }
            acc[teacher].students++;
            if (row.data['是否已確認'] === '是') {
              acc[teacher].confirmed++;
            }
            acc[teacher].conversionRate = acc[teacher].students > 0 
              ? (acc[teacher].confirmed / acc[teacher].students * 100) 
              : 0;
            return acc;
          }, {} as Record<string, { students: number; confirmed: number; conversionRate: number }>)
        ).map(([teacher, stats]) => ({
          teacher,
          ...stats,
          conversionRate: parseFloat(stats.conversionRate.toFixed(1))
        })).sort((a, b) => b.conversionRate - a.conversionRate),
        
        // 需要關注的學生 (Students Requiring Attention)
        attentionRequired: {
          uncontactedStudents: recentData.filter(row => 
            row.data['是否已確認'] !== '是' && 
            (!row.data['未聯繫原因'] || row.data['未聯繫原因'] === '')
          ).length,
          
          studentsWithContactIssues: recentData.filter(row => 
            row.data['未聯繫原因'] && row.data['未聯繫原因'] !== ''
          ).length
        },
        
        lastUpdated: new Date()
      };

      res.json({ success: true, data: insights });
    } catch (error) {
      console.error('Error generating business insights:', error);
      res.status(500).json({ success: false, error: 'Failed to generate business insights' });
    }
  });

  // Dashboard Analytics with Real Data (admin only)
  app.get('/api/analytics/dashboard/:templateType', async (req, res) => {
    try {
      const { templateType } = req.params;
      const template = await storage.getDashboardTemplateByType(templateType);
      
      if (!template) {
        return res.status(404).json({ success: false, error: 'Dashboard template not found' });
      }

      // Get real metrics data based on template type
      let metricsData: {
        templateId: string;
        templateName: string;
        metrics: Array<{
          id: string;
          name: string;
          value: string | number;
          chartType: string;
          position: { x: number; y: number; w: number; h: number };
        }>;
        lastUpdated: Date;
      } = {
        templateId: template.id,
        templateName: template.name,
        metrics: [],
        lastUpdated: new Date()
      };

      switch (templateType) {
        case 'experience_customers':
          // Get comprehensive metrics from core metrics system
          const experienceData = await storage.getWorksheetData('110563615');
          const totalStudents = experienceData.length;
          const confirmedStudents = experienceData.filter(row => row.data['是否已確認'] === '是');
          const unconfirmedStudents = experienceData.filter(row => 
            row.data['是否已確認'] !== '是' && row.data['是否已確認'] !== ''
          );
          
          // Calculate teacher performance for charts
          const teacherStats = experienceData.reduce((acc, row) => {
            const teacher = row.data['授課老師'] || '未分配';
            if (!acc[teacher]) {
              acc[teacher] = { total: 0, confirmed: 0 };
            }
            acc[teacher].total++;
            if (row.data['是否已確認'] === '是') {
              acc[teacher].confirmed++;
            }
            return acc;
          }, {} as Record<string, { total: number; confirmed: number }>);
          
          // Calculate monthly trend for the trend chart
          const monthlyData = experienceData.reduce((acc, row) => {
            const dateStr = row.data['上課日期'];
            if (dateStr) {
              try {
                const date = new Date(dateStr);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!acc[monthKey]) {
                  acc[monthKey] = { total: 0, confirmed: 0 };
                }
                acc[monthKey].total++;
                if (row.data['是否已確認'] === '是') {
                  acc[monthKey].confirmed++;
                }
              } catch (error) {
                // Skip invalid dates
              }
            }
            return acc;
          }, {} as Record<string, { total: number; confirmed: number }>);
          
          metricsData.metrics = template.config.metrics.map(metric => {
            let value: string | number = 0;
            let chartData: any = undefined;
            
            switch (metric.id) {
              case 'total_students':
                value = totalStudents;
                break;
              case 'active_students':
                value = confirmedStudents.length;
                break;
              case 'conversion_rate':
                value = totalStudents > 0 
                  ? ((confirmedStudents.length / totalStudents) * 100).toFixed(1) + '%'
                  : '0.0%';
                break;
              case 'monthly_trend':
                // Provide trend data for chart
                value = Object.keys(monthlyData).length;
                chartData = Object.entries(monthlyData)
                  .sort(([a], [b]) => a.localeCompare(b))
                  .map(([month, stats]) => ({
                    month,
                    total: stats.total,
                    confirmed: stats.confirmed,
                    rate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0'
                  }));
                break;
              case 'teacher_performance':
                // Provide teacher performance data for chart
                value = Object.keys(teacherStats).length;
                chartData = Object.entries(teacherStats)
                  .map(([teacher, stats]) => ({
                    teacher,
                    total: stats.total,
                    confirmed: stats.confirmed,
                    rate: stats.total > 0 ? (stats.confirmed / stats.total * 100).toFixed(1) : '0'
                  }))
                  .sort((a, b) => parseFloat(b.rate) - parseFloat(a.rate));
                break;
              default:
                value = Math.floor(Math.random() * 100);
            }
            
            return {
              id: metric.id,
              name: metric.name,
              value,
              chartType: metric.chartType,
              position: metric.position,
              chartData
            };
          });
          break;
          
        case 'sales_performance':
          // Mock sales data for now - will connect to purchase records later
          metricsData.metrics = template.config.metrics.map(metric => ({
            id: metric.id,
            name: metric.name,
            value: metric.id === 'total_revenue' ? '¥' + (Math.floor(Math.random() * 100000) + 50000).toLocaleString() :
                   metric.id === 'total_purchases' ? Math.floor(Math.random() * 200) + 50 :
                   metric.id === 'avg_order_value' ? '¥' + (Math.floor(Math.random() * 5000) + 1000).toLocaleString() :
                   Math.floor(Math.random() * 100),
            chartType: metric.chartType,
            position: metric.position
          }));
          break;
          
        default:
          // Generic mock data for other templates
          metricsData.metrics = template.config.metrics.map(metric => ({
            id: metric.id,
            name: metric.name,
            value: Math.floor(Math.random() * 1000),
            chartType: metric.chartType,
            position: metric.position
          }));
      }

      res.json({ success: true, data: metricsData });
    } catch (error) {
      console.error('Error generating dashboard analytics:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Authentication API routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      res.json({ success: true, data: user });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ success: false, error: "Failed to fetch user" });
    }
  });

  // User management API routes (Admin only)
  app.get('/api/users', requireAdmin, async (req, res) => {
    try {
      const users = await storage.listUsers();
      res.json({ success: true, data: users });
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ success: false, error: "Failed to fetch users" });
    }
  });

  app.patch('/api/users/:id/role', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { role, department } = req.body;
      
      if (!role) {
        return res.status(400).json({ success: false, error: "Role is required" });
      }
      
      // Validate role exists
      const validRoles = ['admin', 'manager', 'staff', 'user'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }
      
      const updatedUser = await storage.updateUserRole(id, role, department);
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ success: false, error: "Failed to update user role" });
    }
  });

  app.patch('/api/users/:id/status', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, role } = req.body;
      
      if (!status) {
        return res.status(400).json({ success: false, error: "Status is required" });
      }
      
      // Validate status exists
      const validStatuses = ['active', 'inactive', 'pending_approval', 'suspended'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status" });
      }
      
      const updatedUser = await storage.updateUserStatus(id, status, role);
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ success: false, error: "Failed to update user status" });
    }
  });

  app.patch('/api/users/:id/profile', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { firstName, lastName, email, department } = req.body;
      
      // Basic validation
      if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }
      
      const validDepartments = ['教練組', '客服組', '財務組', '管理層'];
      if (department && !validDepartments.includes(department)) {
        return res.status(400).json({ success: false, error: "Invalid department" });
      }
      
      const updatedUser = await storage.updateUserProfile(id, { firstName, lastName, email, department });
      if (!updatedUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user profile:", error);
      res.status(500).json({ success: false, error: "Failed to update user profile" });
    }
  });

  // Unified user update endpoint (Admin only)
  app.patch('/api/users/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { firstName, lastName, email, department, role, status } = req.body;
      
      // Validate email format if provided
      if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }
      
      // Validate department if provided
      const validDepartments = ['教練組', '客服組', '財務組', '管理層'];
      if (department && !validDepartments.includes(department)) {
        return res.status(400).json({ success: false, error: "Invalid department" });
      }
      
      // Validate role if provided
      const validRoles = ['admin', 'manager', 'staff', 'user'];
      if (role && !validRoles.includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }
      
      // Validate status if provided
      const validStatuses = ['active', 'inactive', 'pending_approval', 'suspended'];
      if (status && !validStatuses.includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status" });
      }

      // Get current user to check if we have any changes
      const currentUser = await storage.getUser(id);
      if (!currentUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      let updatedUser = currentUser;

      // Update profile if any profile fields changed
      if (firstName !== undefined || lastName !== undefined || email !== undefined || department !== undefined) {
        const profileData = {
          firstName: firstName !== undefined ? firstName : currentUser.firstName,
          lastName: lastName !== undefined ? lastName : currentUser.lastName,
          email: email !== undefined ? email : currentUser.email,
          department: department !== undefined ? department : currentUser.department,
        };
        const result = await storage.updateUserProfile(id, profileData);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }

      // Update role if changed
      if (role !== undefined && role !== currentUser.role) {
        const result = await storage.updateUserRole(id, role, updatedUser.department || undefined);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }

      // Update status if changed
      if (status !== undefined && status !== currentUser.status) {
        const result = await storage.updateUserStatus(id, status, updatedUser.role || undefined);
        if (!result) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        updatedUser = result;
      }
      
      res.json({ success: true, data: updatedUser });
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ success: false, error: "Failed to update user" });
    }
  });

  // Role management API routes (Admin only)
  app.get('/api/roles', requireAdmin, async (req, res) => {
    try {
      const roles = await storage.listRoles();
      res.json({ success: true, data: roles });
    } catch (error) {
      console.error("Error fetching roles:", error);
      res.status(500).json({ success: false, error: "Failed to fetch roles" });
    }
  });

  app.post('/api/roles', requireAdmin, async (req, res) => {
    try {
      const data = insertRoleSchema.parse(req.body);
      const role = await storage.createRole(data);
      res.status(201).json({ success: true, data: role });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error("Error creating role:", error);
      res.status(500).json({ success: false, error: "Failed to create role" });
    }
  });

  app.put('/api/roles/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertRoleSchema.partial().parse(req.body);
      const role = await storage.updateRole(id, data);
      if (!role) {
        return res.status(404).json({ success: false, error: "Role not found" });
      }
      res.json({ success: true, data: role });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error("Error updating role:", error);
      res.status(500).json({ success: false, error: "Failed to update role" });
    }
  });

  app.delete('/api/roles/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteRole(id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: "Role not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting role:", error);
      res.status(500).json({ success: false, error: "Failed to delete role" });
    }
  });


  // Spreadsheets API routes (now protected)
  const toIsoString = (value?: Date | string | null) => {
    if (!value) {
      return null;
    }

    if (value instanceof Date) {
      return value.toISOString();
    }

    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed.toISOString();
  };

  app.get('/api/spreadsheets', async (req, res) => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      const enhanced = await Promise.all(
        spreadsheets.map(async (sheet) => {
          const relatedWorksheets = await storage.getWorksheets(sheet.spreadsheetId);
          const isActive = relatedWorksheets.some((worksheet) => worksheet.isEnabled);

          return {
            ...sheet,
            isActive,
            lastSyncAt: toIsoString(sheet.lastSyncAt ?? sheet.createdAt ?? null),
            createdAt: toIsoString(sheet.createdAt ?? null),
          };
        })
      );

      res.json({ success: true, data: enhanced });
    } catch (error) {
      console.error('Error fetching spreadsheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch spreadsheets' });
    }
  });

  app.post('/api/spreadsheets', async (req, res) => {
    try {
      const data = insertSpreadsheetSchema.parse(req.body);
      
      // Validate spreadsheet exists and is accessible
      const metadata = await googleSheetsService.validateSpreadsheet(data.spreadsheetId);
      if (!metadata) {
        return res.status(400).json({ success: false, error: 'Invalid spreadsheet ID or access denied' });
      }

      // Check if already exists
      const existing = await storage.getSpreadsheetBySheetId(data.spreadsheetId);
      if (existing) {
        return res.status(409).json({ success: false, error: 'Spreadsheet already exists' });
      }

      const spreadsheet = await storage.createSpreadsheet({
        ...data,
        name: data.name || metadata.name,
      });

      // Broadcast new sheet addition
      broadcast({
        type: 'sheet_added',
        spreadsheet: {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId,
        },
      });

      // 不在串接時同步資料，等待使用者設定 worksheet mapping 後再同步
      console.log('✅ Spreadsheet created successfully, skipping initial sync');

      res.status(201).json({ success: true, data: spreadsheet });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Error creating spreadsheet:', error);
      res.status(500).json({ success: false, error: 'Failed to create spreadsheet' });
    }
  });

  app.delete('/api/spreadsheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteSpreadsheet(id);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting spreadsheet:', error);
      res.status(500).json({ success: false, error: 'Failed to delete spreadsheet' });
    }
  });

  // Worksheet API routes (protected)

  // 優化：一次取得所有 spreadsheets 的 worksheets，避免 N+1 查詢
  app.get('/api/worksheets/all', async (req, res) => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      const allWorksheets: any[] = [];

      // 並行查詢所有 spreadsheets 的 worksheets
      await Promise.all(
        spreadsheets.map(async (spreadsheet) => {
          try {
            // Get worksheets from Google Sheets API
            const worksheetInfo = await googleSheetsService.getWorksheets(spreadsheet.spreadsheetId);
            if (!worksheetInfo) return;

            // Get existing worksheets from storage
            const existingWorksheets = await storage.getWorksheets(spreadsheet.id);

            // Merge Google Sheets data with local storage data
            const worksheets = worksheetInfo.map(wsInfo => {
              const existing = existingWorksheets.find(w => w.gid === wsInfo.gid);
              return existing || {
                id: `temp-${wsInfo.gid}`,
                worksheetName: wsInfo.name,
                gid: wsInfo.gid,
                spreadsheetId: spreadsheet.spreadsheetId,
                isEnabled: false,
                range: "A1:Z1000",
                headers: null,
                rowCount: 0,
                lastSyncAt: null,
                createdAt: new Date(),
              };
            });

            allWorksheets.push(...worksheets);
          } catch (error) {
            console.error(`Error fetching worksheets for spreadsheet ${spreadsheet.id}:`, error);
            // Continue with other spreadsheets even if one fails
          }
        })
      );

      res.json({ success: true, data: allWorksheets });
    } catch (error) {
      console.error('Error fetching all worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  app.get('/api/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Get worksheets from Google Sheets API
      const worksheetInfo = await googleSheetsService.getWorksheets(spreadsheet.spreadsheetId);
      if (!worksheetInfo) {
        return res.status(400).json({ success: false, error: 'Failed to fetch worksheets' });
      }

      // Get existing worksheets from storage
      const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
      
      // Merge Google Sheets data with local storage data
      const worksheets = worksheetInfo.map(wsInfo => {
        const existing = existingWorksheets.find(w => w.gid === wsInfo.gid);
        return existing || {
          id: `temp-${wsInfo.gid}`,
          worksheetName: wsInfo.name,
          gid: wsInfo.gid,
          spreadsheetId: spreadsheet.spreadsheetId,
          isEnabled: false,
          range: "A1:Z1000",
          headers: null,
          rowCount: 0,
          lastSyncAt: null,
          createdAt: new Date(),
        };
      });

      res.json({ success: true, data: worksheets });
    } catch (error) {
      console.error('Error fetching worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  app.post('/api/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertWorksheetSchema.omit({ spreadsheetId: true }).parse(req.body);
      
      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Check if worksheet already exists
      const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
      const existing = existingWorksheets.find(w => w.gid === data.gid);
      
      if (existing) {
        return res.status(409).json({ success: false, error: 'Worksheet already exists' });
      }

      const worksheet = await storage.createWorksheet({
        ...data,
        spreadsheetId: spreadsheet.id, // Use internal UUID
      });

      // Broadcast worksheet added
      broadcast({
        type: 'worksheet_added',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: 'Invalid request data',
          errors: error.errors
        });
      }
      console.error('Error creating worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to create worksheet' });
    }
  });

  app.put('/api/worksheets/:id/toggle', async (req, res) => {
    try {
      const { id } = req.params;
      const { isEnabled, spreadsheetId, gid, worksheetName, range } = req.body;
      
      if (typeof isEnabled !== 'boolean') {
        return res.status(400).json({ success: false, error: 'isEnabled must be a boolean' });
      }
      
      let worksheet = await storage.toggleWorksheetSync(id, isEnabled);

      if (!worksheet) {
        if (!spreadsheetId || !gid) {
          return res.status(404).json({ success: false, error: 'Worksheet not found' });
        }

        // Find spreadsheet by Google Sheets ID to get internal UUID
        const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
        if (!spreadsheet) {
          return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
        }

        const existingWorksheets = await storage.getWorksheets(spreadsheet.id);
        const existing = existingWorksheets.find(w => w.gid === gid);

        if (existing) {
          worksheet = await storage.toggleWorksheetSync(existing.id, isEnabled);
        } else {
          const created = await storage.createWorksheet({
            spreadsheetId: spreadsheet.id, // Use internal UUID
            gid,
            worksheetName: worksheetName || `Worksheet ${gid}`,
            range: range || 'A1:Z1000',
            isEnabled,
            headers: [],
          });
          worksheet = created;
        }
      }
      
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet status change
      broadcast({
        type: 'worksheet_updated',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error toggling worksheet sync:', error);
      res.status(500).json({ success: false, error: 'Failed to toggle worksheet sync' });
    }
  });

  // Update worksheet settings (range, etc.)
  app.put('/api/worksheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const worksheet = await storage.updateWorksheet(id, updates);

      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet update
      broadcast({
        type: 'worksheet_updated',
        worksheet: {
          id: worksheet.id,
          worksheetName: worksheet.worksheetName,
          gid: worksheet.gid,
          isEnabled: worksheet.isEnabled || false,
        },
      });

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error updating worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to update worksheet' });
    }
  });

  app.delete('/api/worksheets/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteWorksheet(id);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Broadcast worksheet removed
      broadcast({
        type: 'worksheet_removed',
        worksheetId: id,
      });

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting worksheet:', error);
      res.status(500).json({ success: false, error: 'Failed to delete worksheet' });
    }
  });

  // Set Supabase table mapping for a worksheet
  app.put('/api/worksheets/:id/supabase-mapping', async (req, res) => {
    try {
      const { id } = req.params;
      const { supabaseTable } = req.body;

      if (!supabaseTable || typeof supabaseTable !== 'string') {
        return res.status(400).json({ success: false, error: 'supabaseTable is required and must be a string' });
      }

      const worksheet = await storage.updateWorksheet(id, { supabaseTable });

      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      res.json({ success: true, data: worksheet });
    } catch (error) {
      console.error('Error setting Supabase mapping:', error);
      res.status(500).json({ success: false, error: 'Failed to set Supabase mapping' });
    }
  });

  // Get all existing Supabase tables
  app.get('/api/supabase/tables', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        console.log('Supabase not available, returning empty table list');
        return res.json({ success: true, data: [] });
      }

      const client = getSupabaseClient();

      // Try to use RPC function to get table names
      // First, try the RPC approach
      const { data: rpcData, error: rpcError } = await client.rpc('get_table_names');

      if (!rpcError && rpcData) {
        console.log('✓ Fetched tables via RPC:', rpcData);
        res.json({ success: true, data: rpcData });
        return;
      }

      // Fallback: Use known tables or a hardcoded list
      // This is a temporary solution - in production, you'd create the RPC function
      console.log('⚠️  RPC function not available, using fallback method');

      // Try to query a known table to verify connection
      const knownTables = [
        'trial_class_attendance',
        'trial_class_purchase',
        'eods_for_closers',
        'purchase_records',
        'consultation_records'
      ];

      // Verify which tables exist by trying to query them
      const existingTables: string[] = [];
      for (const tableName of knownTables) {
        try {
          const { error } = await client.from(tableName).select('*').limit(0);
          if (!error) {
            existingTables.push(tableName);
          }
        } catch (e) {
          // Table doesn't exist or no access
        }
      }

      console.log('✓ Found existing tables:', existingTables);
      res.json({ success: true, data: existingTables });
    } catch (error: any) {
      console.error('Error in /api/supabase/tables:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to fetch Supabase tables' });
    }
  });

  // Create a new Supabase table dynamically
  app.post('/api/supabase/tables', async (req, res) => {
    try {
      const { tableName, columns } = req.body;

      if (!tableName || typeof tableName !== 'string') {
        return res.status(400).json({ success: false, error: 'tableName is required' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase not available' });
      }

      const client = getSupabaseClient();

      // Create table with provided columns or default structure
      const columnDefs = columns && Array.isArray(columns) ? columns : [
        { name: 'id', type: 'uuid', primary: true, default: 'gen_random_uuid()' },
        { name: 'data', type: 'jsonb' },
        { name: 'created_at', type: 'timestamptz', default: 'now()' },
      ];

      // Build CREATE TABLE SQL
      const columnsSql = columnDefs.map((col: any) => {
        let def = `${col.name} ${col.type}`;
        if (col.primary) def += ' PRIMARY KEY';
        if (col.default) def += ` DEFAULT ${col.default}`;
        if (col.notNull) def += ' NOT NULL';
        return def;
      }).join(', ');

      const createTableSql = `CREATE TABLE IF NOT EXISTS ${tableName} (${columnsSql})`;

      // Execute via RPC or direct SQL (Supabase typically doesn't allow DDL via REST API)
      // This is a simplified approach - in production you'd use migrations or Admin API
      const { error } = await client.rpc('exec_sql', { sql: createTableSql });

      if (error) {
        console.error('Error creating table:', error);
        return res.status(500).json({ success: false, error: 'Failed to create table: ' + error.message });
      }

      res.json({ success: true, data: { tableName } });
    } catch (error: any) {
      console.error('Error in /api/supabase/tables POST:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to create table' });
    }
  });

  // Get data for a specific worksheet (protected)
  app.get('/api/worksheets/:id/data', async (req, res) => {
    try {
      const { id } = req.params;
      const { page, limit } = req.query;
      
      const data = await storage.getWorksheetData(id);
      
      // 如果沒有提供分頁參數，保持向後兼容，返回純數組
      if (!page && !limit) {
        return res.json({ success: true, data });
      }
      
      // 分頁參數驗證
      const pageNum = parseInt(page as string);
      const pageSize = parseInt(limit as string);
      
      if (isNaN(pageNum) || pageNum < 1) {
        return res.status(400).json({ success: false, error: 'Invalid page parameter. Must be a positive integer.' });
      }
      
      if (isNaN(pageSize) || pageSize < 1 || pageSize > 1000) {
        return res.status(400).json({ success: false, error: 'Invalid limit parameter. Must be between 1 and 1000.' });
      }
      
      const startIndex = (pageNum - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      const paginatedData = data.slice(startIndex, endIndex);
      
      res.json({
        success: true,
        data: paginatedData,
        pagination: {
          page: pageNum,
          limit: pageSize,
          total: data.length,
          totalPages: Math.ceil(data.length / pageSize)
        }
      });
    } catch (error) {
      console.error('Error fetching worksheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheet data' });
    }
  });

  // Get column headers for a specific worksheet (protected)
  app.get('/api/worksheets/:id/headers', async (req, res) => {
    try {
      const { id } = req.params;
      const worksheet = await storage.getWorksheet(id);
      
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      res.json({
        headers: worksheet.headers || [],
        worksheetName: worksheet.worksheetName
      });
    } catch (error) {
      console.error('Error fetching worksheet headers:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheet headers' });
    }
  });

  // Get aggregated data for a specific worksheet column (protected)
  app.get('/api/worksheets/:id/aggregate', async (req, res) => {
    try {
      const { id } = req.params;
      const { column, operation } = req.query;
      
      if (!column || !operation) {
        return res.status(400).json({ success: false, error: 'Column and operation parameters are required' });
      }
      
      // 驗證操作類型
      const validOperations = ['sum', 'average', 'count', 'max', 'min'];
      if (!validOperations.includes(operation as string)) {
        return res.status(400).json({ 
          message: `Invalid operation. Supported operations: ${validOperations.join(', ')}` 
        });
      }
      
      // 獲取工作表和驗證欄位
      const worksheet = await storage.getWorksheet(id);
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      const headers = worksheet.headers || [];
      if (!headers.includes(column as string)) {
        return res.status(400).json({ 
          message: `Column '${column}' not found. Available columns: ${headers.join(', ')}` 
        });
      }
      
      const data = await storage.getWorksheetData(id);
      const values = data
        .map(row => row.data[column as string])
        .filter(val => val !== null && val !== undefined && val !== '');
      
      let result;
      let numericCount = 0;
      let nonNumericCount = 0;
      
      switch (operation) {
        case 'sum':
          result = values.reduce((sum, val) => {
            const num = parseFloat(val);
            if (!isNaN(num)) {
              numericCount++;
              return sum + num;
            } else {
              nonNumericCount++;
              return sum;
            }
          }, 0);
          break;
        case 'average':
          const numericValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = numericValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? numericValues.reduce((sum, val) => sum + val, 0) / numericCount : 0;
          break;
        case 'count':
          result = values.length;
          numericCount = values.map(val => parseFloat(val)).filter(val => !isNaN(val)).length;
          nonNumericCount = values.length - numericCount;
          break;
        case 'max':
          const maxValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = maxValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? Math.max(...maxValues) : 0;
          break;
        case 'min':
          const minValues = values.map(val => parseFloat(val)).filter(val => !isNaN(val));
          numericCount = minValues.length;
          nonNumericCount = values.length - numericCount;
          result = numericCount > 0 ? Math.min(...minValues) : 0;
          break;
      }
      
      res.json({
        column: column as string,
        operation: operation as string,
        result,
        total: data.length,
        validValues: values.length,
        numericCount,
        nonNumericCount
      });
    } catch (error) {
      console.error('Error calculating aggregate:', error);
      res.status(500).json({ success: false, error: 'Failed to calculate aggregate' });
    }
  });

  // Export worksheet data as JSON (protected)
  app.get('/api/worksheets/:id/export', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { format = 'json' } = req.query;
      
      const worksheet = await storage.getWorksheet(id);
      if (!worksheet) {
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }
      
      const data = await storage.getWorksheetData(id);
      
      if (format === 'csv') {
        // Convert to CSV format
        const headers = worksheet.headers || [];
        const csvRows = [
          headers.join(','),
          ...data.map(row => 
            headers.map(header => 
              JSON.stringify(row.data[header] || '')
            ).join(',')
          )
        ];
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(worksheet.worksheetName)}.csv`);
        res.send(csvRows.join('\n'));
      } else {
        // JSON format with metadata
        const exportData = {
          worksheet: {
            id: worksheet.id,
            name: worksheet.worksheetName,
            gid: worksheet.gid,
            spreadsheetId: worksheet.spreadsheetId,
            headers: worksheet.headers,
            rowCount: worksheet.rowCount,
            lastSyncAt: worksheet.lastSyncAt,
          },
          data: data.map(row => row.data),
          exportedAt: new Date().toISOString(),
        };
        
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(worksheet.worksheetName)}.json`);
        res.json({ success: true, data: exportData });
      }
    } catch (error) {
      console.error('Error exporting worksheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to export worksheet data' });
    }
  });

  // Export all enabled worksheets data for dashboard analytics (admin only)
  app.get('/api/spreadsheets/:id/export-analytics', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }
      
      const worksheets = await storage.getWorksheets(spreadsheet.id);
      const enabledWorksheets = worksheets.filter(w => w.isEnabled);

      const analyticsData = {
        spreadsheet: {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId,
          totalRowCount: spreadsheet.rowCount,
          lastSyncAt: spreadsheet.lastSyncAt,
        },
        worksheets: await Promise.all(enabledWorksheets.map(async (worksheet) => {
          const data = await storage.getWorksheetData(worksheet.id);
          return {
            id: worksheet.id,
            name: worksheet.worksheetName,
            gid: worksheet.gid,
            headers: worksheet.headers,
            rowCount: data.length,
            data: data.map(row => row.data),
            lastSyncAt: worksheet.lastSyncAt,
          };
        })),
        exportedAt: new Date().toISOString(),
      };
      
      res.json({ success: true, data: analyticsData });
    } catch (error) {
      console.error('Error exporting analytics data:', error);
      res.status(500).json({ success: false, error: 'Failed to export analytics data' });
    }
  });

  // Worksheet sync routes (admin only)
  app.post('/api/worksheets/:id/sync', async (req, res) => {
    try {
      const { id } = req.params;
      console.log('🔄 Syncing worksheet with ID:', id);

      const worksheet = await storage.getWorksheet(id);
      console.log('📋 Worksheet found:', worksheet ? `${worksheet.worksheetName} (spreadsheetId: ${worksheet.spreadsheetId})` : 'NOT FOUND');

      if (!worksheet) {
        console.error('❌ Worksheet not found for ID:', id);
        return res.status(404).json({ success: false, error: 'Worksheet not found' });
      }

      // Get spreadsheet to obtain Google Sheets ID
      const spreadsheet = await storage.getSpreadsheet(worksheet.spreadsheetId);
      console.log('📊 Spreadsheet found:', spreadsheet ? `${spreadsheet.name} (ID: ${spreadsheet.spreadsheetId})` : 'NOT FOUND');

      if (!spreadsheet) {
        console.error('❌ Spreadsheet not found for ID:', worksheet.spreadsheetId);
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing worksheet ${worksheet.worksheetName}...`,
      });

      // Sync worksheet and capture the sync result
      const syncResult = await googleSheetsService.syncWorksheet(worksheet, spreadsheet);
      console.log('✅ Sync result:', syncResult ? `${syncResult.insertedToSupabase} inserted, ${syncResult.invalidRows} invalid` : 'null');

      // Get updated worksheet after sync
      const updatedWorksheet = await storage.getWorksheet(id);
      console.log('📋 Updated worksheet:', updatedWorksheet ? `ID: ${updatedWorksheet.id}` : 'NOT FOUND');

      if (!updatedWorksheet) {
        console.error('❌ Failed to get updated worksheet after sync');
        return res.status(500).json({ success: false, error: 'Failed to get updated worksheet' });
      }

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: worksheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for worksheet ${worksheet.worksheetName}`,
      });

      // Return worksheet with sync statistics
      const response = {
        success: true,
        data: updatedWorksheet,
        syncStats: syncResult || {
          totalRows: updatedWorksheet.rowCount || 0,
          insertedToSupabase: 0,
          invalidRows: 0,
          mappedFields: 0,
          hasSyncedToSupabase: !!worksheet.supabaseTable,
          invalidRecords: []
        }
      };

      console.log('📤 API Response:', JSON.stringify({
        success: response.success,
        dataId: response.data.id,
        syncStats: response.syncStats
      }, null, 2));

      res.json(response);
    } catch (error) {
      console.error('Error syncing worksheet:', error);

      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Worksheet sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync worksheet' });
    }
  });

  app.post('/api/spreadsheets/:id/sync-worksheets', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing enabled worksheets for ${spreadsheet.name}...`,
      });

      await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);

      // Get updated spreadsheet after sync
      const updatedSpreadsheet = await storage.getSpreadsheet(id);

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: spreadsheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for enabled worksheets in ${spreadsheet.name}`,
      });

      res.json({ success: true, data: updatedSpreadsheet });
    } catch (error) {
      console.error('Error syncing enabled worksheets:', error);
      
      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Worksheet sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync enabled worksheets' });
    }
  });

  // Get all worksheets (for widget builder)
  app.get('/api/worksheets', async (req, res) => {
    try {
      const worksheets = await storage.getAllWorksheets();
      res.json({ success: true, data: worksheets });
    } catch (error) {
      console.error('Error fetching all worksheets:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch worksheets' });
    }
  });

  // Sheet data API routes
  app.get('/api/spreadsheets/:id/data', async (req, res) => {
    try {
      const { id } = req.params;
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50;
      const search = req.query.search as string;

      const spreadsheet = await storage.getSpreadsheet(id);
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      let data;
      let total;

      if (search) {
        data = await storage.searchSheetData(spreadsheet.spreadsheetId, search);
        total = data.length;
        // Apply pagination to search results
        const start = (page - 1) * limit;
        data = data.slice(start, start + limit);
      } else {
        data = await storage.getSheetData(spreadsheet.spreadsheetId, page, limit);
        total = await storage.getSheetDataCount(spreadsheet.spreadsheetId);
      }

      res.json({
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
        spreadsheet,
      });
    } catch (error) {
      console.error('Error fetching sheet data:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch sheet data' });
    }
  });

  app.post('/api/spreadsheets/:id/sync', async (req, res) => {
    try {
      const { id } = req.params;
      const spreadsheet = await storage.getSpreadsheet(id);
      
      if (!spreadsheet) {
        return res.status(404).json({ success: false, error: 'Spreadsheet not found' });
      }

      // Broadcast sync start
      broadcast({
        type: 'sync_status',
        status: 'syncing',
        message: `Syncing ${spreadsheet.name}...`,
      });

      // Use worksheet-based sync if worksheets are enabled, otherwise use legacy sync
      const worksheets = await storage.getWorksheets(spreadsheet.id);
      const enabledWorksheets = worksheets.filter(w => w.isEnabled);

      if (enabledWorksheets.length > 0) {
        await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);
      } else {
        await googleSheetsService.syncSpreadsheet(spreadsheet);
      }

      // Get updated data count
      const updatedSpreadsheet = await storage.getSpreadsheet(id);

      // Broadcast data update for real-time refresh
      broadcast({
        type: 'data_update',
        spreadsheetId: spreadsheet.spreadsheetId,
        changes: [], // Signal general data update - frontend will refetch
      });

      // Broadcast sync completion
      broadcast({
        type: 'sync_status',
        status: 'connected',
        message: `Sync completed for ${spreadsheet.name}`,
      });

      res.json({ success: true, data: updatedSpreadsheet });
    } catch (error) {
      console.error('Error syncing spreadsheet:', error);
      
      // Broadcast sync error
      broadcast({
        type: 'sync_status',
        status: 'error',
        message: 'Sync failed. Please try again.',
      });

      res.status(500).json({ success: false, error: 'Failed to sync spreadsheet' });
    }
  });

  // Periodic sync - every 5 minutes
  setInterval(async () => {
    try {
      const spreadsheets = await storage.listSpreadsheets();
      
      for (const spreadsheet of spreadsheets) {
        try {
          // Use worksheet-based sync if worksheets are enabled, otherwise use legacy sync
          const worksheets = await storage.getWorksheets(spreadsheet.id);
          const enabledWorksheets = worksheets.filter(w => w.isEnabled);

          if (enabledWorksheets.length > 0) {
            await googleSheetsService.syncEnabledWorksheets(spreadsheet.spreadsheetId);
          } else {
            await googleSheetsService.syncSpreadsheet(spreadsheet);
          }
          
          // Broadcast data update
          broadcast({
            type: 'data_update',
            spreadsheetId: spreadsheet.spreadsheetId,
            changes: [], // Could be more specific about what changed
          });
        } catch (error) {
          console.error(`Failed to sync ${spreadsheet.name}:`, error);
        }
      }
    } catch (error) {
      console.error('Error during periodic sync:', error);
    }
  }, 5 * 60 * 1000); // 5 minutes

  // ===== Multi-Datasource API Routes =====

  // Data Source Relationships
  app.get('/api/data-source-relationships', async (req, res) => {
    try {
      const relationships = await storage.listDataSourceRelationships();
      res.json({ success: true, data: relationships });
    } catch (error) {
      console.error('Error fetching data source relationships:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const relationship = await storage.getDataSourceRelationship(req.params.id);
      if (!relationship) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.json({ success: true, data: relationship });
    } catch (error) {
      console.error('Error fetching data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/data-source-relationships', async (req, res) => {
    try {
      const validated = insertDataSourceRelationshipSchema.parse(req.body);
      
      // Validate referenced data source mappings exist
      const primarySource = await storage.getDataSourceMapping(validated.primarySourceId);
      if (!primarySource) {
        return res.status(400).json({ success: false, error: 'Primary source ID does not exist' });
      }
      const secondarySource = await storage.getDataSourceMapping(validated.secondarySourceId);
      if (!secondarySource) {
        return res.status(400).json({ success: false, error: 'Secondary source ID does not exist' });
      }
      
      const relationship = await storage.createDataSourceRelationship(validated);
      res.status(201).json({ success: true, data: relationship });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const validated = updateDataSourceRelationshipSchema.parse(req.body);
      
      // Validate referenced data source mappings exist
      if (validated.primarySourceId) {
        const primarySource = await storage.getDataSourceMapping(validated.primarySourceId);
        if (!primarySource) {
          return res.status(400).json({ success: false, error: 'Primary source ID does not exist' });
        }
      }
      if (validated.secondarySourceId) {
        const secondarySource = await storage.getDataSourceMapping(validated.secondarySourceId);
        if (!secondarySource) {
          return res.status(400).json({ success: false, error: 'Secondary source ID does not exist' });
        }
      }
      
      const relationship = await storage.updateDataSourceRelationship(req.params.id, validated);
      if (!relationship) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.json({ success: true, data: relationship });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/data-source-relationships/:id', async (req, res) => {
    try {
      const deleted = await storage.deleteDataSourceRelationship(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Data source relationship not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting data source relationship:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Purchase Records
  app.get('/api/purchase-records', async (req, res) => {
    try {
      const { studentName, courseType, status } = req.query;
      const filters: any = {};
      if (studentName) filters.studentName = studentName as string;
      if (courseType) filters.courseType = courseType as string;
      if (status) filters.status = status as string;
      
      const records = await storage.listPurchaseRecords(filters);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching purchase records:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/purchase-records/:id', async (req, res) => {
    try {
      const record = await storage.getPurchaseRecord(req.params.id);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      console.error('Error fetching purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/purchase-records/student/:email', async (req, res) => {
    try {
      const records = await storage.getPurchaseRecordsByStudent(req.params.email);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching purchase records by student:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/purchase-records', async (req, res) => {
    try {
      const validated = enhancedInsertPurchaseRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.createPurchaseRecord(validated);
      res.status(201).json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/purchase-records/:id', async (req, res) => {
    try {
      const validated = updatePurchaseRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.updatePurchaseRecord(req.params.id, validated);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/purchase-records/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deletePurchaseRecord(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Purchase record not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting purchase record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Consultation Records
  app.get('/api/consultation-records', async (req, res) => {
    try {
      const { studentName, status, consultantName } = req.query;
      const filters: any = {};
      if (studentName) filters.studentName = studentName as string;
      if (status) filters.status = status as string;
      if (consultantName) filters.consultantName = consultantName as string;
      
      const records = await storage.listConsultationRecords(filters);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching consultation records:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/consultation-records/:id', async (req, res) => {
    try {
      const record = await storage.getConsultationRecord(req.params.id);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      console.error('Error fetching consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/consultation-records/student/:email', async (req, res) => {
    try {
      const records = await storage.getConsultationRecordsByStudent(req.params.email);
      res.json({ success: true, data: records });
    } catch (error) {
      console.error('Error fetching consultation records by student:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/consultation-records', async (req, res) => {
    try {
      const validated = enhancedInsertConsultationRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.createConsultationRecord(validated);
      res.status(201).json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/consultation-records/:id', async (req, res) => {
    try {
      const validated = updateConsultationRecordSchema.parse(req.body);
      
      // Validate worksheet exists if provided
      if (validated.worksheetId) {
        const worksheet = await storage.getWorksheet(validated.worksheetId);
        if (!worksheet) {
          return res.status(400).json({ success: false, error: 'Worksheet ID does not exist' });
        }
      }
      
      const record = await storage.updateConsultationRecord(req.params.id, validated);
      if (!record) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.json({ success: true, data: record });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/consultation-records/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deleteConsultationRecord(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Consultation record not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting consultation record:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Multi-Source Analytics
  app.get('/api/multi-source-analytics', async (req, res) => {
    try {
      const { analysisType } = req.query;
      const analytics = await storage.listMultiSourceAnalytics(analysisType as string);
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error('Error fetching multi-source analytics:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.get('/api/multi-source-analytics/:id', async (req, res) => {
    try {
      const analytic = await storage.getMultiSourceAnalytic(req.params.id);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      console.error('Error fetching multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/multi-source-analytics', requireAdmin, async (req, res) => {
    try {
      const validated = insertMultiSourceAnalyticSchema.parse(req.body);
      
      // Validate relationship IDs exist if provided
      if (validated.sourceRelationshipIds && validated.sourceRelationshipIds.length > 0) {
        for (const relationshipId of validated.sourceRelationshipIds) {
          const relationship = await storage.getDataSourceRelationship(relationshipId);
          if (!relationship) {
            return res.status(400).json({ message: `Data source relationship ${relationshipId} does not exist` });
          }
        }
      }
      
      const analytic = await storage.createMultiSourceAnalytic(validated);
      res.status(201).json({ success: true, data: analytic });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error creating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.put('/api/multi-source-analytics/:id', requireAdmin, async (req, res) => {
    try {
      const validated = updateMultiSourceAnalyticSchema.parse(req.body);

      // Validate relationship IDs exist if provided
      if (validated.sourceRelationshipIds) {
        for (const relationshipId of validated.sourceRelationshipIds) {
          const relationship = await storage.getDataSourceRelationship(relationshipId);
          if (!relationship) {
            return res.status(400).json({ message: `Data source relationship ${relationshipId} does not exist` });
          }
        }
      }

      const analytic = await storage.updateMultiSourceAnalytic(req.params.id, validated as any);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid data', details: error.errors });
      }
      console.error('Error updating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.post('/api/multi-source-analytics/:id/calculate', requireAdmin, async (req, res) => {
    try {
      const analytic = await storage.calculateMultiSourceAnalytic(req.params.id);
      if (!analytic) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.json({ success: true, data: analytic });
    } catch (error) {
      console.error('Error calculating multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  app.delete('/api/multi-source-analytics/:id', requireAdmin, async (req, res) => {
    try {
      const deleted = await storage.deleteMultiSourceAnalytic(req.params.id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Multi-source analytic not found' });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting multi-source analytic:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // ===== Auto Analysis API Routes =====

  // Analyze a specific worksheet
  app.post('/api/worksheets/:id/analyze', async (req, res) => {
    const worksheetId = req.params.id;
    console.log(`🎯 API request to analyze worksheet: ${worksheetId}`);

    try {
      // Check if worksheet exists
      const worksheet = await storage.getWorksheet(worksheetId);
      if (!worksheet) {
        console.error(`❌ Worksheet not found: ${worksheetId}`);
        return res.status(404).json({
          message: 'Worksheet not found',
          error: `No worksheet found with ID: ${worksheetId}`
        });
      }

      console.log(`✅ Found worksheet: ${worksheet.worksheetName}`);

      // Perform analysis
      console.log(`🔍 Starting analysis for worksheet: ${worksheet.worksheetName}`);
      const analysis = await autoAnalysisService.analyzeWorksheet(worksheetId);

      if (!analysis) {
        console.error(`❌ Analysis failed for worksheet: ${worksheet.worksheetName}`);
        return res.status(500).json({
          message: 'Failed to analyze worksheet',
          error: 'Analysis service returned null. Check server logs for details.',
          worksheetName: worksheet.worksheetName
        });
      }

      console.log(`✅ Analysis completed for worksheet: ${worksheet.worksheetName}`);

      // Save analysis to storage
      console.log(`💾 Saving analysis to storage...`);
      const savedAnalysis = await storage.createWorksheetAnalysis({
        worksheetId: analysis.worksheetId,
        category: analysis.category,
        confidence: Math.round(analysis.confidence * 100),
        columnAnalyses: analysis.columns,
        rowCount: analysis.rowCount,
        dataQuality: analysis.dataQuality,
        suggestedReports: analysis.suggestedReports
      });

      console.log(`🎉 Analysis saved successfully with ID: ${savedAnalysis.id}`);
      res.json({ success: true, data: savedAnalysis });

    } catch (error) {
      console.error(`❌ Error analyzing worksheet ${worksheetId}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      res.status(500).json({
        message: 'Internal server error',
        error: errorMessage,
        worksheetId,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Get analysis for a worksheet
  app.get('/api/worksheets/:id/analysis', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      const analysis = await storage.getWorksheetAnalysis(worksheetId);

      if (!analysis) {
        return res.status(404).json({ success: false, error: 'Analysis not found' });
      }

      res.json({ success: true, data: analysis });
    } catch (error) {
      console.error('Error fetching worksheet analysis:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Analyze all worksheets in a spreadsheet
  app.post('/api/spreadsheets/:id/analyze-all', async (req, res) => {
    const spreadsheetId = req.params.id;
    console.log(`🚀 API request to analyze all worksheets in spreadsheet: ${spreadsheetId}`);

    try {
      const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
      if (!spreadsheet) {
        console.error(`❌ Spreadsheet not found: ${spreadsheetId}`);
        return res.status(404).json({
          message: 'Spreadsheet not found',
          error: `No spreadsheet found with ID: ${spreadsheetId}`
        });
      }

      console.log(`✅ Found spreadsheet: ${spreadsheet.name}`);

      // Clear existing analyses for this spreadsheet's worksheets
      const existingAnalyses = await storage.listWorksheetAnalyses(spreadsheetId);
      console.log(`🗑️ Clearing ${existingAnalyses.length} existing analyses`);

      for (const analysis of existingAnalyses) {
        await storage.deleteWorksheetAnalysis(analysis.id);
      }

      const analyses = await autoAnalysisService.analyzeAllWorksheets(spreadsheetId);
      console.log(`📊 Got ${analyses.length} analyses from service`);

      const savedAnalyses = [];
      const errors = [];

      for (const analysis of analyses) {
        try {
          console.log(`💾 Saving analysis for worksheet: ${analysis.worksheetName}`);
          const savedAnalysis = await storage.createWorksheetAnalysis({
            worksheetId: analysis.worksheetId,
            category: analysis.category,
            confidence: Math.round(analysis.confidence * 100),
            columnAnalyses: analysis.columns,
            rowCount: analysis.rowCount,
            dataQuality: analysis.dataQuality,
            suggestedReports: analysis.suggestedReports
          });
          savedAnalyses.push(savedAnalysis);
          console.log(`✅ Saved analysis for worksheet: ${analysis.worksheetName}`);
        } catch (error) {
          const errorMsg = `Failed to save analysis for worksheet ${analysis.worksheetId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          console.error(`❌ ${errorMsg}`);
          errors.push(errorMsg);
        }
      }

      console.log(`🎉 Analysis completed: ${savedAnalyses.length} saved, ${errors.length} errors`);

      res.json({
        analyses: savedAnalyses,
        summary: {
          total: analyses.length,
          saved: savedAnalyses.length,
          errors: errors.length,
          errorMessages: errors
        }
      });

    } catch (error) {
      console.error(`❌ Error analyzing all worksheets in ${spreadsheetId}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      res.status(500).json({
        message: 'Internal server error',
        error: errorMessage,
        spreadsheetId,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Get all analyses for a spreadsheet
  app.get('/api/spreadsheets/:id/analyses', async (req, res) => {
    try {
      const spreadsheetId = req.params.id;
      const analyses = await storage.listWorksheetAnalyses(spreadsheetId);
      res.json({ success: true, data: analyses });
    } catch (error) {
      console.error('Error fetching spreadsheet analyses:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Generate auto report from analysis suggestion
  app.post('/api/worksheet-analyses/:id/generate-report', async (req, res) => {
    try {
      const analysisId = req.params.id;
      const { suggestionIndex } = req.body;

      const analysis: any = Array.from((storage as any).worksheetAnalyses.values()).find((a: any) => a.id === analysisId);
      if (!analysis) {
        return res.status(404).json({ success: false, error: 'Analysis not found' });
      }

      const suggestion = analysis.suggestedReports[suggestionIndex];
      if (!suggestion) {
        return res.status(404).json({ success: false, error: 'Report suggestion not found' });
      }

      // Convert storage analysis to service analysis format
      const serviceAnalysis = {
        worksheetId: analysis.worksheetId,
        worksheetName: '', // Will be filled by service
        category: analysis.category as any,
        confidence: analysis.confidence / 100,
        columns: analysis.columnAnalyses,
        rowCount: analysis.rowCount,
        suggestedReports: analysis.suggestedReports,
        dataQuality: analysis.dataQuality
      };

      // Generate the report data
      const reportData = await autoAnalysisService.generateAutoReport(serviceAnalysis, suggestion);

      // Save the generated report
      const savedReport = await storage.createAutoGeneratedReport({
        worksheetAnalysisId: analysisId,
        reportType: suggestion.type,
        title: suggestion.title,
        description: suggestion.description,
        config: {
          chartType: suggestion.chartType,
          metrics: suggestion.metrics,
          filters: suggestion.filters,
          groupBy: suggestion.groupBy
        },
        data: reportData,
        isActive: true
      });

      res.json(savedReport);
    } catch (error) {
      console.error('Error generating auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Get auto-generated reports for a worksheet
  app.get('/api/worksheets/:id/auto-reports', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      const reports = await storage.getAutoGeneratedReportsByWorksheet(worksheetId);
      res.json(reports);
    } catch (error) {
      console.error('Error fetching auto-generated reports:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Get a specific auto-generated report
  app.get('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const report = await storage.getAutoGeneratedReport(reportId);

      if (!report) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json(report);
    } catch (error) {
      console.error('Error fetching auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Update an auto-generated report
  app.put('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const updates = req.body;

      const updatedReport = await storage.updateAutoGeneratedReport(reportId, updates);
      if (!updatedReport) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json(updatedReport);
    } catch (error) {
      console.error('Error updating auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // Delete an auto-generated report
  app.delete('/api/auto-reports/:id', async (req, res) => {
    try {
      const reportId = req.params.id;
      const deleted = await storage.deleteAutoGeneratedReport(reportId);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting auto report:', error);
      res.status(500).json({ success: false, error: 'Internal server error' });
    }
  });

  // ===== Development Seed API Routes =====

  // Seed test data for Total Report (DEV only)
  app.post('/api/dev/seed-total-report', isAuthenticated, async (req, res) => {
    // Only allow in development
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({
        success: false,
        error: 'Not allowed in production',
      });
    }

    try {
      const result = await devSeedService.seedTotalReportData();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error seeding data:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to seed data',
        message: error.message,
      });
    }
  });

  // Clear test data (DEV only)
  app.delete('/api/dev/seed-total-report', isAuthenticated, async (req, res) => {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({
        success: false,
        error: 'Not allowed in production',
      });
    }

    try {
      const result = await devSeedService.clearTestData();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error clearing data:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to clear data',
        message: error.message,
      });
    }
  });

  // ===== Introspection Tool API Routes =====

  // Trigger field introspection
  app.post('/api/tools/introspect-sheets', isAuthenticated, async (req, res) => {
    try {
      const result = await introspectService.runIntrospection();
      res.json({
        success: true,
        data: result,
      });
    } catch (error: any) {
      console.error('Error running introspection:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to run introspection',
        message: error.message,
      });
    }
  });

  // Get latest introspection result
  app.get('/api/tools/introspect-sheets/latest', isAuthenticated, async (req, res) => {
    try {
      const result = await introspectService.getLatestIntrospection();
      if (!result) {
        return res.json({
          success: true,
          data: null,
        });
      }
      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('Error fetching latest introspection:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch introspection data',
      });
    }
  });

  // ===== Report Metric Configuration API Routes =====

  // Get all metric configurations
  app.get('/api/report-metrics/config', isAuthenticated, async (req, res) => {
    try {
      const configs = await reportMetricConfigService.getAllConfigs();
      res.json({
        success: true,
        data: configs,
      });
    } catch (error: any) {
      console.error('Error fetching metric configs:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch metric configurations',
        message: error.message,
      });
    }
  });

  // Get specific metric configuration
  app.get('/api/report-metrics/config/:metricId', isAuthenticated, async (req, res) => {
    try {
      const config = await reportMetricConfigService.getConfig(req.params.metricId);
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Metric configuration not found',
        });
      }
      res.json({
        success: true,
        data: config,
      });
    } catch (error: any) {
      console.error('Error fetching metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch metric configuration',
        message: error.message,
      });
    }
  });

  // Update metric configuration
  app.post('/api/report-metrics/config', isAuthenticated, async (req, res) => {
    try {
      const { metricId, manualFormula, sourceFields } = req.body;

      if (!metricId) {
        return res.status(400).json({
          success: false,
          error: 'metricId is required',
        });
      }

      // Validate formula if provided
      if (manualFormula) {
        const allowedVars = Object.keys(getAvailableFormulaVariables());
        const validation = formulaEngine.validateFormula(manualFormula, allowedVars);

        if (!validation.valid) {
          return res.status(400).json({
            success: false,
            error: validation.error,
          });
        }
      }

      const updated = await reportMetricConfigService.updateConfig(metricId, {
        manualFormula,
        sourceFields,
      });

      res.json({
        success: true,
        data: updated,
      });
    } catch (error: any) {
      console.error('Error updating metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update metric configuration',
        message: error.message,
      });
    }
  });

  // Reset metric configuration to default
  app.delete('/api/report-metrics/config/:metricId', isAuthenticated, async (req, res) => {
    try {
      const reset = await reportMetricConfigService.resetConfig(req.params.metricId);
      res.json({
        success: true,
        data: reset,
      });
    } catch (error: any) {
      console.error('Error resetting metric config:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reset metric configuration',
        message: error.message,
      });
    }
  });

  // ===== Formula Validation API =====

  // Validate formula syntax
  app.post('/api/formula/validate', isAuthenticated, async (req, res) => {
    try {
      const { formula } = req.body;

      if (!formula || typeof formula !== 'string') {
        return res.status(400).json({
          success: false,
          error: 'Formula is required',
        });
      }

      const allowedVars = Object.keys(getAvailableFormulaVariables());
      const validation = formulaEngine.validateFormula(formula, allowedVars);

      res.json({
        success: true,
        data: validation,
      });
    } catch (error: any) {
      console.error('Error validating formula:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to validate formula',
        message: error.message,
      });
    }
  });

  // ===== KPI Calculator API Routes =====

  // Get detailed KPI calculation breakdown
  app.get('/api/kpi-calculator/detail', isAuthenticated, async (req, res) => {
    try {
      const period = (req.query.period as string) || 'monthly';
      const baseDate = req.query.baseDate as string | undefined;
      const startDate = req.query.startDate as string | undefined;
      const endDate = req.query.endDate as string | undefined;

      // Get date range using public helper
      const serviceDateRange = totalReportService.getDateRange(
        period as any,
        baseDate ? new Date(baseDate) : new Date(),
        startDate ? new Date(startDate) : undefined,
        endDate ? new Date(endDate) : undefined
      );

      const warnings: string[] = [];

      // Fetch raw data using public helper
      const rawDataResult = await totalReportService.fetchRawData(serviceDateRange, warnings);

      // Get last sync time from storage if available
      let lastSync: string | null = null;
      if (rawDataResult.dataSource === 'storage') {
        const spreadsheets = await storage.listSpreadsheets();
        const sheets = spreadsheets.filter(s =>
          s.name.includes('體驗課') || s.name.includes('EODs')
        );
        if (sheets.length > 0 && sheets[0].lastSyncAt) {
          lastSync = sheets[0].lastSyncAt.toISOString();
        }
      }

      // Calculate with full details
      const { calculateAllKPIs } = await import('./services/kpi-calculator');
      const result = await calculateAllKPIs({
        attendance: rawDataResult.attendanceData,
        purchases: rawDataResult.purchaseData,
        deals: rawDataResult.eodsData,
      });

      // Determine mode
      const mode = rawDataResult.attendanceData.length === 0 &&
                   rawDataResult.purchaseData.length === 0 &&
                   rawDataResult.eodsData.length === 0
                   ? 'mock'
                   : (rawDataResult.dataSource === 'supabase' ? 'supabase' : 'storage');

      res.json({
        success: true,
        data: {
          mode,
          rawDataSummary: {
            source: rawDataResult.dataSource,
            attendance: {
              count: rawDataResult.attendanceData.length,
              source: rawDataResult.dataSource,
            },
            purchases: {
              count: rawDataResult.purchaseData.length,
              source: rawDataResult.dataSource,
            },
            deals: {
              count: rawDataResult.eodsData.length,
              source: rawDataResult.dataSource,
            },
            dateRange: serviceDateRange,
            lastSync,
          },
          calculationDetail: result.calculationDetail,
          summaryMetrics: result.summaryMetrics,
          warnings: Array.from(new Set([...warnings, ...result.warnings])), // Deduplicate warnings
        },
      });
    } catch (error: any) {
      console.error('Error calculating KPI details:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to calculate KPI details',
        message: error.message,
      });
    }
  });

  // ===== Sheet Mappings API Routes =====

  // Development mode - Get all sheet mappings without auth (for testing)
  if (process.env.NODE_ENV !== 'production') {
    app.get('/api/dev/sheet-mappings', async (req, res) => {
      try {
        const mappings = await storage.getSheetMappings();
        res.json({
          success: true,
          data: mappings,
        });
      } catch (error: any) {
        console.error('Error fetching sheet mappings:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to fetch sheet mappings',
          message: error.message,
        });
      }
    });

    app.get('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;
        const mapping = await storage.getSheetMapping(sheetType as any);

        if (!mapping) {
          return res.status(404).json({
            success: false,
            error: 'Sheet mapping not found',
          });
        }

        res.json({
          success: true,
          data: mapping,
        });
      } catch (error: any) {
        console.error('Error fetching sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to fetch sheet mapping',
          message: error.message,
        });
      }
    });

    app.post('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;
        const updates = req.body;

        if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
          });
        }

        const updated = await storage.updateSheetMapping(sheetType as any, updates);

        res.json({
          success: true,
          data: updated,
        });
      } catch (error: any) {
        console.error('Error updating sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to update sheet mapping',
          message: error.message,
        });
      }
    });

    app.delete('/api/dev/sheet-mappings/:sheetType', async (req, res) => {
      try {
        const { sheetType } = req.params;

        if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
          });
        }

        const reset = await storage.resetSheetMapping(sheetType as any);

        res.json({
          success: true,
          data: reset,
        });
      } catch (error: any) {
        console.error('Error resetting sheet mapping:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to reset sheet mapping',
          message: error.message,
        });
      }
    });
  }

  // Get all sheet mappings
  app.get('/api/sheet-mappings', isAuthenticated, async (req, res) => {
    try {
      const mappings = await storage.getSheetMappings();
      res.json({
        success: true,
        data: mappings,
      });
    } catch (error: any) {
      console.error('Error fetching sheet mappings:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch sheet mappings',
        message: error.message,
      });
    }
  });

  // Get specific sheet mapping
  app.get('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;
      const mapping = await storage.getSheetMapping(sheetType as any);

      if (!mapping) {
        return res.status(404).json({
          success: false,
          error: 'Sheet mapping not found',
        });
      }

      res.json({
        success: true,
        data: mapping,
      });
    } catch (error: any) {
      console.error('Error fetching sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch sheet mapping',
        message: error.message,
      });
    }
  });

  // Update sheet mapping
  app.post('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;
      const updates = req.body;

      // Validate sheetType
      if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
        });
      }

      const updated = await storage.updateSheetMapping(sheetType as any, updates);

      res.json({
        success: true,
        data: updated,
      });
    } catch (error: any) {
      console.error('Error updating sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update sheet mapping',
        message: error.message,
      });
    }
  });

  // Reset sheet mapping to default
  app.delete('/api/sheet-mappings/:sheetType', isAuthenticated, async (req, res) => {
    try {
      const { sheetType } = req.params;

      // Validate sheetType
      if (!['trial_attendance', 'trial_purchase', 'eods'].includes(sheetType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid sheet type. Must be one of: trial_attendance, trial_purchase, eods',
        });
      }

      const reset = await storage.resetSheetMapping(sheetType as any);

      res.json({
        success: true,
        data: reset,
      });
    } catch (error: any) {
      console.error('Error resetting sheet mapping:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reset sheet mapping',
        message: error.message,
      });
    }
  });

  // ===== Total Report API Routes =====

  // Validate trial class KPIs
  app.post('/api/reports/trial-class/validate-kpis', isAuthenticated, async (req, res) => {
    try {
      const { trialClassKPIRuleEngine } = await import('./services/kpi-rule-engine');
      const { directSqlRepository } = await import('./services/reporting/direct-sql-repository');

      // 獲取原始數據
      const dateRange = { start: '1970-01-01', end: '2099-12-31' };
      const [purchases, attendance, deals] = await Promise.all([
        directSqlRepository.getPurchases(dateRange),
        directSqlRepository.getAttendance(dateRange),
        directSqlRepository.getDeals(dateRange),
      ]);

      // 驗證 KPI
      const validationReport = trialClassKPIRuleEngine.validateAllKPIs(
        req.body.currentMetrics,
        { purchases, attendance, deals }
      );

      res.json({
        success: true,
        data: validationReport,
      });
    } catch (error) {
      console.error('Error validating KPIs:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
      });
    }
  });

  // Auto-fix trial class KPIs
  app.post('/api/reports/trial-class/auto-fix-kpis', isAuthenticated, async (req, res) => {
    try {
      const { trialClassKPIRuleEngine } = await import('./services/kpi-rule-engine');
      const { directSqlRepository } = await import('./services/reporting/direct-sql-repository');

      // 獲取原始數據
      const dateRange = { start: '1970-01-01', end: '2099-12-31' };
      const [purchases, attendance, deals] = await Promise.all([
        directSqlRepository.getPurchases(dateRange),
        directSqlRepository.getAttendance(dateRange),
        directSqlRepository.getDeals(dateRange),
      ]);

      // 驗證並自動修正
      const validationReport = trialClassKPIRuleEngine.validateAllKPIs(
        req.body.currentMetrics,
        { purchases, attendance, deals }
      );

      const fixedMetrics = trialClassKPIRuleEngine.autoFixKPIs(
        req.body.currentMetrics,
        validationReport
      );

      res.json({
        success: true,
        data: {
          validationReport,
          fixedMetrics,
        },
      });
    } catch (error) {
      console.error('Error auto-fixing KPIs:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
      });
    }
  });

  // Get trial class report data
  app.get('/api/reports/trial-class', isAuthenticated, requireModulePermission('trial_class_report'), async (req, res) => {
    try{
      const period = (req.query.period as 'daily' | 'weekly' | 'lastWeek' | 'monthly') || 'daily';
      const baseDate = req.query.baseDate as string | undefined;

      // Validate period
      if (!['daily', 'weekly', 'lastWeek', 'monthly', 'all'].includes(period)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid period. Must be one of: daily, weekly, lastWeek, monthly, all',
        });
      }

      // Validate baseDate if provided
      if (baseDate) {
        const date = new Date(baseDate);
        if (isNaN(date.getTime())) {
          return res.status(400).json({
            success: false,
            error: 'Invalid baseDate. Must be ISO date string',
          });
        }
      }

      // Generate report（傳遞當前用戶 ID 進行權限過濾）
      // 支援 debug 模式：可透過 query parameter 指定 userId 進行測試
      let userId = (req as any).user?.id;
      if (process.env.SKIP_AUTH === 'true' && req.query.debugUserId) {
        userId = req.query.debugUserId as string;
        console.log(`[DEBUG] Using debugUserId: ${userId}`);
      }

      const reportData = await totalReportService.generateReport({
        period,
        baseDate,
        userId, // 新增：用於權限過濾
      });

      if (!reportData) {
        return res.json({
          success: false,
          error: 'No data available',
          message: '無法產生報表：資料來源不足或無資料。',
        });
      }

      res.json({
        success: true,
        data: reportData,
      });
    } catch (error: any) {
      console.error('Error generating total report:', error);

      // 🛡️ 特別處理 Supabase pooler 斷線錯誤
      const errorMessage = error?.message || String(error);
      const isPoolerTimeout = errorMessage.includes('termination') ||
                             errorMessage.includes('shutdown') ||
                             errorMessage.includes('db_termination');

      if (isPoolerTimeout) {
        console.error('⚠️  Supabase Transaction Pooler timeout detected!');
        console.error('   This query took too long for the Transaction Pooler.');
        console.error('   Recommendation: Switch to Session Pooler (port 6543) in SUPABASE_URL');

        return res.status(503).json({
          success: false,
          error: 'Database query timeout',
          message: '資料庫查詢超時。請稍後再試，或聯絡管理員切換到 Session Pooler 以支援更長的查詢時間。',
        });
      }

      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: '產生報表時發生錯誤',
      });
    }
  });

  // Dashboard Overview API - 儀表板總覽數據
  app.get('/api/reports/overview', isAuthenticated, async (req, res) => {
    try {
      const userId = (req as any).user?.id;

      // 1. 取得本月數據
      const monthlyReport = await totalReportService.generateReport({
        period: 'monthly',
        userId,
      });

      // 2. 取得本週數據
      const weeklyReport = await totalReportService.generateReport({
        period: 'weekly',
        userId,
      });

      // 3. 取得上週數據
      const lastWeekReport = await totalReportService.generateReport({
        period: 'lastWeek',
        userId,
      });

      // 4. 從 eods_for_closers 計算財務數據
      // 本月營收和毛利率
      const monthlyFinancialQuery = `
        SELECT
          COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as monthly_revenue,
          COALESCE(AVG(
            CASE
              WHEN CAST(actual_amount AS NUMERIC) > 0 AND CAST(package_price AS NUMERIC) > 0
              THEN ((CAST(actual_amount AS NUMERIC) - (CAST(package_price AS NUMERIC) * 0.7)) / CAST(actual_amount AS NUMERIC) * 100)
              ELSE 0
            END
          ), 0) as profit_margin
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('month', CURRENT_DATE)
          AND deal_date < date_trunc('month', CURRENT_DATE) + interval '1 month'
          AND consultation_result = '成交'
      `;

      const monthlyFinancialResult = await queryDatabase(monthlyFinancialQuery);

      // 本週營收
      const weeklyRevenueQuery = `
        SELECT COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as weekly_revenue
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('week', CURRENT_DATE)
          AND deal_date < date_trunc('week', CURRENT_DATE) + interval '1 week'
          AND consultation_result = '成交'
      `;

      const weeklyRevenueResult = await queryDatabase(weeklyRevenueQuery);

      // 上週營收
      const lastWeekRevenueQuery = `
        SELECT COALESCE(SUM(CAST(actual_amount AS NUMERIC)), 0) as last_week_revenue
        FROM eods_for_closers
        WHERE deal_date >= date_trunc('week', CURRENT_DATE) - interval '1 week'
          AND deal_date < date_trunc('week', CURRENT_DATE)
          AND consultation_result = '成交'
      `;

      const lastWeekRevenueResult = await queryDatabase(lastWeekRevenueQuery);

      // 5. 計算學生數據
      const studentsQuery = `
        SELECT
          COUNT(DISTINCT student_email) as total_students,
          COUNT(DISTINCT CASE
            WHEN purchase_date >= date_trunc('month', CURRENT_DATE)
            THEN student_email
          END) as new_students_this_month
        FROM trial_class_purchases
        WHERE student_email IS NOT NULL
      `;

      const studentsResult = await queryDatabase(studentsQuery);

      // 6. 組裝回應
      const responseData = {
        // 本月營收概況
        monthlyRevenue: parseFloat(monthlyFinancialResult.rows[0]?.monthly_revenue || 0),
        monthlyTarget: 2000000, // NT$ 2,000,000
        yearlyTarget: 20000000, // NT$ 20,000,000
        profitMargin: parseFloat(monthlyFinancialResult.rows[0]?.profit_margin || 0),

        // 體驗課數據
        trialConversionRate: monthlyReport?.summaryMetrics?.conversionRate || 0,
        pendingStudents: monthlyReport?.summaryMetrics?.pendingStudents || 0,
        weeklyTrials: weeklyReport?.summaryMetrics?.totalTrials || 0,

        // 學生數據
        totalStudents: parseInt(studentsResult.rows[0]?.total_students || 0),
        newStudentsThisMonth: parseInt(studentsResult.rows[0]?.new_students_this_month || 0),

        // 本週趨勢 (vs 上週)
        weeklyTrends: {
          trials: {
            current: weeklyReport?.summaryMetrics?.totalTrials || 0,
            previous: lastWeekReport?.summaryMetrics?.totalTrials || 0,
          },
          conversions: {
            current: weeklyReport?.summaryMetrics?.totalConversions || 0,
            previous: lastWeekReport?.summaryMetrics?.totalConversions || 0,
          },
          revenue: {
            current: parseFloat(weeklyRevenueResult.rows[0]?.weekly_revenue || 0),
            previous: parseFloat(lastWeekRevenueResult.rows[0]?.last_week_revenue || 0),
          },
        },

        // 數據來源元數據
        dataSourceMeta: monthlyReport?.dataSourceMeta || null,
      };

      res.json({
        success: true,
        data: responseData,
      });
    } catch (error) {
      console.error('Error generating overview:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate overview',
        details: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  });

  // ===== Debug API Routes =====

  // Debug: Check worksheet and data status
  app.get('/api/debug/worksheets/:id', async (req, res) => {
    try {
      const worksheetId = req.params.id;
      console.log(`🔍 Debug request for worksheet: ${worksheetId}`);

      // Get worksheet info
      const worksheet = await storage.getWorksheet(worksheetId);
      if (!worksheet) {
        return res.status(404).json({
          error: 'Worksheet not found',
          worksheetId
        });
      }

      // Get worksheet data (all data, no pagination)
      const worksheetData = await storage.getWorksheetData(worksheetId, 1, 10000);

      // Get spreadsheet data
      const spreadsheetData = await storage.getSheetData(worksheet.spreadsheetId, 1, 10000);

      // Get all data for debugging
      const allSheetData = Array.from((storage as any).sheetData.values());

      // Filter data by various criteria for debugging
      const dataWithWorksheetId = allSheetData.filter((item: any) => item.worksheetId === worksheetId);
      const dataWithSpreadsheetId = allSheetData.filter((item: any) => item.spreadsheetId === worksheet.spreadsheetId);
      const dataWithoutWorksheetId = allSheetData.filter((item: any) => !item.worksheetId && item.spreadsheetId === worksheet.spreadsheetId);

      res.json({
        worksheet: {
          id: worksheet.id,
          name: worksheet.worksheetName,
          spreadsheetId: worksheet.spreadsheetId,
          isEnabled: worksheet.isEnabled,
          headers: worksheet.headers,
          rowCount: worksheet.rowCount
        },
        data: {
          worksheetData: {
            count: worksheetData.length,
            sample: worksheetData.slice(0, 3)
          },
          spreadsheetData: {
            count: spreadsheetData.length,
            sample: spreadsheetData.slice(0, 3)
          },
          allDataStats: {
            total: allSheetData.length,
            withWorksheetId: dataWithWorksheetId.length,
            withSpreadsheetId: dataWithSpreadsheetId.length,
            withoutWorksheetId: dataWithoutWorksheetId.length
          },
          sampleDataWithoutWorksheetId: dataWithoutWorksheetId.slice(0, 3)
        },
        recommendation: worksheetData.length === 0 && dataWithoutWorksheetId.length > 0
          ? 'Found data without worksheetId - this might be the issue'
          : worksheetData.length === 0
            ? 'No data found - worksheet needs to be synced'
            : 'Data found successfully'
      });

    } catch (error) {
      console.error('Debug error:', error);
      res.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Debug: List all worksheets in a spreadsheet
  app.get('/api/debug/spreadsheets/:id/worksheets', async (req, res) => {
    try {
      const spreadsheetId = req.params.id;
      console.log(`🔍 Debug request for spreadsheet worksheets: ${spreadsheetId}`);

      const spreadsheet = await storage.getSpreadsheetBySheetId(spreadsheetId);
      const worksheets = await storage.getWorksheets(spreadsheetId);

      const worksheetDetails = [];
      for (const worksheet of worksheets) {
        const worksheetData = await storage.getWorksheetData(worksheet.id, 1, 10000);
        worksheetDetails.push({
          id: worksheet.id,
          name: worksheet.worksheetName,
          isEnabled: worksheet.isEnabled,
          headers: worksheet.headers,
          dataRowCount: worksheetData.length,
          hasData: worksheetData.length > 0
        });
      }

      res.json({
        spreadsheet: spreadsheet ? {
          id: spreadsheet.id,
          name: spreadsheet.name,
          spreadsheetId: spreadsheet.spreadsheetId
        } : null,
        worksheets: worksheetDetails,
        summary: {
          total: worksheets.length,
          enabled: worksheets.filter(w => w.isEnabled).length,
          withData: worksheetDetails.filter(w => w.hasData).length
        }
      });

    } catch (error) {
      console.error('Debug error:', error);
      res.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ===== 戰力報表 API =====

  // 生成戰力報表
  app.post('/api/reports/generate', async (req, res) => {
    try {
      const { type, date } = req.body;

      if (!type || !['daily', 'weekly'].includes(type)) {
        return res.status(400).json({ success: false, error: 'Invalid report type. Must be "daily" or "weekly"' });
      }

      if (!date) {
        return res.status(400).json({ success: false, error: 'Date is required' });
      }

      // 調用報表生成服務
      const reportService = await import('./services/deprecated/integrated-report-service');
      const report = await reportService.integratedReportService.generateReport({ type, date });

      res.json({ success: true, data: report });
    } catch (error: any) {
      console.error('Error generating report:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to generate report' });
    }
  });

  // 獲取報表列表
  app.get('/api/reports', async (req, res) => {
    try {
      const type = req.query.type as string | undefined;
      const limit = parseInt(req.query.limit as string) || 10;

      const reportService = await import('./services/deprecated/integrated-report-service');
      const reports = await reportService.integratedReportService.getReports(type, limit);

      res.json({ success: true, data: reports });
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch reports' });
    }
  });

  // 獲取特定報表
  app.get('/api/reports/:id', async (req, res) => {
    try {
      const reportService = await import('./services/deprecated/integrated-report-service');
      const report = await reportService.integratedReportService.getReport(req.params.id);

      if (!report) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json({ success: true, data: report });
    } catch (error) {
      console.error('Error fetching report:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch report' });
    }
  });

  // 更新報表 AI 建議
  app.put('/api/reports/:id/insights', async (req, res) => {
    try {
      const { insights } = req.body;

      if (!insights || typeof insights !== 'string') {
        return res.status(400).json({ success: false, error: 'Insights text is required' });
      }

      const reportService = await import('./services/deprecated/integrated-report-service');
      const updatedReport = await reportService.integratedReportService.updateReportInsights(req.params.id, insights);

      if (!updatedReport) {
        return res.status(404).json({ success: false, error: 'Report not found' });
      }

      res.json({ success: true, data: updatedReport });
    } catch (error: any) {
      console.error('Error updating report insights:', error);
      res.status(500).json({ success: false, error: error.message || 'Failed to update insights' });
    }
  });

  // ===== AI KPI 定義 API =====

  // 解析自然語言 KPI 定義
  app.post('/api/kpi/parse-definition', async (req, res) => {
    try {
      const { kpiName, definition } = req.body;

      if (!kpiName || !definition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName and definition are required'
        });
      }

      const { parseKPIDefinition } = await import('./services/ai-kpi-definition-parser');
      const result = await parseKPIDefinition(kpiName, definition);

      if (!result.success) {
        return res.status(400).json({
          success: false,
          error: result.error
        });
      }

      res.json({
        success: true,
        parsed: result.parsed
      });
    } catch (error: any) {
      console.error('Error parsing KPI definition:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to parse definition'
      });
    }
  });

  // 預覽 KPI 計算結果
  app.post('/api/kpi/preview-calculation', async (req, res) => {
    try {
      const { kpiName, definition, parameters } = req.body;

      if (!kpiName || !definition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName and definition are required'
        });
      }

      const supabase = getSupabaseClient();
      const { calculatePreview } = await import('./services/ai-kpi-definition-parser');

      const preview = await calculatePreview(
        kpiName,
        definition,
        parameters || {},
        supabase
      );

      res.json({
        success: true,
        preview
      });
    } catch (error: any) {
      console.error('Error calculating preview:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to calculate preview'
      });
    }
  });

  // 儲存 KPI 定義
  app.post('/api/kpi/save-definition', async (req, res) => {
    try {
      const { kpiName, naturalLanguage, parsedDefinition, parameters } = req.body;

      if (!kpiName || !naturalLanguage || !parsedDefinition) {
        return res.status(400).json({
          success: false,
          error: 'kpiName, naturalLanguage, and parsedDefinition are required'
        });
      }

      // Store the custom definition in report metric config
      await reportMetricConfigService.updateConfig(kpiName, {
        manualFormula: naturalLanguage, // Store natural language as manual formula
        description: `自訂定義：${parsedDefinition.numerator.label} / ${parsedDefinition.denominator.label}`,
        metadata: {
          parsedDefinition,
          parameters: parameters || {},
          updatedAt: new Date().toISOString()
        }
      });

      res.json({
        success: true,
        message: 'KPI definition saved successfully'
      });
    } catch (error: any) {
      console.error('Error saving KPI definition:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to save definition'
      });
    }
  });

  // ===== AI 欄位對應 API =====

  // 分析工作表欄位並建議對應
  app.post('/api/worksheets/:id/analyze-fields', async (req, res) => {
    try {
      const { id } = req.params;
      const { googleColumns, supabaseTable } = req.body;

      if (!googleColumns || !Array.isArray(googleColumns)) {
        return res.status(400).json({
          success: false,
          error: 'googleColumns array is required'
        });
      }

      if (!supabaseTable) {
        return res.status(400).json({
          success: false,
          error: 'supabaseTable is required'
        });
      }

      // 取得目標表的欄位
      const { SUPABASE_SCHEMAS } = await import('./services/ai-field-mapper');
      const schema = SUPABASE_SCHEMAS[supabaseTable];

      if (!schema) {
        return res.status(400).json({
          success: false,
          error: `Unknown table: ${supabaseTable}. Available: ${Object.keys(SUPABASE_SCHEMAS).join(', ')}`
        });
      }

      const supabaseColumns = schema.columns.map(col => col.name);

      // 建立 AI Field Mapper 並分析
      const { createAIFieldMapper } = await import('./services/ai-field-mapper');
      const mapper = createAIFieldMapper();

      const worksheet = await storage.getWorksheet(id);
      const worksheetName = worksheet?.worksheetName || 'Unknown';

      const analysis = await mapper.analyzeAndSuggest(
        googleColumns,
        supabaseColumns,
        supabaseTable,
        worksheetName
      );

      res.json({
        success: true,
        data: analysis
      });

    } catch (error: any) {
      console.error('Error analyzing fields:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to analyze fields'
      });
    }
  });

  // 取得可用的表 schemas
  app.get('/api/field-mapping/schemas', async (req, res) => {
    try {
      const { SUPABASE_SCHEMAS } = await import('./services/ai-field-mapper');
      const schemas = Object.keys(SUPABASE_SCHEMAS);

      res.json({
        success: true,
        data: schemas
      });
    } catch (error: any) {
      console.error('Error fetching schemas:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch schemas'
      });
    }
  });

  // 取得特定表的 schema
  app.get('/api/field-mapping/schemas/:tableName', async (req, res) => {
    try {
      const { tableName } = req.params;
      const { SUPABASE_SCHEMAS } = await import('./services/ai-field-mapper');
      const schema = SUPABASE_SCHEMAS[tableName];

      if (!schema) {
        return res.status(404).json({
          success: false,
          error: `Schema not found for table: ${tableName}`
        });
      }

      res.json({
        success: true,
        data: schema
      });
    } catch (error: any) {
      console.error('Error fetching schema:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch schema'
      });
    }
  });

  // 儲存欄位對應
  app.post('/api/worksheets/:id/save-mapping', async (req, res) => {
    try {
      const { id } = req.params;
      const { supabaseTable, mappings } = req.body;

      if (!supabaseTable || !mappings || !Array.isArray(mappings)) {
        return res.status(400).json({
          success: false,
          error: 'supabaseTable and mappings array are required'
        });
      }

      const supabase = getSupabaseClient();
      if (!supabase) {
        return res.status(503).json({
          success: false,
          error: 'Supabase not available'
        });
      }

      // 刪除舊的對應（如果存在）
      await supabase
        .from('field_mappings')
        .delete()
        .eq('worksheet_id', id);

      // 插入新的對應
      const mappingRecords = mappings.map((m: any) => ({
        worksheet_id: id,
        google_column: m.googleColumn,
        supabase_column: m.supabaseColumn,
        data_type: m.dataType,
        transform_function: m.transformFunction || null,
        is_required: m.isRequired || false,
        ai_confidence: m.confidence,
        ai_reasoning: m.reasoning,
        is_confirmed: true,
        confirmed_by: 'user',
        confirmed_at: new Date().toISOString()
      }));

      const { error: insertError } = await supabase
        .from('field_mappings')
        .insert(mappingRecords);

      if (insertError) {
        throw insertError;
      }

      res.json({
        success: true,
        data: {
          worksheetId: id,
          supabaseTable,
          mappingsCount: mappings.length
        }
      });

    } catch (error: any) {
      console.error('Error saving mappings:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to save mappings'
      });
    }
  });

  // 取得已儲存的欄位對應
  app.get('/api/worksheets/:id/mapping', async (req, res) => {
    try {
      const { id } = req.params;

      const supabase = getSupabaseClient();
      if (!supabase) {
        return res.status(503).json({
          success: false,
          error: 'Supabase not available'
        });
      }

      const { data, error } = await supabase
        .from('field_mappings')
        .select('*')
        .eq('worksheet_id', id)
        .eq('is_active', true);

      if (error) {
        throw error;
      }

      res.json({
        success: true,
        data: data || []
      });

    } catch (error: any) {
      console.error('Error fetching mappings:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to fetch mappings'
      });
    }
  });
  // ===== AI Insights API Routes =====

  // AI 卡片資料 API
  app.get('/api/ai/insights', isAuthenticated, async (req, res) => {
    try {
      // 動態 import AI Chat Service
      const { aiChatService } = await import('./services/ai-chat-service');

      // 取得本月資料
      const today = new Date();
      const dateRange = {
        start: `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`,
        end: `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`,
      };

      const warnings: string[] = [];
      const { totalReportService } = await import('./services/reporting/total-report-service');
      const { attendanceData, purchaseData, eodsData } = await totalReportService.fetchRawData(
        dateRange,
        warnings
      );

      // 計算各種統計資料
      const teachers = (aiChatService as any).calculateTeacherStats(attendanceData, purchaseData, eodsData);
      const consultants = (aiChatService as any).calculateConsultantStats(eodsData);
      const revenue = (aiChatService as any).calculateRevenue(eodsData);
      const students = (aiChatService as any).calculateStudentStats(attendanceData, purchaseData, eodsData);

      res.json({
        success: true,
        data: {
          topTeachers: teachers.slice(0, 3),
          topConsultants: consultants.slice(0, 3),
          revenue,
          students,
          dataQuality: {
            warnings,
            attendanceCount: attendanceData.length,
            purchaseCount: purchaseData.length,
            dealsCount: eodsData.length,
          },
        },
      });
    } catch (error: any) {
      console.error('AI Insights error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI 洞察失敗',
      });
    }
  });

  // ===== AI Chat API Routes =====

  // AI 對話 API
  app.post('/api/ai/chat', isAuthenticated, async (req, res) => {
    try {
      const { question, history } = req.body;

      if (!question || typeof question !== 'string') {
        return res.status(400).json({
          success: false,
          error: 'Invalid question',
        });
      }

      // 動態 import AI Chat Service
      const { aiChatService } = await import('./services/ai-chat-service');

      const response = await aiChatService.chat(question, history || []);

      res.json({
        success: true,
        data: response,
      });
    } catch (error: any) {
      console.error('AI Chat error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI 對話失敗',
      });
    }
  });

  // ===== Raw Data MVP API Routes =====

  // MVP 總報表 API（使用 raw_data）
  app.get('/api/reports/raw-data-mvp', async (req, res) => {
    try {
      const { period = 'monthly' } = req.query;
      const rawDataService = await import('./services/raw-data-query-service');

      const [kpis, teacherStats, pipeline] = await Promise.all([
        rawDataService.calculateKPIs(period as any),
        rawDataService.getTeacherStats(),
        rawDataService.getStudentPipeline()
      ]);

      res.json({
        success: true,
        data: {
          kpis,
          teacherStats: teacherStats.slice(0, 3), // TOP 3
          pipeline
        },
        metadata: {
          dataSource: 'raw_data',
          queryTime: Date.now(),
          period
        }
      });
    } catch (error: any) {
      console.error('Raw data MVP error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // 跨表查詢 API
  app.post('/api/raw-data/cross-table-query', async (req, res) => {
    try {
      const { teacher, status, month, package: pkg, minIntention } = req.body;
      const rawDataService = await import('./services/raw-data-query-service');

      const result = await rawDataService.crossTableQuery({
        teacher,
        status,
        month,
        package: pkg,
        minIntention
      });

      res.json({
        success: true,
        data: result,
        count: result.length
      });
    } catch (error: any) {
      console.error('Cross table query error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // AI 對話 API（針對 raw_data 優化）
  app.post('/api/ai/chat-raw-data', async (req, res) => {
    try {
      const { question, context } = req.body;

      if (!question) {
        return res.status(400).json({
          success: false,
          error: '請輸入問題'
        });
      }

      const rawDataService = await import('./services/raw-data-query-service');

      // 分析問題，決定使用哪種查詢方式
      const lowerQ = question.toLowerCase();
      let data: any = {};
      let queryType = 'simple';

      // 檢測上課記錄查詢
      if (lowerQ.includes('上課') || lowerQ.includes('幾位學生')) {
        queryType = 'attendance';

        // 提取時間範圍
        let timeFilter = undefined;
        if (lowerQ.includes('本週') || lowerQ.includes('這週')) {
          const now = new Date();
          const dayOfWeek = now.getDay();
          const startOfWeek = new Date(now);
          startOfWeek.setDate(now.getDate() - dayOfWeek);
          timeFilter = startOfWeek.toISOString().slice(0, 10);
        } else if (lowerQ.includes('本月') || lowerQ.includes('這個月')) {
          timeFilter = new Date().toISOString().slice(0, 7);
        }

        const attendanceData = await rawDataService.fetchRawData('trial_class_attendance');

        // 過濾時間並提取學生資訊
        let filtered = attendanceData;
        if (timeFilter) {
          filtered = attendanceData.filter((row: any) => {
            const date = row.raw_data?.['上課日期'] || row.raw_data?.['Date'] || row.class_date;
            return date && date.toString().startsWith(timeFilter);
          });
        }

        // 統計唯一學生
        const uniqueStudents = new Set();
        data.students = filtered.map((row: any) => {
          const rawData = row.raw_data || {};
          const studentName = rawData['學員姓名'] || rawData['Name'] || rawData['student_name'] || 'Unknown';
          const studentEmail = row.student_email || rawData['Email'] || rawData['email'];

          uniqueStudents.add(studentEmail || studentName);

          return {
            studentName,
            studentEmail,
            classDate: rawData['上課日期'] || rawData['Date'] || row.class_date,
            teacher: rawData['老師'] || rawData['Teacher'] || row.teacher,
            package: rawData['課程'] || rawData['Course'],
            rawData
          };
        });

        data.uniqueCount = uniqueStudents.size;
      }
      // 檢測跨表查詢關鍵字
      else if (lowerQ.includes('升高階') || lowerQ.includes('轉換') ||
          (lowerQ.includes('老師') && (lowerQ.includes('學生') || lowerQ.includes('成交'))) ||
          lowerQ.includes('買課') || lowerQ.includes('有買') || lowerQ.includes('購買')) {
        queryType = 'cross-table';

        // 提取參數
        const teacherMatch = question.match(/(vicky|karen|elena)/i);
        const teacher = teacherMatch ? teacherMatch[1].charAt(0).toUpperCase() + teacherMatch[1].slice(1) : undefined;
        const month = lowerQ.includes('本月') ? new Date().toISOString().slice(0, 7) : undefined;

        data.students = await rawDataService.crossTableQuery({
          teacher,
          status: lowerQ.includes('升高階') ? '已轉高' : undefined,
          month
        });
      } else {
        // 簡單查詢，取相關表資料
        queryType = 'simple';

        if (lowerQ.includes('老師') || lowerQ.includes('教師')) {
          data.teacherStats = await rawDataService.getTeacherStats();
        }

        if (lowerQ.includes('kpi') || lowerQ.includes('轉換') || lowerQ.includes('營收')) {
          data.kpis = await rawDataService.calculateKPIs();
        }
      }

      // 簡化的回答（直接回傳資料）
      let answer = '';

      if (data.students && queryType === 'attendance') {
        const total = data.students.length;
        const uniqueCount = data.uniqueCount || total;

        answer = `根據資料分析，共有 ${uniqueCount} 位學生上課（${total} 堂課）：\n\n`;

        data.students.slice(0, 10).forEach((s: any) => {
          answer += `• ${s.studentName}`;
          if (s.teacher) answer += ` - ${s.teacher} 老師`;
          if (s.classDate) answer += ` (${s.classDate})`;
          answer += `\n`;
        });

        if (total > 10) {
          answer += `\n... 還有 ${total - 10} 堂課\n`;
        }

        answer += `\n總計：${uniqueCount} 位學生，${total} 堂課`;
      } else if (data.students) {
        const total = data.students.length;
        const totalAmount = data.students.reduce((sum: number, s: any) => sum + (s.amount || 0), 0);

        answer = `根據資料分析，共有 ${total} 位學生符合條件：\n\n`;

        data.students.slice(0, 10).forEach((s: any) => {
          answer += `• ${s.studentName} - ${s.package} (NT$ ${s.amount?.toLocaleString() || 0})\n`;
        });

        if (total > 10) {
          answer += `\n... 還有 ${total - 10} 位學生\n`;
        }

        answer += `\n總計：${total} 位，總金額 NT$ ${totalAmount.toLocaleString()}`;
      } else if (data.kpis) {
        answer = `目前 KPI 數據：\n`;
        answer += `• 轉換率：${data.kpis.conversionRate.toFixed(1)}%\n`;
        answer += `• 體驗課完成率：${data.kpis.trialCompletionRate.toFixed(1)}%\n`;
        answer += `• 總營收：NT$ ${data.kpis.totalRevenue.toLocaleString()}`;
      } else if (data.teacherStats) {
        answer = `教師績效統計：\n\n`;
        data.teacherStats.slice(0, 3).forEach((t: any, i: number) => {
          answer += `${i + 1}. ${t.name}\n`;
          answer += `   授課數：${t.classCount}\n`;
          answer += `   學生數：${t.studentCount}\n\n`;
        });
      } else {
        answer = '抱歉，我無法理解您的問題。請嘗試更具體的問法。';
      }

      res.json({
        success: true,
        answer,
        data: data.students || data.kpis || data.teacherStats || [],
        queryType,
        dataUsed: Object.keys(data).length
      });

    } catch (error: any) {
      console.error('AI chat raw data error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  // AI 智能學習查詢端點
  app.post('/api/ai/smart-query', async (req, res) => {
    try {
      const { question, teacherId } = req.body;

      if (!question) {
        return res.status(400).json({
          success: false,
          error: '請輸入問題'
        });
      }

      const aiLearning = await import('./services/ai-query-learning-service');

      console.log('🎯 Smart Query:', { question, teacherId });

      // 1. 檢查是否已經學過類似問題
      const learned = await aiLearning.checkLearnedPattern(question, teacherId);

      if (learned) {
        // 已學過，直接執行查詢
        console.log('✅ 使用學習記錄');
        console.log('🔍 執行查詢:', learned.query_config);

        // 確保 query_config 是物件（如果是字串則解析）
        const queryConfig = typeof learned.query_config === 'string'
          ? JSON.parse(learned.query_config)
          : learned.query_config;

        const queryResult = await aiLearning.executeQueryFromAnalysis(
          queryConfig,
          teacherId
        );

        const answer = aiLearning.formatAnswer(queryResult, queryConfig);

        return res.json({
          success: true,
          answer,
          data: queryResult.students || queryResult.data || [],
          learned: true,
          usageCount: learned.usage_count,
          intent: learned.intent
        });
      }

      // 2. 新問題，使用 AI 分析
      console.log('🤖 新問題，呼叫 OpenAI 分析...');
      const analysis = await aiLearning.analyzeQuestion(question, teacherId);

      // 3. 執行查詢
      const queryResult = await aiLearning.executeQueryFromAnalysis(analysis, teacherId);
      const answer = aiLearning.formatAnswer(queryResult, analysis);

      // 4. 返回結果，但需要使用者確認
      res.json({
        success: true,
        answer,
        data: queryResult.students || queryResult.data || [],
        needConfirmation: true,
        analysis: {
          intent: analysis.intent,
          explanation: analysis.explanation,
          confidence: analysis.confidence
        },
        queryResult
      });

    } catch (error: any) {
      console.error('❌ Smart query error:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'AI 查詢失敗'
      });
    }
  });

  // 確認並儲存學習
  app.post('/api/ai/confirm-learning', async (req, res) => {
    try {
      const { question, analysis, teacherId, confirmed } = req.body;

      if (!question || !analysis) {
        return res.status(400).json({
          success: false,
          error: '缺少必要參數'
        });
      }

      const aiLearning = await import('./services/ai-query-learning-service');

      if (confirmed) {
        // 儲存學習結果
        await aiLearning.saveLearnedQuery(question, analysis, teacherId);

        return res.json({
          success: true,
          message: '✅ 已記住！下次遇到類似問題就不用再確認了'
        });
      } else {
        return res.json({
          success: true,
          message: '請重新描述您的問題'
        });
      }
    } catch (error: any) {
      console.error('❌ Confirm learning error:', error);
      res.status(500).json({
        success: false,
        error: error.message || '儲存學習失敗'
      });
    }
  });

  // ==================== 成本獲利分析 API ====================

  // 取得指定月份資料
  app.get('/api/cost-profit/records', isAuthenticated, requireModulePermission('cost_profit'), async (req, res) => {
    try {
      const schema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
      });

      const parsed = schema.safeParse(req.query);
      if (!parsed.success) {
        return res.status(400).json({ error: '缺少或格式錯誤的 year / month 參數' });
      }

      const { costProfitService } = await import('./services/cost-profit-service');
      const records = await costProfitService.getRecordsByPeriod(parsed.data.year, parsed.data.month);
      res.json({ success: true, data: records });
    } catch (error: any) {
      console.error('成本獲利資料查詢錯誤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // 產生 AI 預測
  app.get('/api/cost-profit/prediction', async (req, res) => {
    try {
      const schema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
      });

      const parsed = schema.safeParse(req.query);
      if (!parsed.success) {
        return res.status(400).json({ error: '缺少或格式錯誤的 year / month 參數' });
      }

      try {
        const { generateCostProfitPrediction } = await import('./services/cost-profit-ai-service');
        const suggestions = await generateCostProfitPrediction({
          year: parsed.data.year,
          month: parsed.data.month,
        });
        res.json({ success: true, data: suggestions });
      } catch (error: any) {
        console.error('成本獲利 AI 預測錯誤:', error);
        res.status(200).json({
          success: true,
          data: [],
          warning: 'AI 預測失敗或未設定，已返回空結果',
        });
      }
    } catch (error: any) {
      console.error('成本獲利 AI 預測錯誤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // 儲存指定月份資料
  app.post('/api/cost-profit/save', async (req, res) => {
    try {
      const recordSchema = z.object({
        category_name: z.string().min(1),
        item_name: z.string().min(1),
        amount: z
          .union([z.number(), z.string(), z.null()])
          .transform((value) => {
            if (value === null || value === '') return null;
            const num = Number(value);
            return Number.isFinite(num) ? num : null;
          }),
        currency: z.enum(['TWD', 'USD', 'RMB']).optional().default('TWD'),
        exchange_rate_used: z.number().optional(),
        amount_in_twd: z.number().optional(),
        notes: z.union([z.string(), z.null()]).optional(),
        is_confirmed: z.coerce.boolean().optional(),
      });

      const bodySchema = z.object({
        year: z.coerce.number().int().min(2000),
        month: z.string().min(1),
        records: z.array(recordSchema),
      });

      const parsed = bodySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: '提交內容格式錯誤', details: parsed.error.format() });
      }

      const { costProfitService } = await import('./services/cost-profit-service');
      await costProfitService.saveMonthlyRecords({
        year: parsed.data.year,
        month: parsed.data.month,
        records: parsed.data.records.map((record) => ({
          category_name: record.category_name,
          item_name: record.item_name,
          amount: record.amount,
          currency: record.currency ?? 'TWD',
          exchange_rate_used: record.exchange_rate_used ?? null,
          amount_in_twd: record.amount_in_twd ?? null,
          notes: record.notes ?? null,
          is_confirmed: record.is_confirmed ?? false,
        })),
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error('成本獲利儲存錯誤:', error);
      res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
  });

  // 獲取所有成本獲利數據
  app.get('/api/cost-profit', async (req, res) => {
    try {
      const { costProfitService } = await import('./services/cost-profit-service');
      const data = await costProfitService.getAllRecords();
      res.json(data);
    } catch (error: any) {
      console.error('成本獲利 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 獲取成本獲利摘要統計
  app.get('/api/cost-profit/summary', async (req, res) => {
    try {
      const { month, year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const summary = await costProfitService.getSummary(
        year ? parseInt(year as string) : undefined,
        month as string | undefined
      );

      res.json(summary);
    } catch (error: any) {
      console.error('成本獲利摘要 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 獲取月度對比
  app.get('/api/cost-profit/monthly-comparison', async (req, res) => {
    try {
      const { year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const result = await costProfitService.getMonthlyComparison(
        year ? parseInt(year as string) : undefined
      );

      res.json(result);
    } catch (error: any) {
      console.error('月度對比 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 獲取分類統計
  app.get('/api/cost-profit/category-stats', async (req, res) => {
    try {
      const { month, year } = req.query;
      const { costProfitService } = await import('./services/cost-profit-service');

      const stats = await costProfitService.getCategoryStats(
        year ? parseInt(year as string) : undefined,
        month as string | undefined
      );

      res.json(stats);
    } catch (error: any) {
      console.error('分類統計 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // 表單填寫 API
  // ========================================

  // 取得老師名單（從 users 表查詢 roles 包含 'teacher'）- 支援多重角色
  app.get('/api/teachers', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'teacher' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      // 組合姓名（只用 first_name，不包含 last_name「老師」）
      const teachers = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles  // 返回所有角色資訊
      }));

      res.json(teachers);
    } catch (error: any) {
      console.error('老師名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得電訪人員名單（從 users 表查詢 roles 包含 'setter'）
  app.get('/api/setters', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'setter' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const setters = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(setters);
    } catch (error: any) {
      console.error('電訪人員名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得諮詢人員名單（從 users 表查詢 roles 包含 'consultant'）
  app.get('/api/consultants', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'consultant' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const consultants = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(consultants);
    } catch (error: any) {
      console.error('諮詢人員名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得真工名單（從 users 表查詢 roles 包含 'employee'）
  app.get('/api/staff', async (req, res) => {
    try {
      const result = await queryDatabase(
        `SELECT id, first_name, last_name, email, roles
         FROM users
         WHERE 'employee' = ANY(roles)
         AND status = 'active'
         ORDER BY first_name ASC`
      );

      const staff = result.rows.map(user => ({
        id: user.id,
        name: user.first_name || user.email || user.id,
        roles: user.roles
      }));

      res.json(staff);
    } catch (error: any) {
      console.error('真工名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // 體驗課打卡記錄 API - 已遷移至 Form Builder 系統
  // 請使用 /api/forms/custom/trial-class-form-001 系列 API
  // ========================================

  // ========================================
  // 諮詢記錄表單 API
  // ========================================

  // POST - Submit new consultation record
  app.post('/api/forms/consultation', async (req, res) => {
    try {
      const {
        studentName,
        studentEmail,
        callerName,
        closerName,
        isOnline,
        leadSource,
        consultationResult,
        dealPackage,
        packageQuantity,
        paymentMethod,
        installmentPeriods,
        packagePrice,
        actualAmount,
        consultationDate,
        dealDate,
        notes,
      } = req.body;

      // Validate required fields
      if (!studentName || !closerName || !consultationResult || !consultationDate) {
        return res.status(400).json({ error: '缺少必填欄位' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      // Calculate month, year, week number
      const consultDate = new Date(consultationDate);
      const month = consultDate.getMonth() + 1;
      const year = consultDate.getFullYear();

      // Calculate week number (ISO week)
      const firstDayOfYear = new Date(year, 0, 1);
      const pastDaysOfYear = (consultDate.getTime() - firstDayOfYear.getTime()) / 86400000;
      const weekNumber = Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);

      // Insert into eods_for_closers table
      const { data, error } = await supabase
        .from('eods_for_closers')
        .insert({
          student_name: studentName,
          student_email: studentEmail || null,
          setter_name: callerName || null,
          closer_name: closerName,
          is_show: isOnline || null,
          lead_source: leadSource || null,
          consultation_result: consultationResult,
          plan: dealPackage || null,
          package_quantity: packageQuantity ? parseFloat(packageQuantity) : null,
          payment_method: paymentMethod || null,
          installment_periods: installmentPeriods ? parseInt(installmentPeriods) : null,
          package_price: packagePrice ? parseFloat(packagePrice) : null,
          actual_amount: actualAmount ? parseFloat(actualAmount) : null,
          consultation_date: new Date(consultationDate).toISOString(),
          deal_date: dealDate ? new Date(dealDate).toISOString() : null,
          notes: notes || null,
          submitted_at: new Date().toISOString(),
          month,
          year,
          week_number: weekNumber,
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase 插入錯誤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: '諮詢記錄已成功提交',
        data,
      });
    } catch (error: any) {
      console.error('諮詢表單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - List consultation records with pagination
  app.get('/api/forms/consultation', async (req, res) => {
    try {
      const { page = '1', limit = '10' } = req.query;
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data, error, count } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact' })
        .order('consultation_date', { ascending: false })
        .order('created_at', { ascending: false })
        .range((pageNum - 1) * limitNum, pageNum * limitNum - 1);

      if (error) {
        console.error('Supabase 查詢錯誤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('諮詢查詢 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - Statistics (today/week/month counts)
  app.get('/api/forms/consultation/stats', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      const { count: todayCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', today);

      const { count: weekCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', weekAgo);

      const { count: monthCount } = await supabase
        .from('eods_for_closers')
        .select('*', { count: 'exact', head: true })
        .gte('consultation_date', monthAgo);

      res.json({
        today: todayCount || 0,
        week: weekCount || 0,
        month: monthCount || 0,
      });
    } catch (error: any) {
      console.error('諮詢統計 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // 電訪記錄表單 API
  // ========================================

  // POST - Submit new telemarketing call record
  app.post('/api/forms/telemarketing', async (req, res) => {
    try {
      const {
        studentName,
        studentPhone,
        studentEmail,
        callerName,
        callDate,
        callTime,
        callDuration,
        callResult,
        contactStatus,
        scheduledCallbackDate,
        interestLevel,
        interestedPackage,
        budgetRange,
        forwardedToConsultant,
        consultantName,
        notes,
      } = req.body;

      // Validate required fields
      if (!studentName || !studentPhone || !callerName || !callResult || !callDate) {
        return res.status(400).json({ error: '缺少必填欄位' });
      }

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      // Convert call duration from minutes to seconds
      const durationInSeconds = callDuration ? parseInt(callDuration) * 60 : null;

      // Insert into telemarketing_calls table
      const { data, error } = await supabase
        .from('telemarketing_calls')
        .insert({
          student_name: studentName,
          student_phone: studentPhone,
          student_email: studentEmail || null,
          caller_name: callerName,
          call_date: new Date(callDate).toISOString(),
          call_time: callTime || null,
          call_duration: durationInSeconds,
          call_result: callResult,
          contact_status: contactStatus || null,
          scheduled_callback_date: scheduledCallbackDate
            ? new Date(scheduledCallbackDate).toISOString()
            : null,
          interest_level: interestLevel || null,
          interested_package: interestedPackage || null,
          budget_range: budgetRange || null,
          forwarded_to_consultant: forwardedToConsultant || false,
          consultant_name: consultantName || null,
          notes: notes || null,
          raw_data: {
            source: 'form_submission',
            submitted_at: new Date().toISOString(),
          },
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase 插入錯誤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: '電訪記錄已成功提交',
        data,
      });
    } catch (error: any) {
      console.error('電訪表單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - List telemarketing call records with pagination
  app.get('/api/forms/telemarketing', async (req, res) => {
    try {
      const { page = '1', limit = '10' } = req.query;
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data, error, count } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact' })
        .order('call_date', { ascending: false })
        .order('created_at', { ascending: false })
        .range((pageNum - 1) * limitNum, pageNum * limitNum - 1);

      if (error) {
        console.error('Supabase 查詢錯誤:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('電訪查詢 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - Statistics (today/week/month counts)
  app.get('/api/forms/telemarketing/stats', async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      const { count: todayCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', today);

      const { count: weekCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', weekAgo);

      const { count: monthCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', monthAgo);

      res.json({
        today: todayCount || 0,
        week: weekCount || 0,
        month: monthCount || 0,
      });
    } catch (error: any) {
      console.error('電訪統計 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // 電訪記錄管理 API
  // ========================================

  // GET - 查詢所有電訪記錄
  app.get('/api/telemarketing/calls', isAuthenticated, requireModulePermission('telemarketing_system'), async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data: calls, error } = await supabase
        .from('telemarketing_calls')
        .select('*')
        .order('call_date', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) {
        console.error('查詢電訪記錄失敗:', error);
        throw error;
      }

      res.json(calls || []);
    } catch (error: any) {
      console.error('電訪記錄 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - 電訪記錄統計資料
  app.get('/api/telemarketing/calls/stats', isAuthenticated, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      // 總記錄數
      const { count: total } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true });

      // 今日記錄
      const { count: todayCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', today);

      // 本週記錄
      const { count: weekCount } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .gte('call_date', weekAgo);

      // 已接通數
      const { count: connected } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('call_result', '已接通');

      // 有意願數
      const { count: interested } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('interest_level', '高');

      // 已轉諮詢數
      const { count: forwarded } = await supabase
        .from('telemarketing_calls')
        .select('*', { count: 'exact', head: true })
        .eq('forwarded_to_consultant', true);

      res.json({
        total: total || 0,
        today: todayCount || 0,
        this_week: weekCount || 0,
        connected: connected || 0,
        interested: interested || 0,
        forwarded: forwarded || 0,
      });
    } catch (error: any) {
      console.error('電訪統計 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ========================================
  // 廣告名單系統 API (Facebook Lead Ads)
  // ========================================

  // Webhook - 接收 Facebook Lead Ads 名單
  app.post('/api/webhooks/facebook-leads', async (req, res) => {
    try {
      const { object, entry } = req.body;

      // 驗證是否為 Facebook page webhook
      if (object !== 'page') {
        return res.status(400).json({ error: 'Invalid webhook object type' });
      }

      if (!isSupabaseAvailable()) {
        console.error('⚠️  Supabase 未連線，無法儲存 Facebook 名單');
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();
      const insertedLeads = [];

      // 處理每個 entry（可能有多個名單）
      for (const entryItem of entry) {
        const changes = entryItem.changes || [];

        for (const change of changes) {
          if (change.field === 'leadgen') {
            const leadgenData = change.value;
            const {
              leadgen_id,
              ad_id,
              ad_name,
              form_id,
              form_name,
              campaign_id,
              campaign_name,
              created_time,
              field_data,
            } = leadgenData;

            // 解析表單欄位資料
            const fieldMap: Record<string, string> = {};
            if (field_data && Array.isArray(field_data)) {
              field_data.forEach((field: any) => {
                fieldMap[field.name] = field.values?.[0] || '';
              });
            }

            // 提取姓名、電話、Email
            const studentName = fieldMap['姓名'] || fieldMap['full_name'] || fieldMap['name'] || '';
            const studentPhone = fieldMap['電話'] || fieldMap['phone_number'] || fieldMap['phone'] || '';
            const studentEmail = fieldMap['Email'] || fieldMap['email'] || '';

            // 驗證必填欄位
            if (!studentName || !studentPhone) {
              console.warn('⚠️  名單缺少姓名或電話，跳過:', leadgen_id);
              continue;
            }

            // 檢查是否已存在（防止重複）
            const { data: existingLead } = await supabase
              .from('ad_leads')
              .select('id')
              .eq('leadgen_id', leadgen_id)
              .single();

            if (existingLead) {
              console.log(`ℹ️  名單已存在，跳過: ${leadgen_id}`);
              continue;
            }

            // 插入新名單
            const { data: newLead, error } = await supabase
              .from('ad_leads')
              .insert({
                leadgen_id,
                ad_id,
                ad_name,
                campaign_id,
                campaign_name,
                form_id,
                form_name,
                student_name: studentName,
                student_phone: studentPhone,
                student_email: studentEmail || null,
                claim_status: 'unclaimed',
                contact_status: 'pending',
                stage1_status: 'pending',
                stage2_status: 'pending',
                stage3_status: 'pending',
                raw_data: {
                  facebook_data: leadgenData,
                  field_map: fieldMap,
                  received_at: new Date().toISOString(),
                },
              })
              .select()
              .single();

            if (error) {
              console.error('❌ 插入名單失敗:', error);
              continue;
            }

            insertedLeads.push(newLead);
            console.log(`✅ 新增廣告名單: ${studentName} (${studentPhone})`);
          }
        }
      }

      res.json({
        success: true,
        message: `成功接收 ${insertedLeads.length} 筆名單`,
        count: insertedLeads.length,
      });
    } catch (error: any) {
      console.error('Facebook webhook 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Webhook 驗證端點（Facebook 訂閱驗證）
  app.get('/api/webhooks/facebook-leads', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    // 驗證 token（需要在環境變數設定 FACEBOOK_VERIFY_TOKEN）
    const VERIFY_TOKEN = process.env.FACEBOOK_VERIFY_TOKEN || 'singple_webhook_2024';

    if (mode === 'subscribe' && token === VERIFY_TOKEN) {
      console.log('✅ Facebook webhook 驗證成功');
      res.status(200).send(challenge);
    } else {
      console.error('❌ Facebook webhook 驗證失敗');
      res.sendStatus(403);
    }
  });

  // GET - 取得廣告名單列表（支援篩選）
  app.get('/api/leads/ad-leads', isAuthenticated, async (req, res) => {
    try {
      const {
        claim_status,
        stage1_status,
        stage2_status,
        claimed_by,
        start_date,
        end_date,
        page = '1',
        limit = '20',
      } = req.query;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();
      let query = supabase.from('ad_leads').select('*', { count: 'exact' });

      // 篩選條件
      if (claim_status) query = query.eq('claim_status', claim_status);
      if (stage1_status) query = query.eq('stage1_status', stage1_status);
      if (stage2_status) query = query.eq('stage2_status', stage2_status);
      if (claimed_by) query = query.eq('claimed_by', claimed_by);
      if (start_date) query = query.gte('created_at', start_date);
      if (end_date) query = query.lte('created_at', end_date);

      // 分頁
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);
      const offset = (pageNum - 1) * limitNum;
      query = query.range(offset, offset + limitNum - 1);

      // 排序（最新優先）
      query = query.order('created_at', { ascending: false });

      const { data, error, count } = await query;

      if (error) {
        console.error('查詢名單失敗:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limitNum),
        },
      });
    } catch (error: any) {
      console.error('廣告名單列表 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // PATCH - 認領名單
  app.patch('/api/leads/ad-leads/:id/claim', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = (req as any).user;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      // 檢查名單是否存在且未被認領
      const { data: lead } = await supabase
        .from('ad_leads')
        .select('id, claim_status')
        .eq('id', id)
        .single();

      if (!lead) {
        return res.status(404).json({ error: '找不到此名單' });
      }

      if (lead.claim_status === 'claimed') {
        return res.status(400).json({ error: '此名單已被認領' });
      }

      // 認領名單
      const { data, error } = await supabase
        .from('ad_leads')
        .update({
          claim_status: 'claimed',
          claimed_by: user.first_name || user.email,
          claimed_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('認領名單失敗:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: '認領成功',
        data,
      });
    } catch (error: any) {
      console.error('認領名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // PATCH - 更新名單狀態
  app.patch('/api/leads/ad-leads/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      // 更新名單
      const { data, error } = await supabase
        .from('ad_leads')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('更新名單失敗:', error);
        return res.status(500).json({ error: error.message });
      }

      res.json({
        success: true,
        message: '更新成功',
        data,
      });
    } catch (error: any) {
      console.error('更新名單 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - 廣告成效報表（兩階段轉換率）
  app.get('/api/reports/ad-performance', isAuthenticated, async (req, res) => {
    try {
      const {
        start_date,
        end_date,
        campaign_id,
        groupBy = 'campaign', // 'campaign' or 'daily'
      } = req.query;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      // 建立基本查詢
      let query = supabase.from('ad_leads').select('*');

      // 時間篩選（預設本週）
      if (start_date) {
        query = query.gte('created_at', start_date);
      } else {
        // 預設本週一
        const monday = new Date();
        monday.setDate(monday.getDate() - monday.getDay() + 1);
        monday.setHours(0, 0, 0, 0);
        query = query.gte('created_at', monday.toISOString());
      }

      if (end_date) {
        query = query.lte('created_at', end_date);
      }

      if (campaign_id) {
        query = query.eq('campaign_id', campaign_id);
      }

      const { data: leads, error } = await query;

      if (error) {
        console.error('查詢廣告成效失敗:', error);
        return res.status(500).json({ error: error.message });
      }

      // 計算總覽數據（三階段轉換）
      const totalLeads = leads?.length || 0;

      // 階段 1：預約諮詢（出現在 EOD）
      const stage1Converted = leads?.filter(l => l.stage1_status === 'scheduled').length || 0;

      // 階段 2：是否上線
      const stage2Converted = leads?.filter(l => l.stage2_status === 'showed').length || 0;

      // 階段 3：高階課程成交
      const stage3Converted = leads?.filter(l => l.stage3_status === 'converted').length || 0;
      const trialOnlyCount = leads?.filter(l => l.stage3_status === 'trial_only').length || 0;

      const totalRevenue = leads?.reduce((sum, l) => sum + (parseFloat(l.deal_amount) || 0), 0) || 0;

      const stage1ConversionRate = totalLeads > 0 ? (stage1Converted / totalLeads) * 100 : 0;
      const stage2ConversionRate = stage1Converted > 0 ? (stage2Converted / stage1Converted) * 100 : 0;
      const stage3ConversionRate = stage2Converted > 0 ? (stage3Converted / stage2Converted) * 100 : 0;
      const overallConversionRate = totalLeads > 0 ? (stage3Converted / totalLeads) * 100 : 0;

      // 按廣告活動分組統計
      const campaignStats: Record<string, any> = {};
      leads?.forEach(lead => {
        const campaignName = lead.campaign_name || '未知廣告活動';
        if (!campaignStats[campaignName]) {
          campaignStats[campaignName] = {
            campaign_name: campaignName,
            campaign_id: lead.campaign_id,
            total_leads: 0,
            stage1_converted: 0,
            stage2_converted: 0,
            stage3_converted: 0,
            trial_only: 0,
            total_revenue: 0,
          };
        }

        campaignStats[campaignName].total_leads += 1;
        if (lead.stage1_status === 'scheduled') {
          campaignStats[campaignName].stage1_converted += 1;
        }
        if (lead.stage2_status === 'showed') {
          campaignStats[campaignName].stage2_converted += 1;
        }
        if (lead.stage3_status === 'converted') {
          campaignStats[campaignName].stage3_converted += 1;
          campaignStats[campaignName].total_revenue += parseFloat(lead.deal_amount) || 0;
        }
        if (lead.stage3_status === 'trial_only') {
          campaignStats[campaignName].trial_only += 1;
        }
      });

      // 計算各廣告活動的轉換率
      const campaignList = Object.values(campaignStats).map((campaign: any) => ({
        ...campaign,
        stage1_conversion_rate: campaign.total_leads > 0
          ? ((campaign.stage1_converted / campaign.total_leads) * 100).toFixed(2)
          : '0.00',
        stage2_conversion_rate: campaign.stage1_converted > 0
          ? ((campaign.stage2_converted / campaign.stage1_converted) * 100).toFixed(2)
          : '0.00',
        stage3_conversion_rate: campaign.stage2_converted > 0
          ? ((campaign.stage3_converted / campaign.stage2_converted) * 100).toFixed(2)
          : '0.00',
        overall_conversion_rate: campaign.total_leads > 0
          ? ((campaign.stage3_converted / campaign.total_leads) * 100).toFixed(2)
          : '0.00',
      }));

      res.json({
        success: true,
        data: {
          summary: {
            total_leads: totalLeads,
            stage1_converted: stage1Converted,
            stage2_converted: stage2Converted,
            stage3_converted: stage3Converted,
            trial_only: trialOnlyCount,
            total_revenue: totalRevenue,
            stage1_conversion_rate: stage1ConversionRate.toFixed(2) + '%',
            stage2_conversion_rate: stage2ConversionRate.toFixed(2) + '%',
            stage3_conversion_rate: stage3ConversionRate.toFixed(2) + '%',
            overall_conversion_rate: overallConversionRate.toFixed(2) + '%',
          },
          campaigns: campaignList,
        },
      });
    } catch (error: any) {
      console.error('廣告成效報表 API 錯誤:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ================================================
  // Custom Forms API - 自訂表單系統
  // ================================================

  const customFormService = await import('./services/custom-form-service');
  const { listSupabaseTables, getTableColumns, getAllTablesInfo } = await import('./services/reporting/introspect-service');

  // 取得所有 Supabase 表（用於下拉選單）
  app.get('/api/database/tables', async (_req, res) => {
    try {
      const tables = await listSupabaseTables();
      res.json({ tables });
    } catch (error: any) {
      console.error('列出資料表失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得指定表的欄位（用於欄位映射）
  app.get('/api/database/tables/:tableName/columns', async (req, res) => {
    try {
      const { tableName } = req.params;
      const columns = await getTableColumns(tableName);
      res.json({ columns });
    } catch (error: any) {
      console.error('取得表欄位失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得所有表和欄位資訊
  app.get('/api/database/schema', async (_req, res) => {
    try {
      const schema = await getAllTablesInfo();
      res.json({ schema });
    } catch (error: any) {
      console.error('取得資料庫 schema 失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - 查詢表格資料
  app.get('/api/database/:tableName/data', async (req, res) => {
    try {
      const { tableName } = req.params;
      const { page = '1', limit = '50', search = '', searchColumn = 'email' } = req.query;

      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);
      const limitNum = parseInt(limit as string);

      let query = `SELECT * FROM ${tableName}`;
      const params: any[] = [];

      // 搜尋功能
      if (search) {
        query += ` WHERE ${searchColumn}::text ILIKE $1`;
        params.push(`%${search}%`);
        query += ` ORDER BY created_at DESC LIMIT $2 OFFSET $3`;
        params.push(limitNum, offset);
      } else {
        query += ` ORDER BY created_at DESC LIMIT $1 OFFSET $2`;
        params.push(limitNum, offset);
      }

      const result = await queryDatabase(query, params);
      const data = result.rows;

      // 取得總筆數
      let countQuery = `SELECT COUNT(*) as total FROM ${tableName}`;
      const countParams: any[] = [];
      if (search) {
        countQuery += ` WHERE ${searchColumn}::text ILIKE $1`;
        countParams.push(`%${search}%`);
      }
      const countResult = await queryDatabase(countQuery, countParams);
      const total = parseInt(countResult.rows[0]?.total || '0');

      res.json({
        success: true,
        data,
        pagination: {
          page: parseInt(page as string),
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum)
        }
      });
    } catch (error: any) {
      console.error('查詢資料失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - 更新單筆資料
  app.put('/api/database/:tableName/:id', async (req, res) => {
    try {
      const { tableName, id } = req.params;
      const updates = req.body;

      const setClause = Object.keys(updates)
        .map((key, index) => `${key} = $${index + 1}`)
        .join(', ');
      const values = Object.values(updates);

      // 檢查表格是否有 updated_at 欄位
      const columnsQuery = `
        SELECT column_name
        FROM information_schema.columns
        WHERE table_name = $1 AND column_name = 'updated_at'
      `;
      const columnsResult = await queryDatabase(columnsQuery, [tableName]);
      const hasUpdatedAt = columnsResult.rows.length > 0;

      // 如果有 updated_at 欄位，自動更新它
      const updatedAtClause = hasUpdatedAt ? ', updated_at = NOW()' : '';

      const query = `
        UPDATE ${tableName}
        SET ${setClause}${updatedAtClause}
        WHERE id = $${values.length + 1}
        RETURNING *
      `;

      const result = await queryDatabase(query, [...values, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: '找不到該筆資料' });
      }

      res.json({ success: true, data: result.rows[0] });
    } catch (error: any) {
      console.error('更新資料失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - 新增資料
  app.post('/api/database/:tableName/data', async (req, res) => {
    try {
      const { tableName } = req.params;
      const data = req.body;

      const result = await insertAndReturn(tableName, data);

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('新增資料失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Database Browser API - 刪除資料
  app.delete('/api/database/:tableName/:id', async (req, res) => {
    try {
      const { tableName, id } = req.params;

      const query = `DELETE FROM ${tableName} WHERE id = $1 RETURNING *`;
      const result = await queryDatabase(query, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: '找不到該筆資料' });
      }

      res.json({ success: true, data: result.rows[0] });
    } catch (error: any) {
      console.error('刪除資料失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 建立自訂表單
  app.post('/api/forms/custom', isAuthenticated, requireAdmin, requireModulePermission('form_builder'), async (req, res) => {
    try {
      const form = await customFormService.createCustomForm(req.body);
      res.json({ success: true, form });
    } catch (error: any) {
      console.error('建立表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得所有表單（可篩選狀態）
  app.get('/api/forms/custom', async (req, res) => {
    try {
      const status = req.query.status as 'active' | 'archived' | undefined;
      const forms = await customFormService.getAllForms(status);
      res.json({ success: true, forms });
    } catch (error: any) {
      console.error('取得表單列表失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得單一表單
  app.get('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const form = await customFormService.getFormById(id);

      if (!form) {
        return res.status(404).json({ error: '找不到指定的表單' });
      }

      res.json({ success: true, form });
    } catch (error: any) {
      console.error('取得表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 更新表單
  app.put('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const form = await customFormService.updateCustomForm(id, req.body);
      res.json({ success: true, form });
    } catch (error: any) {
      console.error('更新表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 封存表單（軟刪除）
  app.post('/api/forms/custom/:id/archive', async (req, res) => {
    try {
      const { id } = req.params;
      await customFormService.archiveForm(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error('封存表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 刪除表單（永久刪除）
  app.delete('/api/forms/custom/:id', async (req, res) => {
    try {
      const { id } = req.params;
      await customFormService.deleteForm(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error('刪除表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 提交表單資料
  app.post('/api/forms/custom/:id/submit', async (req, res) => {
    try {
      const { id } = req.params;
      const result = await customFormService.submitFormData({
        form_id: id,
        data: req.body.data,
        submitted_by: req.body.submitted_by
      });
      res.json({ success: true, ...result });
    } catch (error: any) {
      console.error('提交表單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 取得表單提交記錄
  app.get('/api/forms/custom/:id/submissions', async (req, res) => {
    try {
      const { id } = req.params;
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;

      const submissions = await customFormService.getFormSubmissions(id, { limit, offset });
      const total = await customFormService.countFormSubmissions(id);

      res.json({
        success: true,
        submissions,
        total,
        limit,
        offset
      });
    } catch (error: any) {
      console.error('取得提交記錄失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================================================
  // Public Form APIs (No Authentication Required)
  // 公開表單 API（不需要登入）
  // ============================================================================

  // 公開提交表單資料（不需登入）
  app.post('/api/forms/public/:id/submit', async (req, res) => {
    try {
      const { id } = req.params;
      const result = await customFormService.submitFormData({
        form_id: id,
        data: req.body.data,
        submitted_by: 'public' // 公開表單提交者標記為 public
      });
      res.json({ success: true, ...result });
    } catch (error: any) {
      console.error('公開表單提交失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得公開的老師列表（不需登入）
  app.get('/api/teachers/public', async (req, res) => {
    try {
      const pool = createPool();
      const result = await queryDatabase(
        pool,
        `SELECT DISTINCT first_name as name
         FROM users
         WHERE 'teacher' = ANY(roles)
         AND status = 'active'
         AND first_name IS NOT NULL
         ORDER BY first_name ASC`
      );

      const teachers = result.rows.map(row => row.name);
      res.json({ success: true, teachers });
    } catch (error: any) {
      console.error('取得老師列表失敗:', error);
      // 返回備用列表
      res.json({ success: true, teachers: ['Karen', 'Vicky', 'Orange', 'Elena'] });
    }
  });

  // ============================================================================
  // Teaching Quality Analysis API Endpoints
  // ============================================================================

  // Register authentication routes
  registerAuthRoutes(app);

  // Register new auto-analysis routes
  registerTeachingQualityRoutes(app, isAuthenticated);

  // Register employee management routes
  registerEmployeeManagementRoutes(app);

  // Register Know-it-all AI Advisor routes
  registerKnowItAllRoutes(app);

  // Register permission management routes
  registerPermissionRoutes(app);

  // 0. Get attendance records (for creating new analysis) [DEPRECATED - use student-records instead]
  app.get('/api/teaching-quality/attendance-records', isAuthenticated, requireModulePermission('teaching_quality'), async (req: any, res) => {
    try {
      // 建立權限過濾條件（使用新的業務身份系統）
      const permissionFilter = await buildPermissionFilter({
        userId: req.user.id,
        tableName: 'trial_class_attendance',
        additionalConditions: 'ai_analysis_id IS NULL'
      });

      const query = `
        SELECT
          tca.id,
          tca.student_name,
          tca.class_date,
          tca.teacher_name,
          tca.teacher_code,
          tca.status,
          tca.ai_analysis_id
        FROM trial_class_attendance tca
        WHERE ${permissionFilter}
        ORDER BY tca.class_date DESC
        LIMIT 100
      `;

      const result = await queryDatabase(query);

      res.json({
        success: true,
        data: result.rows
      });
    } catch (error: any) {
      console.error('Failed to fetch attendance records:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 1. Create new analysis (trigger AI analysis)
  app.post('/api/teaching-quality/analyze', isAuthenticated, async (req: any, res) => {
    try {
      const {
        attendanceId,
        transcriptText,
        transcriptFileUrl,
        classTopic
      } = req.body;

      if (!attendanceId || !transcriptText) {
        return res.status(400).json({
          error: 'Missing required fields: attendanceId, transcriptText'
        });
      }

      const pool = createPool();

      // Get attendance record
      const attendanceResult = await queryDatabase(pool, `
        SELECT tca.*, u.full_name as teacher_name
        FROM trial_class_attendance tca
        LEFT JOIN users u ON tca.teacher_id = u.id
        WHERE tca.id = $1
      `, [attendanceId]);

      if (attendanceResult.rows.length === 0) {
        return res.status(404).json({ error: 'Attendance record not found' });
      }

      const attendance = attendanceResult.rows[0];

      // Check permissions: teachers can only analyze their own classes
      if (req.user && req.user.role === 'teacher' && attendance.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Run AI analysis
      const analysis = await teachingQualityGPT.analyzeTeachingQuality(
        transcriptText,
        attendance.student_name,
        attendance.teacher_name || 'Unknown',
        classTopic
      );

      // Save to database
      const result = await insertAndReturn(pool, 'teaching_quality_analysis', {
        attendance_id: attendanceId,
        teacher_id: attendance.teacher_id,
        teacher_name: attendance.teacher_name,
        student_name: attendance.student_name,
        class_date: attendance.class_date,
        class_topic: classTopic || null,
        transcript_text: transcriptText,
        transcript_file_url: transcriptFileUrl || null,
        overall_score: analysis.overallScore,
        strengths: JSON.stringify(analysis.strengths),
        weaknesses: JSON.stringify(analysis.weaknesses),
        class_summary: analysis.summary,
        suggestions: JSON.stringify(analysis.suggestions),
        conversion_status: attendance.status === 'completed' ? 'converted' : 'not_converted',
        analyzed_by: req.user.id
      });

      // Update attendance record with analysis reference
      await queryDatabase(pool, `
        UPDATE trial_class_attendance
        SET ai_analysis_id = $1
        WHERE id = $2
      `, [result.id, attendanceId]);

      // Create suggestion execution log entries
      for (let i = 0; i < analysis.suggestions.length; i++) {
        await insertAndReturn(pool, 'suggestion_execution_log', {
          analysis_id: result.id,
          suggestion_index: i,
          suggestion_text: analysis.suggestions[i].suggestion,
          is_executed: false
        });
      }

      await pool.end();

      res.json({
        success: true,
        data: {
          ...result,
          strengths: analysis.strengths,
          weaknesses: analysis.weaknesses,
          suggestions: analysis.suggestions
        }
      });
    } catch (error: any) {
      console.error('教學品質分析失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 2. Get all analyses (with teacher filtering)
  app.get('/api/teaching-quality/analyses', isAuthenticated, async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      const teacherId = req.query.teacherId as string;

      // 建立權限過濾條件
      let additionalConditions = '';
      if (teacherId) {
        additionalConditions = `tqa.teacher_id = '${teacherId}'`;
      }

      const permissionFilter = await buildPermissionFilter({
        userId: req.user.id,
        tableName: 'teaching_quality_analysis',
        additionalConditions
      });

      const query = `
        SELECT
          tqa.*,
          COUNT(sel.id) as total_suggestions,
          COUNT(CASE WHEN sel.is_executed = true THEN 1 END) as executed_suggestions
        FROM teaching_quality_analysis tqa
        LEFT JOIN suggestion_execution_log sel ON tqa.id = sel.analysis_id
        WHERE ${permissionFilter}
        GROUP BY tqa.id
        ORDER BY tqa.class_date DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const result = await queryDatabase(query);

      // Parse JSONB fields
      const analyses = result.rows.map(row => ({
        ...row,
        strengths: typeof row.strengths === 'string' ? JSON.parse(row.strengths) : row.strengths,
        weaknesses: typeof row.weaknesses === 'string' ? JSON.parse(row.weaknesses) : row.weaknesses,
        suggestions: typeof row.suggestions === 'string' ? JSON.parse(row.suggestions) : row.suggestions,
        conversion_suggestions: row.conversion_suggestions && typeof row.conversion_suggestions === 'string'
          ? JSON.parse(row.conversion_suggestions)
          : row.conversion_suggestions
      }));

      res.json({
        success: true,
        data: analyses,
        limit,
        offset
      });
    } catch (error: any) {
      console.error('取得分析記錄失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 3. Get single analysis detail
  app.get('/api/teaching-quality/analyses/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(`
        SELECT tqa.*,
          (SELECT json_agg(sel ORDER BY sel.suggestion_index)
           FROM suggestion_execution_log sel
           WHERE sel.analysis_id = tqa.id) as suggestion_logs,
          tcp.package_name as purchased_package,
          tcp.student_email,
          tca.student_email as attendance_email,
          tca.student_email as student_email
        FROM teaching_quality_analysis tqa
        LEFT JOIN trial_class_attendance tca ON tqa.attendance_id = tca.id
        LEFT JOIN trial_class_purchases tcp ON tcp.student_email = tca.student_email
        WHERE tqa.id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Analysis not found' });
      }

      const analysis = result.rows[0];

      // Permission check
      if (req.user && req.user.role === 'teacher' && analysis.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Calculate remaining lessons dynamically based on class date
      let remaining_lessons = null;
      if (analysis.purchased_package && analysis.attendance_email) {
        // Determine total lessons from package name
        let totalLessons = 4; // 預設初學專案
        if (analysis.purchased_package.includes('pro')) {
          totalLessons = 2;
        } else if (analysis.purchased_package.includes('終極')) {
          totalLessons = 1;
        } else if (analysis.purchased_package.includes('12堂')) {
          totalLessons = 12;
        }

        // Count classes BEFORE or ON this class date
        const attendanceCountResult = await queryDatabase(`
          SELECT COUNT(*) as count
          FROM trial_class_attendance
          WHERE student_email = $1
            AND class_date <= $2
        `, [analysis.attendance_email, analysis.class_date]);

        const classesBeforeOrOn = parseInt(attendanceCountResult.rows[0]?.count || '0', 10);
        remaining_lessons = Math.max(0, totalLessons - classesBeforeOrOn);
      }

      // Parse JSONB fields
      const parsedAnalysis = {
        ...analysis,
        remaining_lessons, // 使用動態計算的剩餘堂數
        strengths: typeof analysis.strengths === 'string' ? JSON.parse(analysis.strengths) : analysis.strengths,
        weaknesses: typeof analysis.weaknesses === 'string' ? JSON.parse(analysis.weaknesses) : analysis.weaknesses,
        suggestions: typeof analysis.suggestions === 'string' ? JSON.parse(analysis.suggestions) : analysis.suggestions,
        conversion_suggestions: analysis.conversion_suggestions && typeof analysis.conversion_suggestions === 'string'
          ? JSON.parse(analysis.conversion_suggestions)
          : analysis.conversion_suggestions
      };

      res.json({
        success: true,
        data: parsedAnalysis
      });
    } catch (error: any) {
      console.error('取得分析詳情失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 4. Mark suggestion as executed
  app.post('/api/teaching-quality/suggestions/:logId/mark-executed', isAuthenticated, async (req: any, res) => {
    try {
      const { logId } = req.params;
      const { executionNotes } = req.body;

      const pool = createPool();

      // Get the suggestion log and check permissions
      const logResult = await queryDatabase(pool, `
        SELECT sel.*, tqa.teacher_id
        FROM suggestion_execution_log sel
        JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
        WHERE sel.id = $1
      `, [logId]);

      if (logResult.rows.length === 0) {
        return res.status(404).json({ error: 'Suggestion log not found' });
      }

      const log = logResult.rows[0];

      // Permission check
      if (req.user && req.user.role === 'teacher' && log.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Update execution status
      await queryDatabase(pool, `
        UPDATE suggestion_execution_log
        SET is_executed = true,
            executed_at = NOW(),
            execution_notes = $1,
            marked_by = $2,
            updated_at = NOW()
        WHERE id = $3
      `, [executionNotes || null, req.user.id, logId]);

      await pool.end();

      res.json({ success: true });
    } catch (error: any) {
      console.error('標記建議執行狀態失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 5. Analyze suggestion effectiveness (compare with next class)
  app.post('/api/teaching-quality/suggestions/:logId/analyze-effectiveness', isAuthenticated, async (req: any, res) => {
    try {
      const { logId } = req.params;
      const { nextAnalysisId } = req.body;

      if (!nextAnalysisId) {
        return res.status(400).json({ error: 'Missing nextAnalysisId' });
      }

      const pool = createPool();

      // Get previous and current analysis
      const logResult = await queryDatabase(pool, `
        SELECT sel.*, tqa.transcript_text as prev_transcript, tqa.teacher_name, tqa.student_name
        FROM suggestion_execution_log sel
        JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
        WHERE sel.id = $1
      `, [logId]);

      if (logResult.rows.length === 0) {
        return res.status(404).json({ error: 'Suggestion log not found' });
      }

      const log = logResult.rows[0];

      // Get next analysis
      const nextResult = await queryDatabase(pool, `
        SELECT transcript_text, suggestions
        FROM teaching_quality_analysis
        WHERE id = $1
      `, [nextAnalysisId]);

      if (nextResult.rows.length === 0) {
        return res.status(404).json({ error: 'Next analysis not found' });
      }

      const nextAnalysis = nextResult.rows[0];

      // Parse the original suggestion
      const prevAnalysisResult = await queryDatabase(pool, `
        SELECT suggestions
        FROM teaching_quality_analysis
        WHERE id = $1
      `, [log.analysis_id]);

      const prevSuggestions = typeof prevAnalysisResult.rows[0].suggestions === 'string'
        ? JSON.parse(prevAnalysisResult.rows[0].suggestions)
        : prevAnalysisResult.rows[0].suggestions;

      const originalSuggestion = prevSuggestions[log.suggestion_index];

      // Run effectiveness analysis
      const effectiveness = await teachingQualityGPT.analyzeSuggestionEffectiveness(
        log.prev_transcript,
        nextAnalysis.transcript_text,
        originalSuggestion,
        log.teacher_name,
        log.student_name
      );

      // Update suggestion log
      await queryDatabase(pool, `
        UPDATE suggestion_execution_log
        SET next_analysis_id = $1,
            effectiveness_score = $2,
            effectiveness_evidence = $3,
            evaluated_at = NOW(),
            updated_at = NOW()
        WHERE id = $4
      `, [nextAnalysisId, effectiveness.effectivenessScore, effectiveness.evidence, logId]);

      await pool.end();

      res.json({
        success: true,
        data: effectiveness
      });
    } catch (error: any) {
      console.error('分析建議效果失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 6. Generate conversion optimization suggestions
  app.post('/api/teaching-quality/analyses/:id/conversion-optimization', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { studentBackground } = req.body;

      const pool = createPool();

      // Get analysis
      const result = await queryDatabase(pool, `
        SELECT * FROM teaching_quality_analysis WHERE id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Analysis not found' });
      }

      const analysis = result.rows[0];

      // Permission check
      if (req.user && req.user.role === 'teacher' && analysis.teacher_id !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      // Generate conversion suggestion (now returns single object)
      const conversionSuggestion = await teachingQualityGPT.analyzeConversionOptimization(
        analysis.transcript_text,
        analysis.student_name,
        analysis.teacher_name,
        studentBackground
      );

      // Update analysis with conversion suggestions
      await queryDatabase(pool, `
        UPDATE teaching_quality_analysis
        SET conversion_suggestions = $1,
            updated_at = NOW()
        WHERE id = $2
      `, [JSON.stringify(conversionSuggestion), id]);

      await pool.end();

      res.json({
        success: true,
        data: conversionSuggestion
      });
    } catch (error: any) {
      console.error('生成轉換優化建議失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 7. Get teacher statistics
  app.get('/api/teaching-quality/teachers/:teacherId/stats', isAuthenticated, async (req: any, res) => {
    try {
      const { teacherId } = req.params;

      // Permission check
      if (req.user && req.user.role === 'teacher' && teacherId !== req.user.id) {
        return res.status(403).json({ error: 'Permission denied' });
      }

      const pool = createPool();

      const result = await queryDatabase(pool, `
        SELECT
          COUNT(*) as total_classes,
          AVG(overall_score) as avg_score,
          COUNT(CASE WHEN conversion_status = 'converted' THEN 1 END) as converted_count,
          COUNT(CASE WHEN conversion_status = 'not_converted' THEN 1 END) as not_converted_count,
          (SELECT COUNT(*) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1 AND sel.is_executed = true) as executed_suggestions,
          (SELECT COUNT(*) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1) as total_suggestions,
          (SELECT AVG(effectiveness_score) FROM suggestion_execution_log sel
           JOIN teaching_quality_analysis tqa ON sel.analysis_id = tqa.id
           WHERE tqa.teacher_id = $1 AND sel.effectiveness_score IS NOT NULL) as avg_effectiveness
        FROM teaching_quality_analysis
        WHERE teacher_id = $1
      `, [teacherId]);

      // Get score trend (last 10 classes)
      const trendResult = await queryDatabase(pool, `
        SELECT class_date, overall_score
        FROM teaching_quality_analysis
        WHERE teacher_id = $1
        ORDER BY class_date DESC
        LIMIT 10
      `, [teacherId]);

      await pool.end();

      res.json({
        success: true,
        data: {
          ...result.rows[0],
          score_trend: trendResult.rows.reverse()
        }
      });
    } catch (error: any) {
      console.error('取得教師統計失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 8. Delete analysis (admin only)
  app.delete('/api/teaching-quality/analyses/:id', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const pool = createPool();

      await queryDatabase(pool, `DELETE FROM teaching_quality_analysis WHERE id = $1`, [id]);

      await pool.end();

      res.json({ success: true });
    } catch (error: any) {
      console.error('刪除分析記錄失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 9. Estimate analysis cost
  app.post('/api/teaching-quality/estimate-cost', isAuthenticated, async (req, res) => {
    try {
      const { transcriptText } = req.body;

      if (!transcriptText) {
        return res.status(400).json({ error: 'Missing transcriptText' });
      }

      const cost = teachingQualityGPT.estimateAnalysisCost(transcriptText.length);

      res.json({
        success: true,
        data: {
          transcriptLength: transcriptText.length,
          estimatedCostUSD: cost.toFixed(4),
          estimatedCostNTD: (cost * 32).toFixed(2) // Assuming 1 USD = 32 TWD
        }
      });
    } catch (error: any) {
      console.error('估算成本失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================
  // 收支紀錄表 API (Phase 18)
  // ============================================
  const { incomeExpenseService } = await import('./services/income-expense-service');

  // 查詢收支記錄（支援多種篩選）
  app.get('/api/income-expense/records', isAuthenticated, requireModulePermission('income_expense'), async (req: any, res) => {
    try {
      // 建立額外過濾條件
      const conditions: string[] = [];
      if (req.query.month) conditions.push(`transaction_date >= '${req.query.month}-01' AND transaction_date < '${req.query.month}-01'::date + interval '1 month'`);
      if (req.query.transaction_type) conditions.push(`transaction_type = '${req.query.transaction_type}'`);
      if (req.query.category) conditions.push(`category = '${req.query.category}'`);
      if (req.query.is_confirmed !== undefined) conditions.push(`is_confirmed = ${req.query.is_confirmed === 'true'}`);
      if (req.query.start_date) conditions.push(`transaction_date >= '${req.query.start_date}'`);
      if (req.query.end_date) conditions.push(`transaction_date <= '${req.query.end_date}'`);
      if (req.query.search) conditions.push(`(description ILIKE '%${req.query.search}%' OR student_name ILIKE '%${req.query.search}%')`);

      // 建立權限過濾條件（開發模式跳過權限檢查）
      let permissionFilter: string;
      if (process.env.SKIP_AUTH === 'true') {
        // 開發模式：顯示所有記錄
        permissionFilter = conditions.length > 0 ? conditions.join(' AND ') : '1=1';
      } else {
        // 正式模式：套用權限過濾
        permissionFilter = await buildPermissionFilter({
          userId: req.user.id,
          tableName: 'income_expense_records',
          additionalConditions: conditions.length > 0 ? conditions.join(' AND ') : undefined
        });
      }

      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      const offset = req.query.page ? (parseInt(req.query.page as string) - 1) * limit : 0;

      const query = `
        SELECT * FROM income_expense_records
        WHERE ${permissionFilter}
        ORDER BY transaction_date DESC, created_at DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const result = await queryDatabase(query);
      res.json({ success: true, data: { records: result.rows } });
    } catch (error: any) {
      console.error('查詢收支記錄失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 新增收支記錄
  app.post('/api/income-expense/records', async (req, res) => {
    try {
      const record = await incomeExpenseService.createRecord(req.body);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('新增收支記錄失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得單筆收支記錄
  app.get('/api/income-expense/records/:id', async (req, res) => {
    try {
      const record = await incomeExpenseService.getRecordById(req.params.id);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('取得收支記錄失敗:', error);
      res.status(404).json({ success: false, error: error.message });
    }
  });

  // 更新收支記錄
  app.put('/api/income-expense/records/:id', async (req, res) => {
    try {
      const record = await incomeExpenseService.updateRecord(req.params.id, req.body);
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('更新收支記錄失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 刪除收支記錄
  app.delete('/api/income-expense/records/:id', async (req, res) => {
    try {
      await incomeExpenseService.deleteRecord(req.params.id);
      res.json({ success: true, message: '記錄已刪除' });
    } catch (error: any) {
      console.error('刪除收支記錄失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得月度統計
  app.get('/api/income-expense/summary/:month', async (req, res) => {
    try {
      const summary = await incomeExpenseService.getMonthlySummary(req.params.month);
      res.json({ success: true, data: summary });
    } catch (error: any) {
      console.error('取得月度統計失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得教師相關記錄
  app.get('/api/income-expense/by-teacher/:teacherId', isAuthenticated, async (req: any, res) => {
    try {
      const { teacherId } = req.params;

      // 權限檢查：教師只能查看自己的資料（admin 可以查看所有）
      if (req.user.id !== teacherId && !req.user.roles?.includes('super_admin') && !req.user.roles?.includes('admin')) {
        return res.status(403).json({ success: false, error: '沒有權限查看此教師的資料' });
      }

      // 建立額外條件
      const conditions: string[] = [`teacher_id = '${teacherId}'`, `transaction_type = 'income'`];
      if (req.query.month) conditions.push(`transaction_date >= '${req.query.month}-01' AND transaction_date < '${req.query.month}-01'::date + interval '1 month'`);

      // 建立權限過濾條件
      const permissionFilter = await buildPermissionFilter({
        userId: req.user.id,
        tableName: 'income_expense_records',
        additionalConditions: conditions.join(' AND ')
      });

      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      const offset = req.query.page ? (parseInt(req.query.page as string) - 1) * limit : 0;

      const query = `
        SELECT * FROM income_expense_records
        WHERE ${permissionFilter}
        ORDER BY transaction_date DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const result = await queryDatabase(query);
      res.json({ success: true, data: result.rows });
    } catch (error: any) {
      console.error('取得教師記錄失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 批次匯入記錄
  app.post('/api/income-expense/bulk-import', async (req, res) => {
    try {
      const { records } = req.body;

      if (!Array.isArray(records)) {
        return res.status(400).json({ success: false, error: '請提供記錄陣列' });
      }

      const result = await incomeExpenseService.bulkImport(records);
      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('批次匯入失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 同步到成本獲利表
  app.post('/api/income-expense/sync-to-cost-profit', async (req, res) => {
    try {
      const { month } = req.body;

      if (!month) {
        return res.status(400).json({ success: false, error: '請提供月份 (YYYY-MM)' });
      }

      await incomeExpenseService.syncToCostProfit(month);
      res.json({ success: true, message: '同步完成' });
    } catch (error: any) {
      console.error('同步到成本獲利表失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // 員工管理 API
  // ========================================

  // 取得所有員工列表（含完整人資資訊）
  app.get('/api/employees', isAuthenticated, async (req, res) => {
    try {
      const result = await queryDatabase(`
        SELECT
          u.id,
          u.email,
          u.first_name,
          u.last_name,
          u.role,
          u.department,
          u.status,
          u.created_at,

          -- 員工基本資料
          ep.employee_number,
          ep.national_id,
          ep.hire_date,
          ep.resign_date,
          ep.employment_type,
          ep.residential_address,
          ep.emergency_contact_name,
          ep.emergency_contact_phone,

          -- 業務身份（JSON 陣列）
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'type', bi.identity_type,
                'code', bi.identity_code,
                'display_name', bi.display_name
              )
            ) FILTER (WHERE bi.id IS NOT NULL),
            '[]'::json
          ) as business_identities,

          -- 目前薪資
          ec.base_salary,
          ec.commission_type,
          ec.commission_config,

          -- 目前勞健保
          ei.labor_insurance_grade,
          ei.health_insurance_grade,
          ei.pension_employer_rate

        FROM users u
        LEFT JOIN employee_profiles ep ON ep.user_id = u.id
        LEFT JOIN business_identities bi ON bi.user_id = u.id AND bi.is_active = true
        LEFT JOIN employee_compensation ec ON ec.user_id = u.id AND ec.is_active = true
        LEFT JOIN employee_insurance ei ON ei.user_id = u.id AND ei.is_active = true
        GROUP BY u.id, ep.id, ec.id, ei.id
        ORDER BY u.created_at DESC
      `);

      res.json({ success: true, employees: result.rows });
    } catch (error: any) {
      console.error('取得員工列表失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得單一員工詳細資料
  app.get('/api/employees/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;

      const result = await queryDatabase(`
        SELECT
          u.*,
          ep.*,

          -- 業務身份
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', bi.id,
                'type', bi.identity_type,
                'code', bi.identity_code,
                'display_name', bi.display_name,
                'is_active', bi.is_active
              )
            ) FILTER (WHERE bi.id IS NOT NULL),
            '[]'::json
          ) as business_identities,

          -- 薪資歷史（所有記錄）
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', ec.id,
                'base_salary', ec.base_salary,
                'commission_type', ec.commission_type,
                'commission_config', ec.commission_config,
                'effective_from', ec.effective_from,
                'effective_to', ec.effective_to,
                'is_active', ec.is_active
              )
            ) FILTER (WHERE ec.id IS NOT NULL),
            '[]'::json
          ) as compensation_history,

          -- 勞健保歷史
          COALESCE(
            json_agg(
              DISTINCT jsonb_build_object(
                'id', ei.id,
                'labor_insurance_grade', ei.labor_insurance_grade,
                'health_insurance_grade', ei.health_insurance_grade,
                'pension_employer_rate', ei.pension_employer_rate,
                'effective_from', ei.effective_from,
                'effective_to', ei.effective_to,
                'is_active', ei.is_active
              )
            ) FILTER (WHERE ei.id IS NOT NULL),
            '[]'::json
          ) as insurance_history

        FROM users u
        LEFT JOIN employee_profiles ep ON ep.user_id = u.id
        LEFT JOIN business_identities bi ON bi.user_id = u.id
        LEFT JOIN employee_compensation ec ON ec.user_id = u.id
        LEFT JOIN employee_insurance ei ON ei.user_id = u.id
        WHERE u.id = $1
        GROUP BY u.id, ep.id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, error: '找不到該員工' });
      }

      res.json({ success: true, employee: result.rows[0] });
    } catch (error: any) {
      console.error('取得員工詳細資料失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 新增員工基本資料
  app.post('/api/employees', isAuthenticated, async (req, res) => {
    try {
      const {
        email,
        first_name,
        last_name,
        role,
        department,
        national_id,
        hire_date,
        employment_type,
        residential_address,
        emergency_contact_name,
        emergency_contact_phone
      } = req.body;

      // 先建立 user
      const userResult = await queryDatabase(`
        INSERT INTO users (email, first_name, last_name, role, department)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
      `, [email, first_name || '', last_name || '', role || 'user', department || '']);

      const userId = userResult.rows[0].id;

      // 建立 employee_profile
      if (national_id || hire_date || employment_type) {
        await queryDatabase(`
          INSERT INTO employee_profiles (
            user_id,
            national_id,
            hire_date,
            employment_type,
            residential_address,
            emergency_contact_name,
            emergency_contact_phone
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, [
          userId,
          national_id || null,
          hire_date || null,
          employment_type || 'full_time',
          residential_address || null,
          emergency_contact_name || null,
          emergency_contact_phone || null
        ]);
      }

      res.json({ success: true, employee: userResult.rows[0] });
    } catch (error: any) {
      console.error('新增員工失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 更新員工資料
  app.put('/api/employees/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const {
        email,
        first_name,
        last_name,
        role,
        department,
        status,
        national_id,
        hire_date,
        resign_date,
        employment_type,
        residential_address,
        emergency_contact_name,
        emergency_contact_phone
      } = req.body;

      // 更新 user
      await queryDatabase(`
        UPDATE users
        SET
          email = COALESCE($1, email),
          first_name = COALESCE($2, first_name),
          last_name = COALESCE($3, last_name),
          role = COALESCE($4, role),
          department = COALESCE($5, department),
          status = COALESCE($6, status),
          updated_at = NOW()
        WHERE id = $7
      `, [email, first_name, last_name, role, department, status, id]);

      // 更新或新增 employee_profile
      const profileExists = await queryDatabase(
        'SELECT id FROM employee_profiles WHERE user_id = $1',
        [id]
      );

      if (profileExists.rows.length > 0) {
        await queryDatabase(`
          UPDATE employee_profiles
          SET
            national_id = COALESCE($1, national_id),
            hire_date = COALESCE($2, hire_date),
            resign_date = $3,
            employment_type = COALESCE($4, employment_type),
            residential_address = COALESCE($5, residential_address),
            emergency_contact_name = COALESCE($6, emergency_contact_name),
            emergency_contact_phone = COALESCE($7, emergency_contact_phone),
            updated_at = NOW()
          WHERE user_id = $8
        `, [national_id, hire_date, resign_date, employment_type, residential_address, emergency_contact_name, emergency_contact_phone, id]);
      } else {
        await queryDatabase(`
          INSERT INTO employee_profiles (
            user_id, national_id, hire_date, resign_date, employment_type,
            residential_address, emergency_contact_name, emergency_contact_phone
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [id, national_id, hire_date, resign_date, employment_type, residential_address, emergency_contact_name, emergency_contact_phone]);
      }

      res.json({ success: true, message: '員工資料更新成功' });
    } catch (error: any) {
      console.error('更新員工資料失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 刪除員工
  app.delete('/api/employees/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // 刪除 user（會級聯刪除相關資料）
      await queryDatabase('DELETE FROM users WHERE id = $1', [id]);

      res.json({ success: true, message: '員工已刪除' });
    } catch (error: any) {
      console.error('刪除員工失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // 業務身份管理 API
  // ========================================

  // 為員工新增業務身份
  app.post('/api/employees/:id/business-identities', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { identity_type, display_name } = req.body;

      if (!identity_type) {
        return res.status(400).json({ success: false, error: '請提供身份類型' });
      }

      // 檢查是否已存在相同類型的啟用身份
      const existing = await queryDatabase(`
        SELECT id FROM business_identities
        WHERE user_id = $1 AND identity_type = $2 AND is_active = true
      `, [id, identity_type]);

      if (existing.rows.length > 0) {
        return res.status(400).json({
          success: false,
          error: `該員工已有啟用的${identity_type}身份`
        });
      }

      // 新增業務身份（identity_code 會自動生成）
      const result = await queryDatabase(`
        INSERT INTO business_identities (
          user_id,
          identity_type,
          display_name,
          effective_from,
          is_active
        )
        VALUES ($1, $2, $3, CURRENT_DATE, true)
        RETURNING *
      `, [id, identity_type, display_name || null]);

      res.json({ success: true, identity: result.rows[0] });
    } catch (error: any) {
      console.error('新增業務身份失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 停用業務身份（不刪除，只標記為停用）
  app.delete('/api/employees/:userId/business-identities/:identityId', isAuthenticated, async (req, res) => {
    try {
      const { userId, identityId } = req.params;

      // 停用身份（設定 effective_to 和 is_active）
      await queryDatabase(`
        UPDATE business_identities
        SET
          is_active = false,
          effective_to = CURRENT_DATE
        WHERE id = $1 AND user_id = $2
      `, [identityId, userId]);

      res.json({ success: true, message: '業務身份已停用' });
    } catch (error: any) {
      console.error('停用業務身份失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 重新啟用業務身份
  app.put('/api/employees/:userId/business-identities/:identityId/activate', isAuthenticated, async (req, res) => {
    try {
      const { userId, identityId } = req.params;

      // 重新啟用
      await queryDatabase(`
        UPDATE business_identities
        SET
          is_active = true,
          effective_to = NULL,
          effective_from = CURRENT_DATE
        WHERE id = $1 AND user_id = $2
      `, [identityId, userId]);

      res.json({ success: true, message: '業務身份已重新啟用' });
    } catch (error: any) {
      console.error('重新啟用業務身份失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // 薪資管理 API
  // ========================================

  // 為員工新增薪資設定
  app.post('/api/employees/:userId/compensation', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const {
        base_salary,
        commission_type,
        commission_config,
        allowances,
        effective_from,
        adjustment_reason,
      } = req.body;

      // 先將目前的薪資設定標記為歷史
      await queryDatabase(`
        UPDATE employee_compensation
        SET
          is_active = false,
          effective_to = $1
        WHERE user_id = $2 AND is_active = true
      `, [effective_from || new Date().toISOString().split('T')[0], userId]);

      // 新增新的薪資設定
      const result = await queryDatabase(`
        INSERT INTO employee_compensation (
          user_id,
          base_salary,
          commission_type,
          commission_config,
          allowances,
          effective_from,
          adjustment_reason,
          is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, true)
        RETURNING *
      `, [
        userId,
        base_salary || 0,
        commission_type || 'none',
        commission_config ? JSON.stringify(commission_config) : null,
        allowances ? JSON.stringify(allowances) : null,
        effective_from || new Date().toISOString().split('T')[0],
        adjustment_reason || null,
      ]);

      res.json({ success: true, compensation: result.rows[0] });
    } catch (error: any) {
      console.error('新增薪資設定失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得員工薪資歷史
  app.get('/api/employees/:userId/compensation/history', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;

      const result = await queryDatabase(`
        SELECT *
        FROM employee_compensation
        WHERE user_id = $1
        ORDER BY effective_from DESC
      `, [userId]);

      res.json({ success: true, history: result.rows });
    } catch (error: any) {
      console.error('取得薪資歷史失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // 勞健保管理 API
  // ========================================

  // 為員工新增勞健保設定
  app.post('/api/employees/:userId/insurance', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const {
        labor_insurance_grade,
        health_insurance_grade,
        pension_employer_rate,
        effective_from,
        adjustment_reason,
      } = req.body;

      // 先將目前的勞健保設定標記為歷史
      await queryDatabase(`
        UPDATE employee_insurance
        SET
          is_active = false,
          effective_to = $1
        WHERE user_id = $2 AND is_active = true
      `, [effective_from || new Date().toISOString().split('T')[0], userId]);

      // 新增新的勞健保設定
      const result = await queryDatabase(`
        INSERT INTO employee_insurance (
          user_id,
          labor_insurance_grade,
          health_insurance_grade,
          pension_employer_rate,
          effective_from,
          notes,
          is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, true)
        RETURNING *
      `, [
        userId,
        labor_insurance_grade || null,
        health_insurance_grade || null,
        pension_employer_rate || 0.06,
        effective_from || new Date().toISOString().split('T')[0],
        adjustment_reason || null,
      ]);

      res.json({ success: true, insurance: result.rows[0] });
    } catch (error: any) {
      console.error('新增勞健保設定失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 取得員工勞健保歷史
  app.get('/api/employees/:userId/insurance/history', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;

      const result = await queryDatabase(`
        SELECT *
        FROM employee_insurance
        WHERE user_id = $1
        ORDER BY effective_from DESC
      `, [userId]);

      res.json({ success: true, history: result.rows });
    } catch (error: any) {
      console.error('取得勞健保歷史失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // Facebook Lead Ads API 整合
  // ========================================

  const {
    generateFacebookAuthUrl,
    exchangeCodeForToken,
    getFacebookUser,
    getFacebookPages,
    getPageLeadForms,
    getFormLeads,
    parseFieldData,
    checkFacebookConfig,
  } = await import('./services/facebook-service.js');

  // 1. 取得 Facebook 登入 URL
  app.get('/api/facebook/auth-url', requireAdmin, async (req, res) => {
    try {
      // 檢查環境變數
      const configCheck = checkFacebookConfig();
      if (!configCheck.valid) {
        return res.status(500).json({
          success: false,
          error: 'Facebook 環境變數未設定',
          missing: configCheck.missing,
        });
      }

      // 產生隨機 state 防止 CSRF
      const state = Math.random().toString(36).substring(7);

      // 將 state 存到 session（供 callback 驗證用）
      if (req.session) {
        req.session.facebookOAuthState = state;
      }

      const authUrl = generateFacebookAuthUrl(state);

      res.json({ success: true, authUrl });
    } catch (error: any) {
      console.error('產生 Facebook 登入 URL 失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 2. Facebook OAuth Callback
  app.get('/api/facebook/callback', async (req, res) => {
    try {
      const { code, state, error, error_description } = req.query;

      // 檢查是否有錯誤
      if (error) {
        console.error('Facebook OAuth 錯誤:', error, error_description);
        return res.redirect(`/settings/facebook?error=${error}`);
      }

      // 驗證 state（防止 CSRF）
      if (req.session?.facebookOAuthState !== state) {
        console.error('State 不符，可能是 CSRF 攻擊');
        return res.redirect('/settings/facebook?error=invalid_state');
      }

      if (!code || typeof code !== 'string') {
        return res.redirect('/settings/facebook?error=no_code');
      }

      // 用 code 換取 access_token
      const tokenData = await exchangeCodeForToken(code);
      const { access_token, expires_in } = tokenData;

      // 取得使用者資訊
      const fbUser = await getFacebookUser(access_token);

      // 取得粉絲專頁列表（同時取得 page access token）
      const pages = await getFacebookPages(access_token);

      if (pages.length === 0) {
        return res.redirect('/settings/facebook?error=no_pages');
      }

      // 預設選第一個粉絲專頁
      const firstPage = pages[0];

      // 計算 token 過期時間
      const expiresAt = new Date(Date.now() + expires_in * 1000);

      if (!isSupabaseAvailable()) {
        return res.redirect('/settings/facebook?error=db_unavailable');
      }

      const supabase = getSupabaseClient();

      // 檢查是否已有設定（Singleton）
      const { data: existingSettings } = await supabase
        .from('facebook_settings')
        .select('id')
        .single();

      if (existingSettings) {
        // 更新現有設定
        await supabase
          .from('facebook_settings')
          .update({
            access_token,
            token_expires_at: expiresAt.toISOString(),
            facebook_user_id: fbUser.id,
            facebook_user_name: fbUser.name,
            page_id: firstPage.id,
            page_name: firstPage.name,
            page_access_token: firstPage.access_token,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingSettings.id);
      } else {
        // 建立新設定
        await supabase.from('facebook_settings').insert({
          access_token,
          token_expires_at: expiresAt.toISOString(),
          facebook_user_id: fbUser.id,
          facebook_user_name: fbUser.name,
          page_id: firstPage.id,
          page_name: firstPage.name,
          page_access_token: firstPage.access_token,
          sync_enabled: true,
          sync_interval_minutes: 5,
        });
      }

      // 清除 session 中的 state
      if (req.session) {
        delete req.session.facebookOAuthState;
      }

      // 彈出視窗模式：返回 HTML 自動關閉視窗
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Facebook 授權成功</title>
        </head>
        <body>
          <script>
            // 通知父視窗授權成功
            if (window.opener) {
              window.opener.postMessage({ type: 'facebook-auth-success' }, '*');
            }
            // 自動關閉視窗
            window.close();
            // 如果無法關閉（某些瀏覽器限制），顯示訊息
            setTimeout(() => {
              document.body.innerHTML = '<div style="text-align:center;padding:50px;font-family:sans-serif;"><h2>✅ 授權成功</h2><p>請關閉此視窗回到系統</p></div>';
            }, 1000);
          </script>
        </body>
        </html>
      `);
    } catch (error: any) {
      console.error('Facebook OAuth callback 失敗:', error);
      res.redirect(`/settings/facebook?error=${encodeURIComponent(error.message)}`);
    }
  });

  // 3. 取得 Facebook 設定狀態
  app.get('/api/facebook/settings', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('*')
        .single();

      if (!settings) {
        return res.json({ success: true, connected: false, settings: null });
      }

      // 不返回敏感的 access_token
      const safeSettings = {
        connected: true,
        facebook_user_name: settings.facebook_user_name,
        page_id: settings.page_id,
        page_name: settings.page_name,
        form_ids: settings.form_ids || [],
        form_names: settings.form_names || {},
        sync_enabled: settings.sync_enabled,
        sync_interval_minutes: settings.sync_interval_minutes,
        last_sync_at: settings.last_sync_at,
        last_sync_status: settings.last_sync_status,
        last_sync_count: settings.last_sync_count,
        last_sync_new_leads: settings.last_sync_new_leads,
        last_sync_error: settings.last_sync_error,
        token_expires_at: settings.token_expires_at,
      };

      res.json({ success: true, connected: true, settings: safeSettings });
    } catch (error: any) {
      console.error('取得 Facebook 設定失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 4. 取得粉絲專頁的表單列表
  app.get('/api/facebook/forms', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('page_id, page_access_token')
        .single();

      if (!settings) {
        return res.status(400).json({ success: false, error: '尚未連接 Facebook' });
      }

      const forms = await getPageLeadForms(settings.page_id, settings.page_access_token);

      res.json({ success: true, forms });
    } catch (error: any) {
      console.error('取得表單列表失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 5. 更新 Facebook 設定（選擇要追蹤的表單）
  app.put('/api/facebook/settings', requireAdmin, async (req, res) => {
    try {
      const { form_ids, form_names, sync_enabled, sync_interval_minutes } = req.body;

      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const updateData: any = {};

      if (form_ids !== undefined) updateData.form_ids = form_ids;
      if (form_names !== undefined) updateData.form_names = form_names;
      if (sync_enabled !== undefined) updateData.sync_enabled = sync_enabled;
      if (sync_interval_minutes !== undefined)
        updateData.sync_interval_minutes = sync_interval_minutes;

      const { data, error } = await supabase
        .from('facebook_settings')
        .update(updateData)
        .eq('id', (await supabase.from('facebook_settings').select('id').single()).data.id)
        .select()
        .single();

      if (error) throw error;

      res.json({ success: true, settings: data });
    } catch (error: any) {
      console.error('更新 Facebook 設定失敗:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // 6. 手動同步名單
  app.post('/api/facebook/sync', requireAdmin, async (req, res) => {
    try {
      if (!isSupabaseAvailable()) {
        return res.status(503).json({ success: false, error: 'Supabase 未連線' });
      }

      const supabase = getSupabaseClient();

      const { data: settings } = await supabase
        .from('facebook_settings')
        .select('*')
        .single();

      if (!settings || !settings.page_access_token) {
        return res.status(400).json({ success: false, error: '尚未連接 Facebook' });
      }

      if (!settings.form_ids || settings.form_ids.length === 0) {
        return res.status(400).json({ success: false, error: '尚未選擇要追蹤的表單' });
      }

      let totalNewLeads = 0;
      let totalProcessed = 0;

      // 對每個表單抓取名單
      for (const formId of settings.form_ids) {
        try {
          // 取得最後一次同步時間（只抓新的）
          const sinceTimestamp = settings.last_sync_at
            ? Math.floor(new Date(settings.last_sync_at).getTime() / 1000)
            : undefined;

          const leads = await getFormLeads(formId, settings.page_access_token, {
            sinceTimestamp,
            limit: 100,
          });

          totalProcessed += leads.length;

          // 插入到 ad_leads 表
          for (const lead of leads) {
            // 解析欄位資料
            const { studentName, studentPhone, studentEmail, allFields } = parseFieldData(
              lead.field_data
            );

            // 驗證必填欄位
            if (!studentName || !studentPhone) {
              console.warn(`名單缺少姓名或電話，跳過: ${lead.id}`);
              continue;
            }

            // 檢查是否已存在
            const { data: existingLead } = await supabase
              .from('ad_leads')
              .select('id')
              .eq('leadgen_id', lead.id)
              .single();

            if (existingLead) {
              console.log(`名單已存在，跳過: ${lead.id}`);
              continue;
            }

            // 插入新名單
            const { error } = await supabase.from('ad_leads').insert({
              leadgen_id: lead.id,
              ad_id: lead.ad_id || null,
              ad_name: lead.ad_name || null,
              form_id: lead.form_id,
              form_name: settings.form_names?.[lead.form_id] || null,
              student_name: studentName,
              student_phone: studentPhone,
              student_email: studentEmail || null,
              claim_status: 'unclaimed',
              contact_status: 'pending',
              stage1_status: 'pending',
              stage2_status: 'pending',
              stage3_status: 'pending',
              raw_data: {
                facebook_data: lead,
                field_map: allFields,
                synced_at: new Date().toISOString(),
              },
            });

            if (!error) {
              totalNewLeads++;
              console.log(`✅ 新增廣告名單: ${studentName} (${studentPhone})`);
            }
          }
        } catch (formError: any) {
          console.error(`抓取表單 ${formId} 失敗:`, formError);
        }
      }

      // 更新同步狀態
      await supabase
        .from('facebook_settings')
        .update({
          last_sync_at: new Date().toISOString(),
          last_sync_status: 'success',
          last_sync_count: totalProcessed,
          last_sync_new_leads: totalNewLeads,
          last_sync_error: null,
        })
        .eq('id', settings.id);

      res.json({
        success: true,
        message: `同步完成，處理 ${totalProcessed} 筆，新增 ${totalNewLeads} 筆`,
        totalProcessed,
        totalNewLeads,
      });
    } catch (error: any) {
      console.error('同步名單失敗:', error);

      // 記錄錯誤到資料庫
      if (isSupabaseAvailable()) {
        const supabase = getSupabaseClient();
        const { data: settings } = await supabase
          .from('facebook_settings')
          .select('id')
          .single();

        if (settings) {
          await supabase
            .from('facebook_settings')
            .update({
              last_sync_at: new Date().toISOString(),
              last_sync_status: 'error',
              last_sync_error: error.message,
            })
            .eq('id', settings.id);
        }
      }

      res.status(500).json({ success: false, error: error.message });
    }
  });

  // ========================================
  // GoHighLevel Webhook Integration
  // ========================================

  // Webhook - 接收 GoHighLevel Contact 資料
  app.post('/api/webhooks/gohighlevel', async (req, res) => {
    try {
      console.log('📨 收到 GoHighLevel webhook:', JSON.stringify(req.body, null, 2));

      const contactData = req.body;

      // 驗證必要欄位
      if (!contactData.id && !contactData.contactId) {
        console.warn('⚠️  GoHighLevel webhook 缺少 contact ID');
        return res.status(400).json({ error: 'Missing contact ID' });
      }

      const pool = createPool();

      // 提取關鍵欄位
      const contactId = contactData.id || contactData.contactId;
      const firstName = contactData.firstName || contactData.first_name || '';
      const lastName = contactData.lastName || contactData.last_name || '';
      const name = contactData.name || contactData.fullName || `${firstName} ${lastName}`.trim();
      const email = contactData.email || '';
      const phone = contactData.phone || contactData.phoneNumber || '';
      const tags = contactData.tags || [];
      const source = contactData.source || contactData.leadSource || '';
      const locationId = contactData.locationId || contactData.location_id || '';
      const companyName = contactData.companyName || contactData.company || '';
      const address = contactData.address || '';
      const city = contactData.city || '';
      const state = contactData.state || '';
      const postalCode = contactData.postalCode || contactData.postal_code || '';
      const country = contactData.country || '';

      // 提取自訂欄位
      const customFields = contactData.customFields || contactData.customField || {};

      // 檢查是否已存在（防止重複）
      const existingContact = await queryDatabase(
        pool,
        'SELECT id FROM gohighlevel_contacts WHERE contact_id = $1',
        [contactId]
      );

      let result;

      if (existingContact.rows.length > 0) {
        // 更新現有聯絡人
        console.log(`ℹ️  更新現有聯絡人: ${contactId}`);
        result = await queryDatabase(
          pool,
          `UPDATE gohighlevel_contacts
           SET name = $1, first_name = $2, last_name = $3, email = $4, phone = $5,
               tags = $6, source = $7, location_id = $8, company_name = $9,
               address = $10, city = $11, state = $12, postal_code = $13, country = $14,
               custom_fields = $15, raw_data = $16, updated_at = NOW()
           WHERE contact_id = $17
           RETURNING *`,
          [
            name, firstName, lastName, email, phone,
            tags, source, locationId, companyName,
            address, city, state, postalCode, country,
            JSON.stringify(customFields), JSON.stringify(contactData), contactId
          ]
        );
      } else {
        // 新增聯絡人
        console.log(`✨ 新增聯絡人: ${contactId}`);
        result = await queryDatabase(
          pool,
          `INSERT INTO gohighlevel_contacts
           (contact_id, name, first_name, last_name, email, phone, tags, source,
            location_id, company_name, address, city, state, postal_code, country,
            custom_fields, raw_data)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
           RETURNING *`,
          [
            contactId, name, firstName, lastName, email, phone, tags, source,
            locationId, companyName, address, city, state, postalCode, country,
            JSON.stringify(customFields), JSON.stringify(contactData)
          ]
        );
      }

      await pool.end();

      console.log('✅ GoHighLevel contact 已儲存:', contactId);

      res.json({
        success: true,
        message: 'Contact received and stored',
        contactId: contactId,
      });

    } catch (error: any) {
      console.error('❌ GoHighLevel webhook 處理失敗:', error);
      res.status(500).json({
        error: 'Internal server error',
        message: error.message,
      });
    }
  });

  // GET - 查詢 GoHighLevel Contacts 列表
  app.get('/api/gohighlevel/contacts', isAuthenticated, async (req, res) => {
    try {
      const {
        search,
        source,
        start_date,
        end_date,
        page = '1',
        limit = '20',
      } = req.query;

      const pool = createPool();

      // 建立查詢條件
      const conditions: string[] = ['1=1'];
      const params: any[] = [];
      let paramIndex = 1;

      // 搜尋條件（姓名、電話、Email）
      if (search && typeof search === 'string') {
        conditions.push(`(name ILIKE $${paramIndex} OR phone ILIKE $${paramIndex} OR email ILIKE $${paramIndex})`);
        params.push(`%${search}%`);
        paramIndex++;
      }

      // 來源篩選
      if (source && typeof source === 'string') {
        conditions.push(`source = $${paramIndex}`);
        params.push(source);
        paramIndex++;
      }

      // 日期範圍
      if (start_date && typeof start_date === 'string') {
        conditions.push(`created_at >= $${paramIndex}`);
        params.push(start_date);
        paramIndex++;
      }

      if (end_date && typeof end_date === 'string') {
        conditions.push(`created_at <= $${paramIndex}`);
        params.push(end_date);
        paramIndex++;
      }

      // 計算總數
      const countQuery = `SELECT COUNT(*) FROM gohighlevel_contacts WHERE ${conditions.join(' AND ')}`;
      const countResult = await queryDatabase(pool, countQuery, params);
      const total = parseInt(countResult.rows[0].count);

      // 分頁
      const pageNum = parseInt(page as string);
      const limitNum = parseInt(limit as string);
      const offset = (pageNum - 1) * limitNum;

      // 查詢資料
      const dataQuery = `
        SELECT * FROM gohighlevel_contacts
        WHERE ${conditions.join(' AND ')}
        ORDER BY created_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      const dataResult = await queryDatabase(pool, dataQuery, [...params, limitNum, offset]);

      await pool.end();

      res.json({
        success: true,
        data: dataResult.rows,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum),
        },
      });

    } catch (error: any) {
      console.error('查詢 GoHighLevel contacts 失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - 取得單一 Contact 詳情
  app.get('/api/gohighlevel/contacts/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const pool = createPool();

      const result = await queryDatabase(
        pool,
        'SELECT * FROM gohighlevel_contacts WHERE id = $1',
        [id]
      );

      await pool.end();

      if (result.rows.length === 0) {
        return res.status(404).json({ error: '找不到此聯絡人' });
      }

      res.json({ success: true, data: result.rows[0] });

    } catch (error: any) {
      console.error('查詢 contact 詳情失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // GET - 統計資料
  app.get('/api/gohighlevel/stats', isAuthenticated, async (req, res) => {
    try {
      const pool = createPool();

      // 總聯絡人數
      const totalResult = await queryDatabase(pool, 'SELECT COUNT(*) FROM gohighlevel_contacts');
      const total = parseInt(totalResult.rows[0].count);

      // 今日新增
      const todayResult = await queryDatabase(
        pool,
        `SELECT COUNT(*) FROM gohighlevel_contacts
         WHERE created_at >= CURRENT_DATE`
      );
      const today = parseInt(todayResult.rows[0].count);

      // 本週新增
      const weekResult = await queryDatabase(
        pool,
        `SELECT COUNT(*) FROM gohighlevel_contacts
         WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'`
      );
      const week = parseInt(weekResult.rows[0].count);

      // 依來源分組
      const sourceResult = await queryDatabase(
        pool,
        `SELECT source, COUNT(*) as count
         FROM gohighlevel_contacts
         WHERE source IS NOT NULL AND source != ''
         GROUP BY source
         ORDER BY count DESC`
      );

      await pool.end();

      res.json({
        success: true,
        data: {
          total,
          today,
          week,
          bySources: sourceResult.rows,
        },
      });

    } catch (error: any) {
      console.error('查詢統計資料失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // ============================================================================
  // Student Knowledge Base & AI Conversation API
  // ============================================================================

  // 1. Get student complete profile
  app.get('/api/teaching-quality/student/:email/profile', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const studentKnowledgeService = await import('./services/student-knowledge-service');

      const context = await studentKnowledgeService.getStudentFullContext(email);

      res.json({
        success: true,
        data: context
      });
    } catch (error: any) {
      console.error('取得學員檔案失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 2. Ask AI preset question
  app.post('/api/teaching-quality/student/:email/ask-preset', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { questionType } = req.body;
      const teacherId = req.user.id;

      if (!questionType) {
        return res.status(400).json({ error: 'Missing questionType' });
      }

      const aiConversationService = await import('./services/ai-conversation-service');

      const result = await aiConversationService.askPresetQuestion(teacherId, email, questionType);

      res.json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('AI 預設問題查詢失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 3. Ask AI custom question
  app.post('/api/teaching-quality/student/:email/ask-custom', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { question } = req.body;
      const teacherId = req.user.id;

      if (!question || question.trim() === '') {
        return res.status(400).json({ error: 'Missing question' });
      }

      const aiConversationService = await import('./services/ai-conversation-service');

      const result = await aiConversationService.askCustomQuestion(teacherId, email, question);

      res.json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('AI 自訂問題查詢失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 4. Get conversation history
  app.get('/api/teaching-quality/student/:email/conversations', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const teacherId = req.user.id;
      const limit = parseInt(req.query.limit as string) || 20;

      const aiConversationService = await import('./services/ai-conversation-service');

      const conversations = await aiConversationService.getConversationHistory(teacherId, email, limit);

      res.json({
        success: true,
        data: conversations
      });
    } catch (error: any) {
      console.error('取得對話歷史失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 5. Get preset questions list
  app.get('/api/teaching-quality/preset-questions', isAuthenticated, async (req: any, res) => {
    try {
      const aiConversationService = await import('./services/ai-conversation-service');

      res.json({
        success: true,
        data: aiConversationService.PRESET_QUESTIONS
      });
    } catch (error: any) {
      console.error('取得預設問題清單失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // 6. Save insight to knowledge base
  app.post('/api/teaching-quality/student/:email/save-insight', isAuthenticated, async (req: any, res) => {
    try {
      const { email } = req.params;
      const { conversationId, question, answer } = req.body;

      if (!conversationId || !question || !answer) {
        return res.status(400).json({ error: '缺少必要參數' });
      }

      const studentKnowledgeService = await import('./services/student-knowledge-service');

      await studentKnowledgeService.saveInsightToKnowledgeBase(
        email,
        conversationId,
        question,
        answer
      );

      res.json({
        success: true,
        message: '已儲存到知識庫'
      });
    } catch (error: any) {
      console.error('儲存到知識庫失敗:', error);
      res.status(500).json({ error: error.message });
    }
  });

  return httpServer;
}
