/**
 * Supabase Storage Implementation
 * Replaces MemStorage with persistent Supabase-backed storage
 */

import { getSupabaseClient } from '../supabase-client';
import type { IStorage } from './storage';
import type {
  Spreadsheet, InsertSpreadsheet,
  Worksheet, InsertWorksheet,
  SheetData, InsertSheetData,
  User, InsertUser,
} from '@shared/schema';

// Temporary type definitions for missing types in schema
type UpsertUser = Partial<User> & { id?: string; email?: string };
type Role = any; type InsertRole = any;
type DashboardTemplate = any; type InsertDashboardTemplate = any;
type CustomDashboard = any; type InsertCustomDashboard = any;
type CalculationRule = any; type InsertCalculationRule = any;
type DataSourceMapping = any; type InsertDataSourceMapping = any;
type DataSourceRelationship = any; type InsertDataSourceRelationship = any;
type PurchaseRecord = any; type InsertPurchaseRecord = any;
type ConsultationRecord = any; type InsertConsultationRecord = any;
type MultiSourceAnalytic = any; type InsertMultiSourceAnalytic = any;
type WorksheetAnalysis = any; type InsertWorksheetAnalysis = any;
type AutoGeneratedReport = any; type InsertAutoGeneratedReport = any;

import type { SheetFieldMapping, SheetMappingUpdateInput, SheetType } from '../../../configs/sheet-mapping-defaults';
import { getDefaultSheetMapping, SHEET_MAPPING_DEFAULT_LIST } from '../../../configs/sheet-mapping-defaults';
import type { ReportMetricConfig } from '../../../configs/report-metric-defaults';
import { DEFAULT_METRIC_CONFIGS } from '../../../configs/report-metric-defaults';

class SupabaseStorage implements IStorage {
  private get supabase() {
    const client = getSupabaseClient();
    if (!client) throw new Error('Supabase client not available');
    return client;
  }

  // In-memory cache for report metric configs
  private metricConfigCache = new Map<string, ReportMetricConfig>();

  constructor() {
    // Initialize metric config cache with default configs
    Object.entries(DEFAULT_METRIC_CONFIGS).forEach(([key, config]) => {
      this.metricConfigCache.set(key, {
        ...config,
        updatedAt: new Date(),
      });
    });
  }

  // Helper: Convert snake_case DB row to camelCase Spreadsheet
  private mapSpreadsheet(row: any): Spreadsheet {
    if (!row) return row;
    return {
      ...row,
      spreadsheetId: row.spreadsheet_id,
      spreadsheetUrl: row.spreadsheet_url,
      ownerUserId: row.owner_user_id,
      lastSyncAt: row.last_sync_at,
      rowCount: row.row_count,
      syncFrequencyMinutes: row.sync_frequency_minutes,
      isAutoSyncEnabled: row.is_auto_sync_enabled,
      syncStatus: row.sync_status,
      lastSyncError: row.last_sync_error,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    } as Spreadsheet;
  }

  private mapWorksheet(row: any): Worksheet {
    if (!row) return row;
    return {
      ...row,
      spreadsheetId: row.spreadsheet_id,
      worksheetName: row.worksheet_name,
      isEnabled: row.is_enabled,
      rowCount: row.row_count,
      lastSyncAt: row.last_sync_at,
      supabaseTable: row.supabase_table,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    } as Worksheet;
  }

  // User Operations
  async getUser(id: string): Promise<User | undefined> {
    const { data, error } = await this.supabase.from('users').select('*').eq('id', id).single();
    if (error) return undefined;
    return data as User;
  }

  async upsertUser(user: UpsertUser): Promise<User> {
    const { data, error} = await this.supabase.from('users').upsert({
      id: user.id, email: user.email,
      first_name: (user as any).firstName, last_name: (user as any).lastName,
      profile_image_url: (user as any).profileImageUrl,
      role: (user as any).role || 'user', department: (user as any).department,
      status: (user as any).status || 'active',
      teacher_id: (user as any).teacherId, sales_id: (user as any).salesId,
      updated_at: new Date().toISOString(),
    }, { onConflict: 'id' }).select().single();
    if (error) throw new Error(`Failed to upsert user: ${error.message}`);
    return data as User;
  }

  async updateUserLastLogin(id: string): Promise<User | undefined> {
    const { data } = await this.supabase.from('users').update({ last_login_at: new Date().toISOString() }).eq('id', id).select().single();
    return data as User || undefined;
  }

  async listUsers(): Promise<User[]> {
    const { data } = await this.supabase.from('users').select('*').order('created_at', { ascending: false });
    return (data || []) as User[];
  }

  async updateUserRole(id: string, role: string, department?: string): Promise<User | undefined> {
    const updates: any = { role, updated_at: new Date().toISOString() };
    if (department) updates.department = department;
    const { data } = await this.supabase.from('users').update(updates).eq('id', id).select().single();
    return data as User || undefined;
  }

  async updateUserStatus(id: string, status: string, role?: string): Promise<User | undefined> {
    const updates: any = { status, updated_at: new Date().toISOString() };
    if (role) updates.role = role;
    const { data } = await this.supabase.from('users').update(updates).eq('id', id).select().single();
    return data as User || undefined;
  }

  async updateUserProfile(id: string, profileData: { firstName?: string; lastName?: string; email?: string; department?: string }): Promise<User | undefined> {
    const updates: any = { updated_at: new Date().toISOString() };
    if (profileData.firstName) updates.first_name = profileData.firstName;
    if (profileData.lastName) updates.last_name = profileData.lastName;
    if (profileData.email) updates.email = profileData.email;
    if (profileData.department) updates.department = profileData.department;
    const { data } = await this.supabase.from('users').update(updates).eq('id', id).select().single();
    return data as User || undefined;
  }

  // Role Operations (Stub)
  async getRole(name: string): Promise<Role | undefined> {
    const { data } = await this.supabase.from('roles').select('*').eq('name', name).single();
    return data || undefined;
  }
  async createRole(role: InsertRole): Promise<Role> {
    const { data, error } = await this.supabase.from('roles').insert(role).select().single();
    if (error) throw new Error(`Failed to create role: ${error.message}`);
    return data;
  }
  async updateRole(id: string, updates: Partial<Role>): Promise<Role | undefined> {
    const { data } = await this.supabase.from('roles').update(updates).eq('id', id).select().single();
    return data || undefined;
  }
  async listRoles(): Promise<Role[]> {
    const { data } = await this.supabase.from('roles').select('*');
    return data || [];
  }
  async deleteRole(id: string): Promise<boolean> {
    const { error } = await this.supabase.from('roles').delete().eq('id', id);
    return !error;
  }

  // Spreadsheet Operations
  async getSpreadsheet(id: string): Promise<Spreadsheet | undefined> {
    const { data } = await this.supabase.from('spreadsheets').select('*').eq('id', id).single();
    return data ? this.mapSpreadsheet(data) : undefined;
  }

  async getSpreadsheetBySheetId(spreadsheetId: string): Promise<Spreadsheet | undefined> {
    const { data } = await this.supabase.from('spreadsheets').select('*').eq('spreadsheet_id', spreadsheetId).single();
    return data ? this.mapSpreadsheet(data) : undefined;
  }

  async createSpreadsheet(spreadsheet: InsertSpreadsheet): Promise<Spreadsheet> {
    console.log('üìù Creating spreadsheet with data:', {
      name: spreadsheet.name,
      spreadsheetId: spreadsheet.spreadsheetId
    });

    const { data, error } = await this.supabase.from('spreadsheets').insert({
      name: spreadsheet.name, spreadsheet_id: spreadsheet.spreadsheetId,
      spreadsheet_url: (spreadsheet as any).spreadsheetUrl,
      range: spreadsheet.range || 'A1:Z1000',
      owner_user_id: (spreadsheet as any).ownerUserId,
      headers: spreadsheet.headers, row_count: spreadsheet.rowCount || 0,
      sync_status: 'pending',
    }).select().single();

    console.log('üìä Supabase insert result:', { data, error });

    if (error) throw new Error(`Failed to create spreadsheet: ${error.message}`);

    if (!data) {
      console.error('‚ùå No data returned from Supabase insert!');
      throw new Error('No data returned from database');
    }

    const mapped = this.mapSpreadsheet(data);
    console.log('‚úÖ Mapped spreadsheet:', mapped);
    return mapped;
  }

  async updateSpreadsheet(id: string, updates: Partial<Spreadsheet>): Promise<Spreadsheet | undefined> {
    const dbUpdates: any = { updated_at: new Date().toISOString() };
    if (updates.name) dbUpdates.name = updates.name;
    if (updates.range) dbUpdates.range = updates.range;
    if (updates.headers) dbUpdates.headers = updates.headers;
    if (updates.rowCount !== undefined) dbUpdates.row_count = updates.rowCount;
    if (updates.lastSyncAt) dbUpdates.last_sync_at = updates.lastSyncAt;
    if ((updates as any).syncStatus) dbUpdates.sync_status = (updates as any).syncStatus;
    if ((updates as any).lastSyncError !== undefined) dbUpdates.last_sync_error = (updates as any).lastSyncError;
    const { data } = await this.supabase.from('spreadsheets').update(dbUpdates).eq('id', id).select().single();
    return data ? this.mapSpreadsheet(data) : undefined;
  }

  async listSpreadsheets(): Promise<Spreadsheet[]> {
    const { data } = await this.supabase.from('spreadsheets').select('*').order('created_at', { ascending: false });
    return (data || []).map(row => this.mapSpreadsheet(row));
  }

  async deleteSpreadsheet(id: string): Promise<boolean> {
    const { error } = await this.supabase.from('spreadsheets').delete().eq('id', id);
    return !error;
  }

  // Worksheet Operations
  async getWorksheets(spreadsheetId: string): Promise<Worksheet[]> {
    let { data } = await this.supabase.from('worksheets').select('*').eq('spreadsheet_id', spreadsheetId).order('created_at', { ascending: true });
    if ((!data || data.length === 0) && !spreadsheetId.match(/^[0-9a-f-]{36}$/i)) {
      const spreadsheet = await this.getSpreadsheetBySheetId(spreadsheetId);
      if (spreadsheet) {
        const result = await this.supabase.from('worksheets').select('*').eq('spreadsheet_id', spreadsheet.id).order('created_at', { ascending: true });
        data = result.data;
      }
    }
    return (data || []).map(row => this.mapWorksheet(row));
  }

  async createWorksheet(worksheet: InsertWorksheet): Promise<Worksheet> {
    const { data, error } = await this.supabase.from('worksheets').insert({
      spreadsheet_id: worksheet.spreadsheetId, worksheet_name: worksheet.worksheetName,
      gid: worksheet.gid, is_enabled: worksheet.isEnabled !== undefined ? worksheet.isEnabled : true,
      range: worksheet.range || 'A1:Z1000', headers: worksheet.headers,
      row_count: worksheet.rowCount || 0, supabase_table: (worksheet as any).supabaseTable,
    }).select().single();
    if (error) throw new Error(`Failed to create worksheet: ${error.message}`);
    return this.mapWorksheet(data);
  }

  async getWorksheet(id: string): Promise<Worksheet | undefined> {
    const { data } = await this.supabase.from('worksheets').select('*').eq('id', id).single();
    return data ? this.mapWorksheet(data) : undefined;
  }

  async updateWorksheet(id: string, updates: Partial<Worksheet>): Promise<Worksheet | undefined> {
    const dbUpdates: any = { updated_at: new Date().toISOString() };
    if (updates.worksheetName) dbUpdates.worksheet_name = updates.worksheetName;
    if (updates.gid) dbUpdates.gid = updates.gid;
    if (updates.isEnabled !== undefined) dbUpdates.is_enabled = updates.isEnabled;
    if (updates.range) dbUpdates.range = updates.range;
    if (updates.headers) dbUpdates.headers = updates.headers;
    if (updates.rowCount !== undefined) dbUpdates.row_count = updates.rowCount;
    if ((updates as any).supabaseTable) dbUpdates.supabase_table = (updates as any).supabaseTable;
    if (updates.lastSyncAt) dbUpdates.last_sync_at = updates.lastSyncAt;
    const { data } = await this.supabase.from('worksheets').update(dbUpdates).eq('id', id).select().single();
    return data ? this.mapWorksheet(data) : undefined;
  }

  async deleteWorksheets(spreadsheetId: string): Promise<boolean> {
    const { error } = await this.supabase.from('worksheets').delete().eq('spreadsheet_id', spreadsheetId);
    return !error;
  }

  async toggleWorksheetSync(id: string, isEnabled: boolean): Promise<Worksheet | undefined> {
    return this.updateWorksheet(id, { isEnabled });
  }

  async deleteWorksheet(id: string): Promise<boolean> {
    const { error } = await this.supabase.from('worksheets').delete().eq('id', id);
    return !error;
  }

  async getAllWorksheets(): Promise<Worksheet[]> {
    const { data } = await this.supabase.from('worksheets').select('*').order('created_at', { ascending: false });
    return (data || []).map(row => this.mapWorksheet(row));
  }

  // Sheet Data Operations
  async getSheetData(spreadsheetId: string, page = 1, limit = 100): Promise<SheetData[]> {
    const offset = (page - 1) * limit;
    const { data } = await this.supabase.from('sheet_data').select('*').eq('spreadsheet_id', spreadsheetId).order('row_index', { ascending: true }).range(offset, offset + limit - 1);
    return (data || []) as SheetData[];
  }

  async getWorksheetData(worksheetId: string, page = 1, limit = 100): Promise<SheetData[]> {
    const offset = (page - 1) * limit;
    const { data } = await this.supabase.from('sheet_data').select('*').eq('worksheet_id', worksheetId).order('row_index', { ascending: true }).range(offset, offset + limit - 1);
    return (data || []) as SheetData[];
  }

  async createSheetData(sheetData: InsertSheetData): Promise<SheetData> {
    const { data, error } = await this.supabase.from('sheet_data').insert({
      spreadsheet_id: sheetData.spreadsheetId, worksheet_id: (sheetData as any).worksheetId || null,
      row_index: sheetData.rowIndex, data: sheetData.data,
    }).select().single();
    if (error) throw new Error(`Failed to create sheet data: ${error.message}`);
    return data as SheetData;
  }

  async updateSheetData(id: string, updates: Partial<SheetData>): Promise<SheetData | undefined> {
    const dbUpdates: any = { last_updated: new Date().toISOString() };
    if (updates.data) dbUpdates.data = updates.data;
    if (updates.rowIndex !== undefined) dbUpdates.row_index = updates.rowIndex;
    const { data } = await this.supabase.from('sheet_data').update(dbUpdates).eq('id', id).select().single();
    return data as SheetData || undefined;
  }

  async deleteSheetData(spreadsheetId: string): Promise<boolean> {
    const { error } = await this.supabase.from('sheet_data').delete().eq('spreadsheet_id', spreadsheetId);
    return !error;
  }

  async deleteWorksheetData(worksheetId: string): Promise<boolean> {
    const { error } = await this.supabase.from('sheet_data').delete().eq('worksheet_id', worksheetId);
    return !error;
  }

  async upsertSheetData(spreadsheetId: string, rowIndex: number, data: Record<string, any>, worksheetId?: string): Promise<SheetData> {
    let query = this.supabase.from('sheet_data').select('*').eq('spreadsheet_id', spreadsheetId).eq('row_index', rowIndex);
    if (worksheetId) query = query.eq('worksheet_id', worksheetId);

    // Use maybeSingle() instead of single() to avoid error when no rows found
    const { data: existing, error } = await query.maybeSingle();

    // Only throw if there's a real error (not "no rows" error)
    if (error && error.code !== 'PGRST116') {
      console.error('Error checking existing sheet data:', error);
      throw error;
    }

    if (existing) {
      const updated = await this.updateSheetData(existing.id, { data });
      if (!updated) throw new Error('Failed to update sheet data');
      return updated;
    }
    return await this.createSheetData({ spreadsheetId, worksheetId, rowIndex, data } as InsertSheetData);
  }

  async batchInsertSheetData(batchData: Array<{ spreadsheetId: string; worksheetId: string; rowIndex: number; data: Record<string, any> }>): Promise<void> {
    const insertData = batchData.map(item => ({
      spreadsheet_id: item.spreadsheetId,
      worksheet_id: item.worksheetId,
      row_index: item.rowIndex,
      data: item.data,
    }));

    const { error } = await this.supabase.from('sheet_data').insert(insertData);
    if (error) throw new Error(`Failed to batch insert sheet data: ${error.message}`);
  }

  async searchSheetData(spreadsheetId: string, query: string): Promise<SheetData[]> {
    const allData = await this.getSheetData(spreadsheetId, 1, 10000);
    const lowerQuery = query.toLowerCase();
    return allData.filter(item => JSON.stringify(item.data).toLowerCase().includes(lowerQuery));
  }

  async getSheetDataCount(spreadsheetId: string): Promise<number> {
    const { count } = await this.supabase.from('sheet_data').select('*', { count: 'exact', head: true }).eq('spreadsheet_id', spreadsheetId);
    return count || 0;
  }

  // Sheet Mapping Operations (In-memory)
  private sheetMappings: Map<SheetType, SheetFieldMapping> = new Map(SHEET_MAPPING_DEFAULT_LIST.map(m => [m.sheetType, m]));

  async getSheetMappings(): Promise<SheetFieldMapping[]> { return Array.from(this.sheetMappings.values()); }
  async getSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping | undefined> { return this.sheetMappings.get(sheetType); }
  async updateSheetMapping(sheetType: SheetType, updates: SheetMappingUpdateInput): Promise<SheetFieldMapping> {
    const current = this.sheetMappings.get(sheetType) || getDefaultSheetMapping(sheetType);
    const updated = { ...current, ...updates };
    this.sheetMappings.set(sheetType, updated);
    return updated;
  }
  async resetSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping> {
    const defaultMapping = getDefaultSheetMapping(sheetType);
    this.sheetMappings.set(sheetType, defaultMapping);
    return defaultMapping;
  }

  // Dashboard Templates
  async getDashboardTemplate(id: string): Promise<DashboardTemplate | undefined> {
    const { data } = await this.supabase.from('dashboard_templates').select('*').eq('id', id).single();
    return data || undefined;
  }
  async getDashboardTemplateByType(type: string): Promise<DashboardTemplate | undefined> {
    const { data } = await this.supabase.from('dashboard_templates').select('*').eq('type', type).single();
    return data || undefined;
  }
  async createDashboardTemplate(template: InsertDashboardTemplate): Promise<DashboardTemplate> {
    const { data, error } = await this.supabase.from('dashboard_templates').insert(template).select().single();
    if (error) throw new Error(`Failed to create dashboard template: ${error.message}`);
    return data;
  }
  async updateDashboardTemplate(id: string, updates: Partial<DashboardTemplate>): Promise<DashboardTemplate | undefined> {
    const { data } = await this.supabase.from('dashboard_templates').update(updates).eq('id', id).select().single();
    return data || undefined;
  }
  async listDashboardTemplates(): Promise<DashboardTemplate[]> {
    const { data } = await this.supabase.from('dashboard_templates').select('*');
    return data || [];
  }
  async listActiveDashboardTemplates(): Promise<DashboardTemplate[]> {
    const { data } = await this.supabase.from('dashboard_templates').select('*').eq('is_active', true);
    return data || [];
  }
  async deleteDashboardTemplate(id: string): Promise<boolean> {
    const { error } = await this.supabase.from('dashboard_templates').delete().eq('id', id);
    return !error;
  }

  // Custom Dashboards
  async getCustomDashboard(id: string): Promise<CustomDashboard | undefined> {
    const { data } = await this.supabase.from('custom_dashboards').select('*').eq('id', id).single();
    return data || undefined;
  }
  async createCustomDashboard(dashboard: InsertCustomDashboard): Promise<CustomDashboard> {
    const { data, error } = await this.supabase.from('custom_dashboards').insert(dashboard).select().single();
    if (error) throw new Error(`Failed to create custom dashboard: ${error.message}`);
    return data;
  }
  async updateCustomDashboard(id: string, updates: Partial<CustomDashboard>): Promise<CustomDashboard | undefined> {
    const { data } = await this.supabase.from('custom_dashboards').update(updates).eq('id', id).select().single();
    return data || undefined;
  }
  async listCustomDashboards(userId?: string): Promise<CustomDashboard[]> {
    let query = this.supabase.from('custom_dashboards').select('*');
    if (userId) query = query.eq('user_id', userId);
    const { data } = await query;
    return data || [];
  }
  async listPublicCustomDashboards(): Promise<CustomDashboard[]> { return []; }
  async deleteCustomDashboard(id: string): Promise<boolean> {
    const { error } = await this.supabase.from('custom_dashboards').delete().eq('id', id);
    return !error;
  }

  // Stub implementations for unused features
  async getCalculationRule(id: string): Promise<CalculationRule | undefined> { return undefined; }
  async getCalculationRuleByName(name: string): Promise<CalculationRule | undefined> { return undefined; }
  async createCalculationRule(rule: InsertCalculationRule): Promise<CalculationRule> { throw new Error('Not implemented'); }
  async updateCalculationRule(id: string, updates: Partial<CalculationRule>): Promise<CalculationRule | undefined> { return undefined; }
  async listCalculationRules(category?: string): Promise<CalculationRule[]> { return []; }
  async listActiveCalculationRules(): Promise<CalculationRule[]> { return []; }
  async deleteCalculationRule(id: string): Promise<boolean> { return false; }
  async getDataSourceMapping(id: string): Promise<DataSourceMapping | undefined> { return undefined; }
  async getDataSourceMappingByName(name: string): Promise<DataSourceMapping | undefined> { return undefined; }
  async createDataSourceMapping(mapping: InsertDataSourceMapping): Promise<DataSourceMapping> { throw new Error('Not implemented'); }
  async updateDataSourceMapping(id: string, updates: Partial<DataSourceMapping>): Promise<DataSourceMapping | undefined> { return undefined; }
  async listDataSourceMappings(): Promise<DataSourceMapping[]> { return []; }
  async listActiveDataSourceMappings(): Promise<DataSourceMapping[]> { return []; }
  async deleteDataSourceMapping(id: string): Promise<boolean> { return false; }
  async getDataSourceRelationship(id: string): Promise<DataSourceRelationship | undefined> { return undefined; }
  async getDataSourceRelationshipByName(name: string): Promise<DataSourceRelationship | undefined> { return undefined; }
  async createDataSourceRelationship(rel: InsertDataSourceRelationship): Promise<DataSourceRelationship> { throw new Error('Not implemented'); }
  async updateDataSourceRelationship(id: string, updates: Partial<DataSourceRelationship>): Promise<DataSourceRelationship | undefined> { return undefined; }
  async listDataSourceRelationships(): Promise<DataSourceRelationship[]> { return []; }
  async listActiveDataSourceRelationships(): Promise<DataSourceRelationship[]> { return []; }
  async deleteDataSourceRelationship(id: string): Promise<boolean> { return false; }
  async getPurchaseRecord(id: string): Promise<PurchaseRecord | undefined> { return undefined; }
  async createPurchaseRecord(record: InsertPurchaseRecord): Promise<PurchaseRecord> { throw new Error('Not implemented'); }
  async updatePurchaseRecord(id: string, updates: Partial<PurchaseRecord>): Promise<PurchaseRecord | undefined> { return undefined; }
  async listPurchaseRecords(filters?: any): Promise<PurchaseRecord[]> { return []; }
  async deletePurchaseRecord(id: string): Promise<boolean> { return false; }
  async getPurchaseRecordsByStudent(studentEmail: string): Promise<PurchaseRecord[]> { return []; }
  async getPurchaseRecordsByDateRange(startDate: Date, endDate: Date): Promise<PurchaseRecord[]> { return []; }
  async getConsultationRecord(id: string): Promise<ConsultationRecord | undefined> { return undefined; }
  async createConsultationRecord(record: InsertConsultationRecord): Promise<ConsultationRecord> { throw new Error('Not implemented'); }
  async updateConsultationRecord(id: string, updates: Partial<ConsultationRecord>): Promise<ConsultationRecord | undefined> { return undefined; }
  async listConsultationRecords(filters?: any): Promise<ConsultationRecord[]> { return []; }
  async deleteConsultationRecord(id: string): Promise<boolean> { return false; }
  async getConsultationRecordsByStudent(studentEmail: string): Promise<ConsultationRecord[]> { return []; }
  async getConsultationRecordsByDateRange(startDate: Date, endDate: Date): Promise<ConsultationRecord[]> { return []; }
  async getMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined> { return undefined; }
  async createMultiSourceAnalytic(analytic: InsertMultiSourceAnalytic): Promise<MultiSourceAnalytic> { throw new Error('Not implemented'); }
  async updateMultiSourceAnalytic(id: string, updates: Partial<MultiSourceAnalytic>): Promise<MultiSourceAnalytic | undefined> { return undefined; }
  async listMultiSourceAnalytics(analysisType?: string): Promise<MultiSourceAnalytic[]> { return []; }
  async deleteMultiSourceAnalytic(id: string): Promise<boolean> { return false; }
  async calculateMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined> { return undefined; }
  async getWorksheetAnalysis(worksheetId: string): Promise<WorksheetAnalysis | undefined> { return undefined; }
  async createWorksheetAnalysis(analysis: InsertWorksheetAnalysis): Promise<WorksheetAnalysis> { throw new Error('Not implemented'); }
  async updateWorksheetAnalysis(id: string, updates: Partial<WorksheetAnalysis>): Promise<WorksheetAnalysis | undefined> { return undefined; }
  async listWorksheetAnalyses(spreadsheetId?: string): Promise<WorksheetAnalysis[]> { return []; }
  async deleteWorksheetAnalysis(id: string): Promise<boolean> { return false; }
  async getAutoGeneratedReport(id: string): Promise<AutoGeneratedReport | undefined> { return undefined; }
  async createAutoGeneratedReport(report: InsertAutoGeneratedReport): Promise<AutoGeneratedReport> { throw new Error('Not implemented'); }
  async updateAutoGeneratedReport(id: string, updates: Partial<AutoGeneratedReport>): Promise<AutoGeneratedReport | undefined> { return undefined; }
  async listAutoGeneratedReports(worksheetAnalysisId?: string): Promise<AutoGeneratedReport[]> { return []; }
  async deleteAutoGeneratedReport(id: string): Promise<boolean> { return false; }
  async getAutoGeneratedReportsByWorksheet(worksheetId: string): Promise<AutoGeneratedReport[]> { return []; }

  // Report Metric Config operations (in-memory)
  async getReportMetricConfigs(): Promise<ReportMetricConfig[]> {
    // Return copies to prevent external mutation
    return Array.from(this.metricConfigCache.values()).map(config => ({ ...config }));
  }

  async getReportMetricConfig(metricId: string): Promise<ReportMetricConfig | null> {
    const config = this.metricConfigCache.get(metricId);
    // Return copy to prevent external mutation
    return config ? { ...config } : null;
  }

  async updateReportMetricConfig(
    metricId: string,
    updates: Partial<ReportMetricConfig>
  ): Promise<ReportMetricConfig> {
    const existing = this.metricConfigCache.get(metricId);
    if (!existing) {
      throw new Error(`Report metric config not found: ${metricId}`);
    }

    const updated: ReportMetricConfig = {
      ...existing,
      ...updates,
      metricId, // Ensure metricId is not changed
      updatedAt: new Date(),
    };

    this.metricConfigCache.set(metricId, updated);
    // Return copy to prevent external mutation
    return { ...updated };
  }

  async resetReportMetricConfig(metricId: string): Promise<ReportMetricConfig> {
    const defaultConfig = DEFAULT_METRIC_CONFIGS[metricId];
    if (!defaultConfig) {
      throw new Error(`No default config found for metric: ${metricId}`);
    }

    const reset: ReportMetricConfig = {
      ...defaultConfig,
      updatedAt: new Date(),
    };

    this.metricConfigCache.set(metricId, reset);
    // Return copy to prevent external mutation
    return { ...reset };
  }
}

export const storage = new SupabaseStorage();
