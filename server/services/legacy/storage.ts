import {
  type Spreadsheet,
  type InsertSpreadsheet,
  type SheetData,
  type InsertSheetData,
  type Worksheet,
  type InsertWorksheet,
  type User,
  type UpsertUser,
  type Role,
  type InsertRole,
  type DashboardTemplate,
  type InsertDashboardTemplate,
  type CustomDashboard,
  type InsertCustomDashboard,
  type CalculationRule,
  type InsertCalculationRule,
  type DataSourceMapping,
  type InsertDataSourceMapping,
  type DataSourceRelationship,
  type InsertDataSourceRelationship,
  type PurchaseRecord,
  type InsertPurchaseRecord,
  type ConsultationRecord,
  type InsertConsultationRecord,
  type MultiSourceAnalytic,
  type InsertMultiSourceAnalytic,
  type WorksheetAnalysis,
  type InsertWorksheetAnalysis,
  type AutoGeneratedReport,
  type InsertAutoGeneratedReport
} from "@shared/schema";
import { randomUUID, createHash } from "crypto";
import { promises as fs } from "fs";
import * as path from "path";
import { ReportMetricConfig, DEFAULT_METRIC_CONFIGS } from "../../../configs/report-metric-defaults";
import {
  type SheetFieldMapping,
  type SheetMappingField,
  type SheetMappingUpdateInput,
  type SheetType,
  cloneSheetMapping,
  getDefaultSheetMapping,
  SHEET_MAPPING_DEFAULT_LIST,
} from "../../../configs/sheet-mapping-defaults";

export interface IStorage {
  // User operations - IMPORTANT: Required for Replit Auth
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  updateUserLastLogin(id: string): Promise<User | undefined>;
  listUsers(): Promise<User[]>;
  updateUserRole(id: string, role: string, department?: string): Promise<User | undefined>;
  updateUserStatus(id: string, status: string, role?: string): Promise<User | undefined>;
  updateUserProfile(id: string, profileData: {
    firstName?: string;
    lastName?: string;
    email?: string;
    department?: string;
  }): Promise<User | undefined>;
  
  // Role operations
  getRole(name: string): Promise<Role | undefined>;
  createRole(role: InsertRole): Promise<Role>;
  updateRole(id: string, updates: Partial<Role>): Promise<Role | undefined>;
  listRoles(): Promise<Role[]>;
  deleteRole(id: string): Promise<boolean>;
  
  
  // Spreadsheet operations
  getSpreadsheet(id: string): Promise<Spreadsheet | undefined>;
  getSpreadsheetBySheetId(spreadsheetId: string): Promise<Spreadsheet | undefined>;
  createSpreadsheet(spreadsheet: InsertSpreadsheet): Promise<Spreadsheet>;
  updateSpreadsheet(id: string, updates: Partial<Spreadsheet>): Promise<Spreadsheet | undefined>;
  listSpreadsheets(): Promise<Spreadsheet[]>;
  deleteSpreadsheet(id: string): Promise<boolean>;
  
  // Worksheet operations
  getWorksheets(spreadsheetId: string): Promise<Worksheet[]>;
  createWorksheet(worksheet: InsertWorksheet): Promise<Worksheet>;
  getWorksheet(id: string): Promise<Worksheet | undefined>;
  updateWorksheet(id: string, updates: Partial<Worksheet>): Promise<Worksheet | undefined>;
  deleteWorksheets(spreadsheetId: string): Promise<boolean>;
  toggleWorksheetSync(id: string, isEnabled: boolean): Promise<Worksheet | undefined>;
  deleteWorksheet(id: string): Promise<boolean>;
  getAllWorksheets(): Promise<Worksheet[]>;
  
  // Sheet data operations
  getSheetData(spreadsheetId: string, page?: number, limit?: number): Promise<SheetData[]>;
  getWorksheetData(worksheetId: string, page?: number, limit?: number): Promise<SheetData[]>;
  createSheetData(data: InsertSheetData): Promise<SheetData>;
  updateSheetData(id: string, updates: Partial<SheetData>): Promise<SheetData | undefined>;
  deleteSheetData(spreadsheetId: string): Promise<boolean>;
  deleteWorksheetData(worksheetId: string): Promise<boolean>;
  upsertSheetData(spreadsheetId: string, rowIndex: number, data: Record<string, any>, worksheetId?: string): Promise<SheetData>;
  searchSheetData(spreadsheetId: string, query: string): Promise<SheetData[]>;
  getSheetDataCount(spreadsheetId: string): Promise<number>;

  // Sheet mapping operations
  getSheetMappings(): Promise<SheetFieldMapping[]>;
  getSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping | undefined>;
  updateSheetMapping(sheetType: SheetType, updates: SheetMappingUpdateInput): Promise<SheetFieldMapping>;
  resetSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping>;
  
  // Dashboard Template operations
  getDashboardTemplate(id: string): Promise<DashboardTemplate | undefined>;
  getDashboardTemplateByType(type: string): Promise<DashboardTemplate | undefined>;
  createDashboardTemplate(template: InsertDashboardTemplate): Promise<DashboardTemplate>;
  updateDashboardTemplate(id: string, updates: Partial<DashboardTemplate>): Promise<DashboardTemplate | undefined>;
  listDashboardTemplates(): Promise<DashboardTemplate[]>;
  listActiveDashboardTemplates(): Promise<DashboardTemplate[]>;
  deleteDashboardTemplate(id: string): Promise<boolean>;
  
  // Custom Dashboard operations
  getCustomDashboard(id: string): Promise<CustomDashboard | undefined>;
  createCustomDashboard(dashboard: InsertCustomDashboard): Promise<CustomDashboard>;
  updateCustomDashboard(id: string, updates: Partial<CustomDashboard>): Promise<CustomDashboard | undefined>;
  listCustomDashboards(userId?: string): Promise<CustomDashboard[]>;
  listPublicCustomDashboards(): Promise<CustomDashboard[]>;
  deleteCustomDashboard(id: string): Promise<boolean>;
  
  // Calculation Rule operations
  getCalculationRule(id: string): Promise<CalculationRule | undefined>;
  getCalculationRuleByName(name: string): Promise<CalculationRule | undefined>;
  createCalculationRule(rule: InsertCalculationRule): Promise<CalculationRule>;
  updateCalculationRule(id: string, updates: Partial<CalculationRule>): Promise<CalculationRule | undefined>;
  listCalculationRules(category?: string): Promise<CalculationRule[]>;
  listActiveCalculationRules(): Promise<CalculationRule[]>;
  deleteCalculationRule(id: string): Promise<boolean>;
  
  // Data Source Mapping operations
  getDataSourceMapping(id: string): Promise<DataSourceMapping | undefined>;
  getDataSourceMappingByName(name: string): Promise<DataSourceMapping | undefined>;
  createDataSourceMapping(mapping: InsertDataSourceMapping): Promise<DataSourceMapping>;
  updateDataSourceMapping(id: string, updates: Partial<DataSourceMapping>): Promise<DataSourceMapping | undefined>;
  listDataSourceMappings(): Promise<DataSourceMapping[]>;
  listActiveDataSourceMappings(): Promise<DataSourceMapping[]>;
  deleteDataSourceMapping(id: string): Promise<boolean>;
  
  // Data Source Relationship operations
  getDataSourceRelationship(id: string): Promise<DataSourceRelationship | undefined>;
  getDataSourceRelationshipByName(name: string): Promise<DataSourceRelationship | undefined>;
  createDataSourceRelationship(relationship: InsertDataSourceRelationship): Promise<DataSourceRelationship>;
  updateDataSourceRelationship(id: string, updates: Partial<DataSourceRelationship>): Promise<DataSourceRelationship | undefined>;
  listDataSourceRelationships(): Promise<DataSourceRelationship[]>;
  listActiveDataSourceRelationships(): Promise<DataSourceRelationship[]>;
  deleteDataSourceRelationship(id: string): Promise<boolean>;
  
  // Purchase Record operations
  getPurchaseRecord(id: string): Promise<PurchaseRecord | undefined>;
  createPurchaseRecord(record: InsertPurchaseRecord): Promise<PurchaseRecord>;
  updatePurchaseRecord(id: string, updates: Partial<PurchaseRecord>): Promise<PurchaseRecord | undefined>;
  listPurchaseRecords(filters?: { studentName?: string; courseType?: string; status?: string }): Promise<PurchaseRecord[]>;
  deletePurchaseRecord(id: string): Promise<boolean>;
  getPurchaseRecordsByStudent(studentEmail: string): Promise<PurchaseRecord[]>;
  getPurchaseRecordsByDateRange(startDate: Date, endDate: Date): Promise<PurchaseRecord[]>;
  
  // Consultation Record operations
  getConsultationRecord(id: string): Promise<ConsultationRecord | undefined>;
  createConsultationRecord(record: InsertConsultationRecord): Promise<ConsultationRecord>;
  updateConsultationRecord(id: string, updates: Partial<ConsultationRecord>): Promise<ConsultationRecord | undefined>;
  listConsultationRecords(filters?: { studentName?: string; status?: string; consultantName?: string }): Promise<ConsultationRecord[]>;
  deleteConsultationRecord(id: string): Promise<boolean>;
  getConsultationRecordsByStudent(studentEmail: string): Promise<ConsultationRecord[]>;
  getConsultationRecordsByDateRange(startDate: Date, endDate: Date): Promise<ConsultationRecord[]>;
  
  // Multi-Source Analytics operations
  getMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined>;
  createMultiSourceAnalytic(analytic: InsertMultiSourceAnalytic): Promise<MultiSourceAnalytic>;
  updateMultiSourceAnalytic(id: string, updates: Partial<MultiSourceAnalytic>): Promise<MultiSourceAnalytic | undefined>;
  listMultiSourceAnalytics(analysisType?: string): Promise<MultiSourceAnalytic[]>;
  deleteMultiSourceAnalytic(id: string): Promise<boolean>;
  calculateMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined>;

  // Auto Analysis operations
  getWorksheetAnalysis(worksheetId: string): Promise<WorksheetAnalysis | undefined>;
  createWorksheetAnalysis(analysis: InsertWorksheetAnalysis): Promise<WorksheetAnalysis>;
  updateWorksheetAnalysis(id: string, updates: Partial<WorksheetAnalysis>): Promise<WorksheetAnalysis | undefined>;
  listWorksheetAnalyses(spreadsheetId?: string): Promise<WorksheetAnalysis[]>;
  deleteWorksheetAnalysis(id: string): Promise<boolean>;

  // Auto Generated Reports operations
  getAutoGeneratedReport(id: string): Promise<AutoGeneratedReport | undefined>;
  createAutoGeneratedReport(report: InsertAutoGeneratedReport): Promise<AutoGeneratedReport>;
  updateAutoGeneratedReport(id: string, updates: Partial<AutoGeneratedReport>): Promise<AutoGeneratedReport | undefined>;
  listAutoGeneratedReports(worksheetAnalysisId?: string): Promise<AutoGeneratedReport[]>;
  deleteAutoGeneratedReport(id: string): Promise<boolean>;
  getAutoGeneratedReportsByWorksheet(worksheetId: string): Promise<AutoGeneratedReport[]>;

  // Sheet Field Mapping operations
  getSheetMappings(): Promise<SheetFieldMapping[]>;
  getSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping | undefined>;
  updateSheetMapping(sheetType: SheetType, updates: SheetMappingUpdateInput): Promise<SheetFieldMapping>;
  resetSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping>;
}

/**
 * Create deterministic worksheet ID based on spreadsheetId + gid
 * This ensures the same worksheet gets the same ID across server restarts
 */
function createDeterministicWorksheetId(spreadsheetId: string, gid: string): string {
  const hash = createHash('sha1');
  hash.update(`${spreadsheetId}:${gid}`);
  return hash.digest('hex');
}

const WORKSHEET_CACHE_PATH = path.join(process.cwd(), 'attached_assets', 'worksheet-cache.json');

export class MemStorage implements IStorage {
  private spreadsheets: Map<string, Spreadsheet>;
  private worksheets: Map<string, Worksheet>;
  private sheetData: Map<string, SheetData>;
  private users: Map<string, User>;
  private roles: Map<string, Role>;
  private dashboardTemplates: Map<string, DashboardTemplate>;
  private customDashboards: Map<string, CustomDashboard>;
  private calculationRules: Map<string, CalculationRule>;
  private dataSourceMappings: Map<string, DataSourceMapping>;
  private dataSourceRelationships: Map<string, DataSourceRelationship>;
  private purchaseRecords: Map<string, PurchaseRecord>;
  private consultationRecords: Map<string, ConsultationRecord>;
  private multiSourceAnalytics: Map<string, MultiSourceAnalytic>;
  private worksheetAnalyses: Map<string, WorksheetAnalysis>;
  private autoGeneratedReports: Map<string, AutoGeneratedReport>;
  private reportMetricConfigs: Map<string, ReportMetricConfig>;
  private sheetMappings: Map<SheetType, SheetFieldMapping>;

  constructor() {
    this.spreadsheets = new Map();
    this.worksheets = new Map();
    this.sheetData = new Map();
    this.users = new Map();
    this.roles = new Map();
    this.dashboardTemplates = new Map();
    this.customDashboards = new Map();
    this.calculationRules = new Map();
    this.dataSourceMappings = new Map();
    this.dataSourceRelationships = new Map();
    this.purchaseRecords = new Map();
    this.consultationRecords = new Map();
    this.multiSourceAnalytics = new Map();
    this.worksheetAnalyses = new Map();
    this.autoGeneratedReports = new Map();
    this.reportMetricConfigs = new Map();
    this.sheetMappings = new Map();

    // Initialize metric configs from defaults
    this.initializeMetricConfigs();
    this.initializeSheetMappings();

    // Load worksheet cache from disk
    this.loadWorksheetCache();
  }

  private initializeMetricConfigs() {
    for (const [key, config] of Object.entries(DEFAULT_METRIC_CONFIGS)) {
      this.reportMetricConfigs.set(key, { ...config });
    }
    console.log(`✓ Initialized ${this.reportMetricConfigs.size} metric configurations`);
  }

  private initializeSheetMappings() {
    SHEET_MAPPING_DEFAULT_LIST.forEach((mapping) => {
      this.sheetMappings.set(mapping.sheetType, cloneSheetMapping(mapping));
    });
  }

  /**
   * Load worksheet cache from disk
   */
  private loadWorksheetCache() {
    try {
      const data = require('fs').readFileSync(WORKSHEET_CACHE_PATH, 'utf-8');
      const cached = JSON.parse(data);

      if (Array.isArray(cached)) {
        cached.forEach((ws: any) => {
          // Restore essential fields, convert date strings back to Date objects
          const worksheet: Worksheet = {
            ...ws,
            lastSyncAt: ws.lastSyncAt ? new Date(ws.lastSyncAt) : new Date(),
            createdAt: ws.createdAt ? new Date(ws.createdAt) : new Date(),
          };
          this.worksheets.set(worksheet.id, worksheet);
        });
        console.log(`✓ Loaded ${cached.length} worksheets from cache`);
      }
    } catch (error: any) {
      // File doesn't exist or parse error - skip silently
      if (error.code !== 'ENOENT') {
        console.warn('⚠️  Failed to load worksheet cache:', error.message);
      }
    }
  }

  /**
   * Persist worksheet cache to disk
   */
  private async persistWorksheetCache() {
    try {
      const cacheDir = path.dirname(WORKSHEET_CACHE_PATH);
      await fs.mkdir(cacheDir, { recursive: true });

      const worksheetsArray = Array.from(this.worksheets.values()).map(ws => ({
        id: ws.id,
        spreadsheetId: ws.spreadsheetId,
        worksheetName: ws.worksheetName,
        gid: ws.gid,
        range: ws.range,
        isEnabled: ws.isEnabled,
        supabaseTable: ws.supabaseTable,
        headers: ws.headers,
        rowCount: ws.rowCount,
        lastSyncAt: ws.lastSyncAt?.toISOString(),
        createdAt: ws.createdAt?.toISOString(),
      }));

      await fs.writeFile(WORKSHEET_CACHE_PATH, JSON.stringify(worksheetsArray, null, 2), 'utf-8');
    } catch (error: any) {
      console.error('❌ Failed to persist worksheet cache:', error.message);
    }
  }

  // User operations - IMPORTANT: Required for Replit Auth
  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const existingUser = this.users.get(userData.id!);
    const user: User = {
      id: userData.id!,
      email: userData.email || null,
      firstName: userData.firstName || null,
      lastName: userData.lastName || null,
      profileImageUrl: userData.profileImageUrl || null,
      role: userData.role || "user",
      department: userData.department || null,
      status: userData.status || "active",
      lastLoginAt: existingUser ? new Date() : null,
      createdAt: existingUser?.createdAt || new Date(),
      updatedAt: new Date(),
    };
    this.users.set(userData.id!, user);
    return user;
  }

  async updateUserLastLogin(id: string): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updated = { ...user, lastLoginAt: new Date(), updatedAt: new Date() };
    this.users.set(id, updated);
    return updated;
  }

  async listUsers(): Promise<User[]> {
    return Array.from(this.users.values());
  }

  async updateUserRole(id: string, role: string, department?: string): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updated = { 
      ...user, 
      role, 
      department: department || user.department,
      updatedAt: new Date() 
    };
    this.users.set(id, updated);
    return updated;
  }

  async updateUserStatus(id: string, status: string, role?: string): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updated = { 
      ...user, 
      status,
      role: role || user.role,
      updatedAt: new Date() 
    };
    this.users.set(id, updated);
    return updated;
  }

  async updateUserProfile(id: string, profileData: {
    firstName?: string;
    lastName?: string;
    email?: string;
    department?: string;
  }): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updated = { 
      ...user, 
      ...profileData,
      updatedAt: new Date() 
    };
    this.users.set(id, updated);
    return updated;
  }

  // Role operations
  async getRole(name: string): Promise<Role | undefined> {
    return Array.from(this.roles.values()).find(role => role.name === name);
  }

  async createRole(insertRole: InsertRole): Promise<Role> {
    const id = randomUUID();
    const role: Role = {
      id,
      name: insertRole.name,
      displayName: insertRole.displayName,
      permissions: Array.isArray(insertRole.permissions) ? insertRole.permissions.map(String) : [],
      spreadsheetAccess: Array.isArray(insertRole.spreadsheetAccess) ? insertRole.spreadsheetAccess.map(String) : [],
      canManageUsers: insertRole.canManageUsers || false,
      canViewAllData: insertRole.canViewAllData || false,
      createdAt: new Date(),
    };
    this.roles.set(id, role);
    return role;
  }

  async updateRole(id: string, updates: Partial<Role>): Promise<Role | undefined> {
    const role = this.roles.get(id);
    if (!role) return undefined;
    
    const updated = { ...role, ...updates };
    this.roles.set(id, updated);
    return updated;
  }

  async listRoles(): Promise<Role[]> {
    return Array.from(this.roles.values());
  }

  async deleteRole(id: string): Promise<boolean> {
    return this.roles.delete(id);
  }


  async getSpreadsheet(id: string): Promise<Spreadsheet | undefined> {
    return this.spreadsheets.get(id);
  }

  async getSpreadsheetBySheetId(spreadsheetId: string): Promise<Spreadsheet | undefined> {
    return Array.from(this.spreadsheets.values()).find(
      (sheet) => sheet.spreadsheetId === spreadsheetId
    );
  }

  async createSpreadsheet(insertSpreadsheet: InsertSpreadsheet): Promise<Spreadsheet> {
    const id = randomUUID();
    const spreadsheet: Spreadsheet = {
      ...insertSpreadsheet,
      id,
      lastSyncAt: new Date(),
      rowCount: 0,
      createdAt: new Date(),
      headers: (insertSpreadsheet.headers as string[]) || null,
      range: insertSpreadsheet.range || null,
    };
    this.spreadsheets.set(id, spreadsheet);
    return spreadsheet;
  }

  async updateSpreadsheet(id: string, updates: Partial<Spreadsheet>): Promise<Spreadsheet | undefined> {
    const spreadsheet = this.spreadsheets.get(id);
    if (!spreadsheet) return undefined;
    
    const updated = { ...spreadsheet, ...updates };
    this.spreadsheets.set(id, updated);
    return updated;
  }

  async listSpreadsheets(): Promise<Spreadsheet[]> {
    return Array.from(this.spreadsheets.values());
  }

  async deleteSpreadsheet(id: string): Promise<boolean> {
    const spreadsheet = this.spreadsheets.get(id);
    if (!spreadsheet) {
      console.log(`Spreadsheet ${id} not found`);
      return false;
    }

    console.log(`Deleting spreadsheet ${id} (Google Sheets ID: ${spreadsheet.spreadsheetId})`);

    // Delete associated worksheets and data
    const worksheetsDeleted = await this.deleteWorksheets(spreadsheet.spreadsheetId);
    console.log(`Deleted worksheets for ${spreadsheet.spreadsheetId}: ${worksheetsDeleted}`);

    const dataDeleted = await this.deleteSheetData(spreadsheet.spreadsheetId);
    console.log(`Deleted sheet data for ${spreadsheet.spreadsheetId}: ${dataDeleted}`);

    const result = this.spreadsheets.delete(id);
    console.log(`Spreadsheet ${id} deleted: ${result}`);

    return result;
  }

  // Worksheet operations
  async getWorksheets(spreadsheetId: string): Promise<Worksheet[]> {
    return Array.from(this.worksheets.values())
      .filter(worksheet => worksheet.spreadsheetId === spreadsheetId);
  }

  async createWorksheet(insertWorksheet: InsertWorksheet): Promise<Worksheet> {
    // Use deterministic ID if spreadsheetId and gid are provided
    const id = (insertWorksheet.spreadsheetId && insertWorksheet.gid)
      ? createDeterministicWorksheetId(insertWorksheet.spreadsheetId, insertWorksheet.gid)
      : randomUUID();

    // Check if worksheet already exists (preserve supabaseTable, createdAt, etc.)
    const existing = this.worksheets.get(id);

    const worksheet: Worksheet = {
      ...insertWorksheet,
      id,
      lastSyncAt: new Date(),
      createdAt: existing?.createdAt || new Date(),
      headers: (insertWorksheet.headers as string[]) || null,
      rowCount: insertWorksheet.rowCount ?? 0,
      isEnabled: insertWorksheet.isEnabled ?? (existing?.isEnabled ?? true),
      range: insertWorksheet.range || existing?.range || "A1:Z1000",
      supabaseTable: insertWorksheet.supabaseTable || existing?.supabaseTable,
    };

    this.worksheets.set(id, worksheet);
    await this.persistWorksheetCache();
    return worksheet;
  }

  async getWorksheet(id: string): Promise<Worksheet | undefined> {
    return this.worksheets.get(id);
  }

  async updateWorksheet(id: string, updates: Partial<Worksheet>): Promise<Worksheet | undefined> {
    const worksheet = this.worksheets.get(id);
    if (!worksheet) return undefined;

    const updated = { ...worksheet, ...updates };
    this.worksheets.set(id, updated);
    await this.persistWorksheetCache();
    return updated;
  }

  async deleteWorksheets(spreadsheetId: string): Promise<boolean> {
    let deleted = false;
    const entriesToDelete = Array.from(this.worksheets.entries()).filter(
      ([_, worksheet]) => worksheet.spreadsheetId === spreadsheetId
    );

    console.log(`Found ${entriesToDelete.length} worksheets to delete for spreadsheet ${spreadsheetId}`);

    for (const [id, worksheet] of entriesToDelete) {
      console.log(`Deleting worksheet ${id} (${worksheet.worksheetName})`);
      await this.deleteWorksheetData(id);
      this.worksheets.delete(id);
      deleted = true;
    }

    if (deleted) {
      await this.persistWorksheetCache();
    }
    return deleted;
  }

  async toggleWorksheetSync(id: string, isEnabled: boolean): Promise<Worksheet | undefined> {
    const worksheet = this.worksheets.get(id);
    if (!worksheet) return undefined;

    const updated = { ...worksheet, isEnabled };
    this.worksheets.set(id, updated);
    await this.persistWorksheetCache();
    return updated;
  }

  async deleteWorksheet(id: string): Promise<boolean> {
    const worksheet = this.worksheets.get(id);
    if (!worksheet) return false;

    // Delete worksheet data first
    await this.deleteWorksheetData(id);

    // Then delete the worksheet record
    const deleted = this.worksheets.delete(id);
    if (deleted) {
      await this.persistWorksheetCache();
    }
    return deleted;
  }

  async getAllWorksheets(): Promise<Worksheet[]> {
    return Array.from(this.worksheets.values());
  }

  async getSheetData(spreadsheetId: string, page = 1, limit = 50): Promise<SheetData[]> {
    const data = Array.from(this.sheetData.values())
      .filter(item => item.spreadsheetId === spreadsheetId)
      .sort((a, b) => a.rowIndex - b.rowIndex);
    
    const start = (page - 1) * limit;
    const end = start + limit;
    return data.slice(start, end);
  }

  async getWorksheetData(worksheetId: string, page?: number, limit?: number): Promise<SheetData[]> {
    const data = Array.from(this.sheetData.values())
      .filter(item => item.worksheetId === worksheetId)
      .sort((a, b) => a.rowIndex - b.rowIndex);

    // If no pagination parameters provided, return all data
    if (page === undefined || limit === undefined) {
      return data;
    }

    const start = (page - 1) * limit;
    const end = start + limit;
    return data.slice(start, end);
  }

  async createSheetData(insertData: InsertSheetData): Promise<SheetData> {
    const id = randomUUID();
    const data: SheetData = {
      ...insertData,
      id,
      lastUpdated: new Date(),
      worksheetId: insertData.worksheetId || null,
    };
    this.sheetData.set(id, data);
    return data;
  }

  async updateSheetData(id: string, updates: Partial<SheetData>): Promise<SheetData | undefined> {
    const data = this.sheetData.get(id);
    if (!data) return undefined;
    
    const updated = { ...data, ...updates, lastUpdated: new Date() };
    this.sheetData.set(id, updated);
    return updated;
  }

  async deleteSheetData(spreadsheetId: string): Promise<boolean> {
    let deleted = false;
    const entriesToDelete = Array.from(this.sheetData.entries()).filter(
      ([_, data]) => data.spreadsheetId === spreadsheetId
    );
    
    for (const [id, _] of entriesToDelete) {
      this.sheetData.delete(id);
      deleted = true;
    }
    return deleted;
  }

  async deleteWorksheetData(worksheetId: string): Promise<boolean> {
    let deleted = false;
    const entriesToDelete = Array.from(this.sheetData.entries()).filter(
      ([_, data]) => data.worksheetId === worksheetId
    );
    
    for (const [id, _] of entriesToDelete) {
      this.sheetData.delete(id);
      deleted = true;
    }
    return deleted;
  }

  async upsertSheetData(spreadsheetId: string, rowIndex: number, data: Record<string, any>, worksheetId?: string): Promise<SheetData> {
    // Normalize worksheetId for comparison (convert undefined to null)
    const normalizedWorksheetId = worksheetId || null;
    
    // Find existing row with proper worksheet isolation
    const existing = Array.from(this.sheetData.values()).find(
      item => item.spreadsheetId === spreadsheetId && 
               item.rowIndex === rowIndex && 
               (item.worksheetId || null) === normalizedWorksheetId
    );

    if (existing) {
      return await this.updateSheetData(existing.id, { data }) || existing;
    } else {
      return await this.createSheetData({ 
        spreadsheetId, 
        rowIndex, 
        data, 
        worksheetId: normalizedWorksheetId 
      });
    }
  }

  async searchSheetData(spreadsheetId: string, query: string): Promise<SheetData[]> {
    const lowerQuery = query.toLowerCase();
    return Array.from(this.sheetData.values())
      .filter(item => 
        item.spreadsheetId === spreadsheetId &&
        JSON.stringify(item.data).toLowerCase().includes(lowerQuery)
      )
      .sort((a, b) => a.rowIndex - b.rowIndex);
  }

  async getSheetDataCount(spreadsheetId: string): Promise<number> {
    return Array.from(this.sheetData.values())
      .filter(item => item.spreadsheetId === spreadsheetId)
      .length;
  }

  // Dashboard Template operations
  async getDashboardTemplate(id: string): Promise<DashboardTemplate | undefined> {
    return this.dashboardTemplates.get(id);
  }

  async getDashboardTemplateByType(type: string): Promise<DashboardTemplate | undefined> {
    return Array.from(this.dashboardTemplates.values()).find(template => template.type === type);
  }

  async createDashboardTemplate(template: InsertDashboardTemplate): Promise<DashboardTemplate> {
    const id = randomUUID();
    const dashboardTemplate: DashboardTemplate = {
      id,
      name: template.name,
      displayName: template.displayName,
      type: template.type,
      description: template.description || null,
      config: template.config as any,
      isActive: template.isActive ?? true,
      isDefault: template.isDefault ?? false,
      createdAt: new Date(),
    };
    this.dashboardTemplates.set(id, dashboardTemplate);
    return dashboardTemplate;
  }

  async updateDashboardTemplate(id: string, updates: Partial<DashboardTemplate>): Promise<DashboardTemplate | undefined> {
    const template = this.dashboardTemplates.get(id);
    if (!template) return undefined;
    
    const updatedTemplate = { ...template, ...updates };
    this.dashboardTemplates.set(id, updatedTemplate);
    return updatedTemplate;
  }

  async listDashboardTemplates(): Promise<DashboardTemplate[]> {
    return Array.from(this.dashboardTemplates.values());
  }

  async listActiveDashboardTemplates(): Promise<DashboardTemplate[]> {
    return Array.from(this.dashboardTemplates.values()).filter(template => template.isActive);
  }

  async deleteDashboardTemplate(id: string): Promise<boolean> {
    return this.dashboardTemplates.delete(id);
  }

  // Custom Dashboard operations
  async getCustomDashboard(id: string): Promise<CustomDashboard | undefined> {
    return this.customDashboards.get(id);
  }

  async createCustomDashboard(dashboard: InsertCustomDashboard): Promise<CustomDashboard> {
    const id = randomUUID();
    const customDashboard: CustomDashboard = {
      id,
      name: dashboard.name,
      description: dashboard.description || null,
      config: dashboard.config as any,
      templateId: dashboard.templateId || null,
      userId: dashboard.userId || '',
      isPublic: dashboard.isPublic ?? false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    this.customDashboards.set(id, customDashboard);
    return customDashboard;
  }

  async updateCustomDashboard(id: string, updates: Partial<CustomDashboard>): Promise<CustomDashboard | undefined> {
    const dashboard = this.customDashboards.get(id);
    if (!dashboard) return undefined;
    
    const updatedDashboard = { ...dashboard, ...updates, updatedAt: new Date() };
    this.customDashboards.set(id, updatedDashboard);
    return updatedDashboard;
  }

  async listCustomDashboards(userId?: string): Promise<CustomDashboard[]> {
    const dashboards = Array.from(this.customDashboards.values());
    if (userId) {
      return dashboards.filter(dashboard => dashboard.userId === userId);
    }
    return dashboards;
  }

  async listPublicCustomDashboards(): Promise<CustomDashboard[]> {
    return Array.from(this.customDashboards.values()).filter(dashboard => dashboard.isPublic);
  }

  async deleteCustomDashboard(id: string): Promise<boolean> {
    return this.customDashboards.delete(id);
  }

  // Calculation Rule operations
  async getCalculationRule(id: string): Promise<CalculationRule | undefined> {
    return this.calculationRules.get(id);
  }

  async getCalculationRuleByName(name: string): Promise<CalculationRule | undefined> {
    return Array.from(this.calculationRules.values()).find(rule => rule.name === name);
  }

  async createCalculationRule(rule: InsertCalculationRule): Promise<CalculationRule> {
    const id = randomUUID();
    const calculationRule: CalculationRule = {
      id,
      name: rule.name,
      displayName: rule.displayName,
      description: rule.description || null,
      isActive: rule.isActive ?? true,
      sourceFields: Array.isArray(rule.sourceFields) ? rule.sourceFields.map(String) : [],
      formula: rule.formula,
      resultType: rule.resultType || "number",
      category: rule.category || null,
      createdAt: new Date(),
    };
    this.calculationRules.set(id, calculationRule);
    return calculationRule;
  }

  async updateCalculationRule(id: string, updates: Partial<CalculationRule>): Promise<CalculationRule | undefined> {
    const rule = this.calculationRules.get(id);
    if (!rule) return undefined;
    
    const updatedRule = { ...rule, ...updates };
    this.calculationRules.set(id, updatedRule);
    return updatedRule;
  }

  async listCalculationRules(category?: string): Promise<CalculationRule[]> {
    const rules = Array.from(this.calculationRules.values());
    if (category) {
      return rules.filter(rule => rule.category === category);
    }
    return rules;
  }

  async listActiveCalculationRules(): Promise<CalculationRule[]> {
    return Array.from(this.calculationRules.values()).filter(rule => rule.isActive);
  }

  async deleteCalculationRule(id: string): Promise<boolean> {
    return this.calculationRules.delete(id);
  }

  // Data Source Mapping operations
  async getDataSourceMapping(id: string): Promise<DataSourceMapping | undefined> {
    return this.dataSourceMappings.get(id);
  }

  async getDataSourceMappingByName(name: string): Promise<DataSourceMapping | undefined> {
    return Array.from(this.dataSourceMappings.values()).find(mapping => mapping.name === name);
  }

  async createDataSourceMapping(mapping: InsertDataSourceMapping): Promise<DataSourceMapping> {
    const id = randomUUID();
    const dataSourceMapping: DataSourceMapping = {
      id,
      name: mapping.name,
      displayName: mapping.displayName,
      sourceType: mapping.sourceType,
      worksheetId: mapping.worksheetId || null,
      calculationRuleId: mapping.calculationRuleId || null,
      fieldMappings: mapping.fieldMappings || {},
      refreshInterval: mapping.refreshInterval || null,
      isActive: mapping.isActive ?? true,
      createdAt: new Date(),
    };
    this.dataSourceMappings.set(id, dataSourceMapping);
    return dataSourceMapping;
  }

  async updateDataSourceMapping(id: string, updates: Partial<DataSourceMapping>): Promise<DataSourceMapping | undefined> {
    const mapping = this.dataSourceMappings.get(id);
    if (!mapping) return undefined;
    
    const updatedMapping = { ...mapping, ...updates };
    this.dataSourceMappings.set(id, updatedMapping);
    return updatedMapping;
  }

  async listDataSourceMappings(): Promise<DataSourceMapping[]> {
    return Array.from(this.dataSourceMappings.values());
  }

  async listActiveDataSourceMappings(): Promise<DataSourceMapping[]> {
    return Array.from(this.dataSourceMappings.values()).filter(mapping => mapping.isActive);
  }

  async deleteDataSourceMapping(id: string): Promise<boolean> {
    return this.dataSourceMappings.delete(id);
  }

  // Data Source Relationship operations
  async getDataSourceRelationship(id: string): Promise<DataSourceRelationship | undefined> {
    return this.dataSourceRelationships.get(id);
  }

  async getDataSourceRelationshipByName(name: string): Promise<DataSourceRelationship | undefined> {
    return Array.from(this.dataSourceRelationships.values()).find(relationship => relationship.name === name);
  }

  async createDataSourceRelationship(relationship: InsertDataSourceRelationship): Promise<DataSourceRelationship> {
    const id = randomUUID();
    const dataSourceRelationship: DataSourceRelationship = {
      id,
      name: relationship.name,
      displayName: relationship.displayName,
      description: relationship.description || null,
      primarySourceId: relationship.primarySourceId,
      secondarySourceId: relationship.secondarySourceId,
      joinType: relationship.joinType,
      primaryKey: relationship.primaryKey,
      foreignKey: relationship.foreignKey,
      isActive: relationship.isActive ?? true,
      createdAt: new Date(),
    };
    this.dataSourceRelationships.set(id, dataSourceRelationship);
    return dataSourceRelationship;
  }

  async updateDataSourceRelationship(id: string, updates: Partial<DataSourceRelationship>): Promise<DataSourceRelationship | undefined> {
    const relationship = this.dataSourceRelationships.get(id);
    if (!relationship) return undefined;
    
    const updated = { ...relationship, ...updates };
    this.dataSourceRelationships.set(id, updated);
    return updated;
  }

  async listDataSourceRelationships(): Promise<DataSourceRelationship[]> {
    return Array.from(this.dataSourceRelationships.values());
  }

  async listActiveDataSourceRelationships(): Promise<DataSourceRelationship[]> {
    return Array.from(this.dataSourceRelationships.values()).filter(relationship => relationship.isActive);
  }

  async deleteDataSourceRelationship(id: string): Promise<boolean> {
    return this.dataSourceRelationships.delete(id);
  }

  // Purchase Record operations
  async getPurchaseRecord(id: string): Promise<PurchaseRecord | undefined> {
    return this.purchaseRecords.get(id);
  }

  async createPurchaseRecord(record: InsertPurchaseRecord): Promise<PurchaseRecord> {
    const id = randomUUID();
    const purchaseRecord: PurchaseRecord = {
      id,
      studentName: record.studentName,
      studentEmail: record.studentEmail?.toLowerCase() || null,
      studentPhone: record.studentPhone || null,
      courseName: record.courseName,
      courseType: record.courseType || null,
      transactionAmount: record.transactionAmount,
      currency: record.currency || 'TWD',
      paymentMethod: record.paymentMethod || null,
      transactionStatus: record.transactionStatus,
      salesPerson: record.salesPerson || null,
      purchaseDate: record.purchaseDate,
      worksheetId: record.worksheetId || null,
      originalRowId: record.originalRowId || null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    this.purchaseRecords.set(id, purchaseRecord);
    return purchaseRecord;
  }

  async updatePurchaseRecord(id: string, updates: Partial<PurchaseRecord>): Promise<PurchaseRecord | undefined> {
    const record = this.purchaseRecords.get(id);
    if (!record) return undefined;
    
    // Normalize email if provided
    const normalizedUpdates = { ...updates };
    if (normalizedUpdates.studentEmail) {
      normalizedUpdates.studentEmail = normalizedUpdates.studentEmail.toLowerCase();
    }
    
    const updated = { ...record, ...normalizedUpdates, updatedAt: new Date() };
    this.purchaseRecords.set(id, updated);
    return updated;
  }

  async listPurchaseRecords(filters?: { studentName?: string; courseType?: string; status?: string }): Promise<PurchaseRecord[]> {
    let records = Array.from(this.purchaseRecords.values());
    
    if (filters) {
      if (filters.studentName) {
        records = records.filter(record => 
          record.studentName.toLowerCase().includes(filters.studentName!.toLowerCase())
        );
      }
      if (filters.courseType) {
        records = records.filter(record => record.courseType === filters.courseType);
      }
      if (filters.status) {
        records = records.filter(record => record.transactionStatus === filters.status);
      }
    }
    
    return records.sort((a, b) => b.purchaseDate.getTime() - a.purchaseDate.getTime());
  }

  async deletePurchaseRecord(id: string): Promise<boolean> {
    return this.purchaseRecords.delete(id);
  }

  async getPurchaseRecordsByStudent(studentEmail: string): Promise<PurchaseRecord[]> {
    return Array.from(this.purchaseRecords.values())
      .filter(record => record.studentEmail === studentEmail)
      .sort((a, b) => b.purchaseDate.getTime() - a.purchaseDate.getTime());
  }

  async getPurchaseRecordsByDateRange(startDate: Date, endDate: Date): Promise<PurchaseRecord[]> {
    return Array.from(this.purchaseRecords.values())
      .filter(record => 
        record.purchaseDate >= startDate && record.purchaseDate <= endDate
      )
      .sort((a, b) => b.purchaseDate.getTime() - a.purchaseDate.getTime());
  }

  // Consultation Record operations
  async getConsultationRecord(id: string): Promise<ConsultationRecord | undefined> {
    return this.consultationRecords.get(id);
  }

  async createConsultationRecord(record: InsertConsultationRecord): Promise<ConsultationRecord> {
    const id = randomUUID();
    const consultationRecord: ConsultationRecord = {
      id,
      studentName: record.studentName,
      studentEmail: record.studentEmail?.toLowerCase() || null,
      studentPhone: record.studentPhone || null,
      consultationType: record.consultationType || null,
      consultationTopic: record.consultationTopic || null,
      consultantName: record.consultantName || null,
      scheduledDate: record.scheduledDate || null,
      actualDate: record.actualDate || null,
      duration: record.duration || null,
      status: record.status,
      outcome: record.outcome || null,
      followUpDate: record.followUpDate || null,
      notes: record.notes || null,
      worksheetId: record.worksheetId || null,
      originalRowId: record.originalRowId || null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    this.consultationRecords.set(id, consultationRecord);
    return consultationRecord;
  }

  async updateConsultationRecord(id: string, updates: Partial<ConsultationRecord>): Promise<ConsultationRecord | undefined> {
    const record = this.consultationRecords.get(id);
    if (!record) return undefined;
    
    // Normalize email if provided
    const normalizedUpdates = { ...updates };
    if (normalizedUpdates.studentEmail) {
      normalizedUpdates.studentEmail = normalizedUpdates.studentEmail.toLowerCase();
    }
    
    const updated = { ...record, ...normalizedUpdates, updatedAt: new Date() };
    this.consultationRecords.set(id, updated);
    return updated;
  }

  async listConsultationRecords(filters?: { studentName?: string; status?: string; consultantName?: string }): Promise<ConsultationRecord[]> {
    let records = Array.from(this.consultationRecords.values());
    
    if (filters) {
      if (filters.studentName) {
        records = records.filter(record => 
          record.studentName.toLowerCase().includes(filters.studentName!.toLowerCase())
        );
      }
      if (filters.status) {
        records = records.filter(record => record.status === filters.status);
      }
      if (filters.consultantName) {
        records = records.filter(record => record.consultantName === filters.consultantName);
      }
    }
    
    return records.sort((a, b) => {
      const dateA = a.scheduledDate || a.createdAt;
      const dateB = b.scheduledDate || b.createdAt;
      // Handle null cases
      if (!dateB || !dateA) return 0;
      return dateB.getTime() - dateA.getTime();
    });
  }

  async deleteConsultationRecord(id: string): Promise<boolean> {
    return this.consultationRecords.delete(id);
  }

  async getConsultationRecordsByStudent(studentEmail: string): Promise<ConsultationRecord[]> {
    return Array.from(this.consultationRecords.values())
      .filter(record => record.studentEmail === studentEmail)
      .sort((a, b) => {
        const dateA = a.scheduledDate || a.createdAt;
        const dateB = b.scheduledDate || b.createdAt;
        // Handle null cases
        if (!dateB || !dateA) return 0;
        return dateB.getTime() - dateA.getTime();
      });
  }

  async getConsultationRecordsByDateRange(startDate: Date, endDate: Date): Promise<ConsultationRecord[]> {
    return Array.from(this.consultationRecords.values())
      .filter(record => {
        const date = record.scheduledDate || record.actualDate || record.createdAt;
        // Handle null case
        if (!date) return false;
        return date >= startDate && date <= endDate;
      })
      .sort((a, b) => {
        const dateA = a.scheduledDate || a.createdAt;
        const dateB = b.scheduledDate || b.createdAt;
        // Handle null cases
        if (!dateB || !dateA) return 0;
        return dateB.getTime() - dateA.getTime();
      });
  }

  // Multi-Source Analytics operations
  async getMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined> {
    return this.multiSourceAnalytics.get(id);
  }

  async createMultiSourceAnalytic(analytic: InsertMultiSourceAnalytic): Promise<MultiSourceAnalytic> {
    const id = randomUUID();
    const multiSourceAnalytic: MultiSourceAnalytic = {
      id,
      name: analytic.name,
      displayName: analytic.displayName,
      description: analytic.description || null,
      sourceRelationshipIds: Array.isArray(analytic.sourceRelationshipIds)
        ? analytic.sourceRelationshipIds.map(String)
        : [],
      analysisType: analytic.analysisType,
      filters: analytic.filters || {},
      aggregationRules: analytic.aggregationRules || {},
      resultCache: analytic.resultCache || {},
      lastCalculated: null,
      isActive: analytic.isActive ?? true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    this.multiSourceAnalytics.set(id, multiSourceAnalytic);
    return multiSourceAnalytic;
  }

  async updateMultiSourceAnalytic(id: string, updates: Partial<MultiSourceAnalytic>): Promise<MultiSourceAnalytic | undefined> {
    const analytic = this.multiSourceAnalytics.get(id);
    if (!analytic) return undefined;
    
    const updated = { ...analytic, ...updates, updatedAt: new Date() };
    this.multiSourceAnalytics.set(id, updated);
    return updated;
  }

  async listMultiSourceAnalytics(analysisType?: string): Promise<MultiSourceAnalytic[]> {
    let analytics = Array.from(this.multiSourceAnalytics.values());

    if (analysisType) {
      analytics = analytics.filter(analytic => analytic.analysisType === analysisType);
    }

    return analytics.sort((a, b) => {
      // Handle null cases for createdAt
      if (!b.createdAt || !a.createdAt) return 0;
      return b.createdAt.getTime() - a.createdAt.getTime();
    });
  }

  async deleteMultiSourceAnalytic(id: string): Promise<boolean> {
    return this.multiSourceAnalytics.delete(id);
  }

  async calculateMultiSourceAnalytic(id: string): Promise<MultiSourceAnalytic | undefined> {
    const analytic = this.multiSourceAnalytics.get(id);
    if (!analytic) return undefined;

    // Placeholder for actual calculation logic
    // This would implement cross-source joins and analysis based on the configuration
    const calculatedResults = {
      timestamp: new Date(),
      totalRecords: 0,
      correlations: [],
      trends: [],
      conversions: []
    };

    const updated = {
      ...analytic,
      resultCache: calculatedResults,
      lastCalculated: new Date(),
      updatedAt: new Date()
    };

    this.multiSourceAnalytics.set(id, updated);
    return updated;
  }

  // Auto Analysis operations
  async getWorksheetAnalysis(worksheetId: string): Promise<WorksheetAnalysis | undefined> {
    return Array.from(this.worksheetAnalyses.values()).find(a => a.worksheetId === worksheetId);
  }

  async createWorksheetAnalysis(analysis: InsertWorksheetAnalysis): Promise<WorksheetAnalysis> {
    const id = randomUUID();
    const now = new Date();
    const newAnalysis: WorksheetAnalysis = {
      id,
      worksheetId: analysis.worksheetId,
      category: analysis.category,
      confidence: analysis.confidence,
      columnAnalyses: Array.isArray(analysis.columnAnalyses)
        ? analysis.columnAnalyses.map((col: any) => ({
            name: col.name,
            type: col.type,
            confidence: col.confidence,
            samples: col.samples,
            nullCount: col.nullCount,
            uniqueCount: col.uniqueCount,
            patterns: col.patterns
          }))
        : [],
      rowCount: analysis.rowCount,
      dataQuality: analysis.dataQuality,
      suggestedReports: Array.isArray(analysis.suggestedReports)
        ? analysis.suggestedReports.map((report: any) => ({
            type: report.type,
            title: report.title,
            description: report.description,
            chartType: report.chartType,
            metrics: Array.isArray(report.metrics)
              ? report.metrics.map((metric: any) => ({
                  column: metric.column,
                  aggregation: metric.aggregation
                }))
              : [],
            filters: report.filters,
            groupBy: report.groupBy,
            confidence: report.confidence
          }))
        : [],
      lastAnalyzedAt: now,
      createdAt: now,
    };
    this.worksheetAnalyses.set(id, newAnalysis);
    return newAnalysis;
  }

  async updateWorksheetAnalysis(id: string, updates: Partial<WorksheetAnalysis>): Promise<WorksheetAnalysis | undefined> {
    const existing = this.worksheetAnalyses.get(id);
    if (!existing) return undefined;

    const updated: WorksheetAnalysis = {
      ...existing,
      ...updates,
      lastAnalyzedAt: new Date(),
    };
    this.worksheetAnalyses.set(id, updated);
    return updated;
  }

  async listWorksheetAnalyses(spreadsheetId?: string): Promise<WorksheetAnalysis[]> {
    let analyses = Array.from(this.worksheetAnalyses.values());

    if (spreadsheetId) {
      // Filter by worksheets belonging to the spreadsheet
      const worksheets = await this.getWorksheets(spreadsheetId);
      const worksheetIds = new Set(worksheets.map(w => w.id));
      analyses = analyses.filter(a => worksheetIds.has(a.worksheetId));
    }

    return analyses.sort((a, b) => {
      // Handle null cases for lastAnalyzedAt
      if (!b.lastAnalyzedAt || !a.lastAnalyzedAt) return 0;
      return b.lastAnalyzedAt.getTime() - a.lastAnalyzedAt.getTime();
    });
  }

  async deleteWorksheetAnalysis(id: string): Promise<boolean> {
    const deleted = this.worksheetAnalyses.delete(id);

    // Also delete associated auto-generated reports
    if (deleted) {
      const reports = Array.from(this.autoGeneratedReports.values())
        .filter(r => r.worksheetAnalysisId === id);

      for (const report of reports) {
        this.autoGeneratedReports.delete(report.id);
      }
    }

    return deleted;
  }

  // Auto Generated Reports operations
  async getAutoGeneratedReport(id: string): Promise<AutoGeneratedReport | undefined> {
    return this.autoGeneratedReports.get(id);
  }

  async createAutoGeneratedReport(report: InsertAutoGeneratedReport): Promise<AutoGeneratedReport> {
    const id = randomUUID();
    const now = new Date();
    const newReport: AutoGeneratedReport = {
      id,
      worksheetAnalysisId: report.worksheetAnalysisId,
      reportType: report.reportType,
      title: report.title,
      description: report.description || null,
      config: {
        chartType: report.config.chartType as any,
        metrics: Array.isArray(report.config.metrics)
          ? report.config.metrics.map((metric: any) => ({
              column: metric.column,
              aggregation: metric.aggregation
            }))
          : [],
        filters: report.config.filters as any,
        groupBy: report.config.groupBy as any
      },
      data: report.data || null,
      isActive: report.isActive ?? true,
      lastGeneratedAt: now,
      createdAt: now,
    };
    this.autoGeneratedReports.set(id, newReport);
    return newReport;
  }

  async updateAutoGeneratedReport(id: string, updates: Partial<AutoGeneratedReport>): Promise<AutoGeneratedReport | undefined> {
    const existing = this.autoGeneratedReports.get(id);
    if (!existing) return undefined;

    const updated: AutoGeneratedReport = {
      ...existing,
      ...updates,
      lastGeneratedAt: new Date(),
    };
    this.autoGeneratedReports.set(id, updated);
    return updated;
  }

  async listAutoGeneratedReports(worksheetAnalysisId?: string): Promise<AutoGeneratedReport[]> {
    let reports = Array.from(this.autoGeneratedReports.values());

    if (worksheetAnalysisId) {
      reports = reports.filter(r => r.worksheetAnalysisId === worksheetAnalysisId);
    }

    return reports
      .filter(r => r.isActive)
      .sort((a, b) => {
        // Handle null cases for lastGeneratedAt
        if (!b.lastGeneratedAt || !a.lastGeneratedAt) return 0;
        return b.lastGeneratedAt.getTime() - a.lastGeneratedAt.getTime();
      });
  }

  async deleteAutoGeneratedReport(id: string): Promise<boolean> {
    return this.autoGeneratedReports.delete(id);
  }

  async getAutoGeneratedReportsByWorksheet(worksheetId: string): Promise<AutoGeneratedReport[]> {
    const analysis = await this.getWorksheetAnalysis(worksheetId);
    if (!analysis) return [];

    return this.listAutoGeneratedReports(analysis.id);
  }

  // Sheet Mapping configuration operations
  private normalizeSheetMappingField(field: SheetMappingField): SheetMappingField {
    const supabaseColumn = field.supabaseColumn.trim();
    const aliasSet = new Set<string>();

    for (const alias of field.aliases ?? []) {
      const trimmed = alias.trim();
      if (trimmed.length > 0) {
        aliasSet.add(trimmed);
      }
    }

    const aliases = Array.from(aliasSet);
    const allowedTransforms = new Set(['date', 'number', 'boolean']);

    let transform = field.transform;
    if (transform !== undefined && transform !== null && !allowedTransforms.has(transform)) {
      transform = undefined;
    }

    const normalized: SheetMappingField = {
      supabaseColumn,
      aliases,
    };

    if (field.required !== undefined) {
      normalized.required = field.required;
    }

    if (transform !== undefined) {
      normalized.transform = transform;
    } else if (field.transform === null) {
      normalized.transform = null;
    }

    return normalized;
  }

  async getSheetMappings(): Promise<SheetFieldMapping[]> {
    return Array.from(this.sheetMappings.values()).map((mapping) => cloneSheetMapping(mapping));
  }

  async getSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping | undefined> {
    const stored = this.sheetMappings.get(sheetType);
    if (!stored) {
      return undefined;
    }
    return cloneSheetMapping(stored);
  }

  async updateSheetMapping(
    sheetType: SheetType,
    updates: SheetMappingUpdateInput
  ): Promise<SheetFieldMapping> {
    const existing = this.sheetMappings.get(sheetType) ?? getDefaultSheetMapping(sheetType);
    const base = cloneSheetMapping(existing);

    const order: string[] = base.fields.map((field) => field.supabaseColumn);
    const fieldMap = new Map<string, SheetMappingField>();

    base.fields.forEach((field) => {
      fieldMap.set(field.supabaseColumn, this.normalizeSheetMappingField(field));
    });

    if (updates.fields) {
      updates.fields.forEach((fieldUpdate) => {
        const existingField = fieldMap.get(fieldUpdate.supabaseColumn);
        const mergedField = this.normalizeSheetMappingField({
          ...(existingField ?? { aliases: [] as string[], supabaseColumn: fieldUpdate.supabaseColumn }),
          ...fieldUpdate,
          aliases: fieldUpdate.aliases ?? existingField?.aliases ?? [],
        });

        fieldMap.set(fieldUpdate.supabaseColumn, mergedField);

        if (!order.includes(fieldUpdate.supabaseColumn)) {
          order.push(fieldUpdate.supabaseColumn);
        }
      });
    }

    const updatedFields = order
      .map((column) => fieldMap.get(column))
      .filter((field): field is SheetMappingField => field !== undefined);

    const updated: SheetFieldMapping = {
      ...base,
      keyStrategy: updates.keyStrategy ?? base.keyStrategy,
      fields: updatedFields,
    };

    this.sheetMappings.set(sheetType, cloneSheetMapping(updated));
    return cloneSheetMapping(updated);
  }

  async resetSheetMapping(sheetType: SheetType): Promise<SheetFieldMapping> {
    const defaults = getDefaultSheetMapping(sheetType);
    this.sheetMappings.set(sheetType, cloneSheetMapping(defaults));
    return cloneSheetMapping(defaults);
  }

  // Report Metric Config operations
  async getReportMetricConfigs(): Promise<ReportMetricConfig[]> {
    return Array.from(this.reportMetricConfigs.values());
  }

  async getReportMetricConfig(metricId: string): Promise<ReportMetricConfig | null> {
    return this.reportMetricConfigs.get(metricId) || null;
  }

  async updateReportMetricConfig(
    metricId: string,
    updates: Partial<ReportMetricConfig>
  ): Promise<ReportMetricConfig> {
    const existing = this.reportMetricConfigs.get(metricId);
    if (!existing) {
      throw new Error(`Metric config not found: ${metricId}`);
    }

    const updated: ReportMetricConfig = {
      ...existing,
      ...updates,
      metricId, // Ensure metricId is not changed
      updatedAt: new Date(),
    };

    this.reportMetricConfigs.set(metricId, updated);
    return updated;
  }

  async resetReportMetricConfig(metricId: string): Promise<ReportMetricConfig> {
    const defaultConfig = DEFAULT_METRIC_CONFIGS[metricId];
    if (!defaultConfig) {
      throw new Error(`Unknown metric: ${metricId}`);
    }

    const reset: ReportMetricConfig = {
      ...defaultConfig,
      manualFormula: undefined,
      aiSuggestedFormula: undefined,
      updatedAt: new Date(),
    };

    this.reportMetricConfigs.set(metricId, reset);
    return reset;
  }
}

// MIGRATED TO SUPABASE: Use Supabase-backed storage instead of MemStorage
export { storage } from './supabase-storage';

// NOTE: Test data initialization disabled - now using real Supabase data
/*
// Add test data for development/testing
(async () => {
  try {
    // Create dashboard templates for experience class business
    await storage.createDashboardTemplate({
      name: "體驗課客戶分析",
      displayName: "體驗課客戶分析儀表板",
      type: "experience_customers",
      description: "體驗課程客戶學習情況和轉換分析",
      config: {
        metrics: [
          {
            id: "total_students",
            name: "總體驗學生數",
            dataSource: "experience_course_records",
            calculation: "count",
            chartType: "number" as const,
            position: { x: 0, y: 0, w: 3, h: 2 }
          },
          {
            id: "active_students",
            name: "上課中學生數",
            dataSource: "experience_course_records",
            calculation: "count_where_confirmed",
            chartType: "number" as const,
            position: { x: 3, y: 0, w: 3, h: 2 }
          },
          {
            id: "conversion_rate",
            name: "購買轉換率",
            dataSource: "purchase_records",
            calculation: "conversion_percentage",
            chartType: "number" as const,
            position: { x: 6, y: 0, w: 3, h: 2 }
          },
          {
            id: "monthly_trend",
            name: "月度體驗課程趨勢",
            dataSource: "experience_course_records",
            calculation: "count_by_month",
            chartType: "line" as const,
            position: { x: 0, y: 2, w: 6, h: 4 }
          },
          {
            id: "teacher_performance",
            name: "授課老師績效",
            dataSource: "experience_course_records",
            calculation: "group_by_teacher",
            chartType: "bar" as const,
            position: { x: 6, y: 2, w: 6, h: 4 }
          }
        ],
        layout: {
          type: "grid",
          cols: 12,
          rows: 6
        },
        filters: [
          {
            id: "date_range",
            name: "日期範圍",
            type: "dateRange",
            defaultValue: "last_30_days"
          },
          {
            id: "teacher_filter",
            name: "授課老師",
            type: "select",
            dataSource: "teachers"
          }
        ]
      },
      isActive: true
    });

    await storage.createDashboardTemplate({
      name: "銷售業績分析",
      displayName: "銷售業績分析儀表板",
      type: "sales_performance",
      description: "銷售人員業績和購買記錄分析",
      config: {
        metrics: [
          {
            id: "total_revenue",
            name: "總銷售額",
            dataSource: "purchase_records",
            calculation: "sum_amount",
            chartType: "number" as const,
            position: { x: 0, y: 0, w: 3, h: 2 }
          },
          {
            id: "total_purchases",
            name: "總成交筆數",
            dataSource: "purchase_records",
            calculation: "count",
            chartType: "number" as const,
            position: { x: 3, y: 0, w: 3, h: 2 }
          },
          {
            id: "avg_order_value",
            name: "平均客單價",
            dataSource: "purchase_records",
            calculation: "average_amount",
            chartType: "number" as const,
            position: { x: 6, y: 0, w: 3, h: 2 }
          },
          {
            id: "revenue_trend",
            name: "銷售趨勢",
            dataSource: "purchase_records",
            calculation: "sum_by_month",
            chartType: "area" as const,
            position: { x: 0, y: 2, w: 8, h: 4 }
          },
          {
            id: "payment_methods",
            name: "付款方式分布",
            dataSource: "purchase_records",
            calculation: "group_by_payment_method",
            chartType: "pie" as const,
            position: { x: 8, y: 2, w: 4, h: 4 }
          }
        ],
        layout: {
          type: "grid",
          cols: 12,
          rows: 6
        },
        filters: [
          {
            id: "date_range",
            name: "日期範圍",
            type: "dateRange",
            defaultValue: "last_30_days"
          },
          {
            id: "payment_method",
            name: "付款方式",
            type: "select",
            dataSource: "payment_methods"
          }
        ]
      },
      isActive: true
    });

    await storage.createDashboardTemplate({
      name: "學員滿意度分析",
      displayName: "學員滿意度分析儀表板", 
      type: "student_satisfaction",
      description: "學員學習體驗和滿意度指標分析",
      config: {
        metrics: [
          {
            id: "satisfaction_score",
            name: "平均滿意度評分",
            dataSource: "feedback_surveys",
            calculation: "average_rating",
            chartType: "number" as const,
            position: { x: 0, y: 0, w: 3, h: 2 }
          },
          {
            id: "completion_rate",
            name: "課程完成率",
            dataSource: "experience_course_records",
            calculation: "completion_percentage",
            chartType: "number" as const,
            position: { x: 3, y: 0, w: 3, h: 2 }
          },
          {
            id: "referral_rate",
            name: "推薦率",
            dataSource: "referral_records",
            calculation: "referral_percentage",
            chartType: "number" as const,
            position: { x: 6, y: 0, w: 3, h: 2 }
          },
          {
            id: "satisfaction_trend",
            name: "滿意度趨勢",
            dataSource: "feedback_surveys",
            calculation: "avg_rating_by_month",
            chartType: "line" as const,
            position: { x: 0, y: 2, w: 8, h: 4 }
          },
          {
            id: "feedback_categories",
            name: "反饋類別分布",
            dataSource: "feedback_surveys",
            calculation: "group_by_category",
            chartType: "bar" as const,
            position: { x: 8, y: 2, w: 4, h: 4 }
          }
        ],
        layout: {
          type: "grid",
          cols: 12,
          rows: 6
        },
        filters: [
          {
            id: "date_range",
            name: "日期範圍",
            type: "dateRange",
            defaultValue: "last_30_days"
          },
          {
            id: "course_type",
            name: "課程類型",
            type: "select",
            dataSource: "course_types"
          }
        ]
      },
      isActive: true
    });

    await storage.createDashboardTemplate({
      name: "廣告效果分析",
      displayName: "廣告效果分析儀表板",
      type: "advertising_effectiveness",
      description: "廣告投放效果和ROI分析",
      config: {
        metrics: [
          {
            id: "total_impressions",
            name: "總曝光次數",
            dataSource: "advertising_campaigns",
            calculation: "sum_impressions",
            chartType: "number" as const,
            position: { x: 0, y: 0, w: 3, h: 2 }
          },
          {
            id: "total_clicks",
            name: "總點擊次數",
            dataSource: "advertising_campaigns",
            calculation: "sum_clicks",
            chartType: "number" as const,
            position: { x: 3, y: 0, w: 3, h: 2 }
          },
          {
            id: "ctr_rate",
            name: "點擊率 (CTR)",
            dataSource: "advertising_campaigns",
            calculation: "ctr_percentage",
            chartType: "number" as const,
            position: { x: 6, y: 0, w: 3, h: 2 }
          },
          {
            id: "roi_metric",
            name: "投資回報率 (ROI)",
            dataSource: "advertising_campaigns",
            calculation: "roi_percentage",
            chartType: "number" as const,
            position: { x: 9, y: 0, w: 3, h: 2 }
          },
          {
            id: "performance_trend",
            name: "廣告績效趨勢",
            dataSource: "advertising_campaigns",
            calculation: "performance_by_month",
            chartType: "line" as const,
            position: { x: 0, y: 2, w: 8, h: 4 }
          },
          {
            id: "channel_comparison",
            name: "廣告管道比較",
            dataSource: "advertising_campaigns",
            calculation: "group_by_channel",
            chartType: "bar" as const,
            position: { x: 8, y: 2, w: 4, h: 4 }
          }
        ],
        layout: {
          type: "grid",
          cols: 12,
          rows: 6
        },
        filters: [
          {
            id: "date_range",
            name: "日期範圍",
            type: "dateRange",
            defaultValue: "last_30_days"
          },
          {
            id: "campaign_type",
            name: "廣告類型",
            type: "select",
            dataSource: "campaign_types"
          },
          {
            id: "budget_range",
            name: "預算範圍",
            type: "number",
            defaultValue: 10000
          }
        ]
      },
      isActive: true
    });

    // Create calculation rules
    await storage.createCalculationRule({
      name: "count",
      displayName: "計算總數",
      formula: "COUNT(*)",
      resultType: "number",
      sourceFields: ["*"],
      category: "basic",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "count_where_confirmed", 
      displayName: "已確認數量",
      formula: "COUNT(*) WHERE 是否已確認 = '是'",
      resultType: "number",
      sourceFields: ["是否已確認"],
      category: "filter",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "conversion_percentage",
      displayName: "轉換率百分比",
      formula: "(COUNT(purchase_records) / COUNT(experience_course_records)) * 100",
      resultType: "percentage",
      sourceFields: ["purchase_records", "experience_course_records"],
      category: "conversion",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "sum_amount",
      displayName: "總金額",
      formula: "SUM(金額)",
      resultType: "currency",
      sourceFields: ["金額"],
      category: "financial",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "average_amount",
      displayName: "平均金額",
      formula: "AVG(金額)",
      resultType: "currency",
      sourceFields: ["金額"],
      category: "financial",
      isActive: true
    });

    // Create data source mappings for existing spreadsheets
    await storage.createDataSourceMapping({
      name: "experience_course_records",
      displayName: "體驗課上課記錄",
      sourceType: "google_sheets",
      worksheetId: "110563615",
      isActive: true,
      fieldMappings: {
        "姓名": "student_name",
        "email": "email",
        "上課日期": "class_date",
        "授課老師": "teacher",
        "是否已確認": "confirmed",
        "未聯繫原因": "no_contact_reason",
        "體驗課文字檔": "class_notes"
      },
      refreshInterval: 3600
    });

    await storage.createDataSourceMapping({
      name: "purchase_records",
      displayName: "體驗課購買記錄",
      sourceType: "google_sheets",
      worksheetId: "1234567890",
      isActive: true,
      fieldMappings: {
        "學生姓名": "student_name",
        "購買日期": "purchase_date",
        "課程類型": "course_type",
        "金額": "amount",
        "付款方式": "payment_method",
        "銷售人員": "sales_person"
      },
      refreshInterval: 3600
    });

    // Create advanced calculation rules for core metrics
    await storage.createCalculationRule({
      name: "count_by_month",
      displayName: "按月統計數量",
      formula: "GROUP BY MONTH(上課日期) COUNT(*)",
      resultType: "timeseries",
      sourceFields: ["上課日期"],
      category: "trend",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "group_by_teacher",
      displayName: "按老師分組統計",
      formula: "GROUP BY 授課老師 COUNT(*), SUM(CASE WHEN 是否已確認='是' THEN 1 ELSE 0 END)",
      resultType: "group",
      sourceFields: ["授課老師", "是否已確認"],
      category: "performance",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "completion_percentage",
      displayName: "完課率百分比",
      formula: "(COUNT(CASE WHEN 是否已確認='是' THEN 1 END) / COUNT(*)) * 100",
      resultType: "percentage",
      sourceFields: ["是否已確認"],
      category: "completion",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "teacher_conversion_rate",
      displayName: "老師轉換率",
      formula: "GROUP BY 授課老師 (COUNT(confirmed_students) / COUNT(total_students)) * 100",
      resultType: "percentage",
      sourceFields: ["授課老師", "是否已確認"],
      category: "conversion",
      isActive: true
    });

    await storage.createCalculationRule({
      name: "monthly_growth_rate",
      displayName: "月增長率",
      formula: "((THIS_MONTH_COUNT - LAST_MONTH_COUNT) / LAST_MONTH_COUNT) * 100",
      resultType: "percentage",
      sourceFields: ["上課日期"],
      category: "growth",
      isActive: true
    });

    // Create advanced data source mapping for purchase records (prepared for future use)
    await storage.createDataSourceMapping({
      name: "purchase_transactions",
      displayName: "購買交易記錄",
      sourceType: "google_sheets",
      worksheetId: null, // Will be set when purchase data is available
      isActive: false, // Inactive until purchase data is connected
      fieldMappings: {
        "學生姓名": "student_name",
        "購買日期": "purchase_date",
        "課程名稱": "course_name",
        "交易金額": "transaction_amount",
        "付款方式": "payment_method",
        "交易狀態": "transaction_status",
        "銷售人員": "sales_person"
      },
      refreshInterval: 1800
    });

    console.log("Dashboard templates, calculation rules, and data source mappings initialized successfully");

    // Add test spreadsheet
    const testSpreadsheet = await storage.createSpreadsheet({
      name: 'Test Spreadsheet',
      spreadsheetId: '1FZffolNcXjkZ-14vA3NVRdN7czm8E6JjdkGidn38LgM',
      range: 'A:Z',
      headers: ['姓名', 'email', '上課日期', '授課老師', '是否已確認', '未聯繫原因', '體驗課文字檔'],
      rowCount: 50
    });

    // Add test worksheets
    await storage.createWorksheet({
      gid: '110563615',
      worksheetName: '體驗課上課記錄表',
      spreadsheetId: '1FZffolNcXjkZ-14vA3NVRdN7czm8E6JjdkGidn38LgM',
      isEnabled: true,
      headers: ['姓名', 'email', '上課日期', '授課老師', '是否已確認', '未聯繫原因', '體驗課文字檔'],
      rowCount: 50,
      range: 'A1:G1000'
    });

    await storage.createWorksheet({
      gid: '468254899',
      worksheetName: '體驗課購買記錄表',
      spreadsheetId: '1FZffolNcXjkZ-14vA3NVRdN7czm8E6JjdkGidn38LgM',
      isEnabled: false,
      headers: ['姓名', 'email', '購買日期', '課程類型', '價格'],
      rowCount: 25,
      range: 'A1:E1000'
    });

    console.log('Test data initialized successfully');

    // Initialize multi-datasource sample data for Phase 6
    await initializeMultiDatasourceSampleData(storage);
    console.log('Multi-datasource sample data initialized successfully');
  } catch (error) {
    console.error('Error initializing test data:', error);
  }
})();

// Initialize comprehensive multi-datasource sample data for Phase 6 demonstration
async function initializeMultiDatasourceSampleData(storage: IStorage) {
  try {
    // Create sample purchase records showing complete student journeys
    const samplePurchases = [
      // Wang Xiaoming's complete journey: experience → regular → advanced
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        courseName: "JavaScript 體驗課程",
        courseType: "experience",
        transactionAmount: 199000, // $1990 TWD in cents
        paymentMethod: "credit_card",
        transactionStatus: "completed",
        salesPerson: "李銷售",
        purchaseDate: new Date("2024-07-01T10:00:00Z"),
        worksheetId: "110563615"
      },
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        courseName: "JavaScript 入門課程",
        courseType: "regular",
        transactionAmount: 599000, // $5990 TWD in cents
        paymentMethod: "credit_card",
        transactionStatus: "completed",
        salesPerson: "李銷售",
        purchaseDate: new Date("2024-08-15T10:00:00Z"),
        worksheetId: "110563615"
      },
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        courseName: "React 進階開發",
        courseType: "advanced",
        transactionAmount: 899000, // $8990 TWD in cents
        paymentMethod: "credit_card",
        transactionStatus: "completed",
        salesPerson: "李銷售",
        purchaseDate: new Date("2024-09-20T10:00:00Z"),
        worksheetId: "110563615"
      },
      // Zhang Meili's partial journey: experience → regular (stopped)
      {
        studentName: "張美麗",
        studentEmail: "meili.zhang@yahoo.com",
        studentPhone: "0987654321",
        courseName: "UI/UX 體驗課程",
        courseType: "experience",
        transactionAmount: 199000, // $1990 TWD in cents
        paymentMethod: "bank_transfer",
        transactionStatus: "completed",
        salesPerson: "陳銷售",
        purchaseDate: new Date("2024-07-10T14:30:00Z"),
        worksheetId: "110563615"
      },
      {
        studentName: "張美麗",
        studentEmail: "meili.zhang@yahoo.com",
        studentPhone: "0987654321",
        courseName: "UI/UX 設計基礎",
        courseType: "regular",
        transactionAmount: 599000, // $5990 TWD in cents
        paymentMethod: "bank_transfer",
        transactionStatus: "completed",
        salesPerson: "陳銷售",
        purchaseDate: new Date("2024-08-25T14:30:00Z"),
        worksheetId: "110563615"
      },
      // Lin Dahua's direct advanced purchase (experienced learner)
      {
        studentName: "林大華",
        studentEmail: "dahua.lin@hotmail.com",
        studentPhone: "0923456789",
        courseName: "Python 數據分析",
        courseType: "advanced",
        transactionAmount: 899000, // $8990 TWD in cents
        paymentMethod: "credit_card",
        transactionStatus: "completed",
        salesPerson: "李銷售",
        purchaseDate: new Date("2024-08-20T09:15:00Z"),
        worksheetId: "110563615"
      },
      // Chen Xiaofang's failed journey: experience only (did not convert)
      {
        studentName: "陳小芳",
        studentEmail: "xiaofang.chen@outlook.com",
        studentPhone: "0934567890",
        courseName: "Python 體驗課程",
        courseType: "experience",
        transactionAmount: 199000, // $1990 TWD in cents
        paymentMethod: "bank_transfer",
        transactionStatus: "completed",
        salesPerson: "陳銷售",
        purchaseDate: new Date("2024-08-05T16:00:00Z"),
        worksheetId: "110563615"
      },
      {
        studentName: "黃建國",
        studentEmail: "jianguo.huang@gmail.com",
        studentPhone: "0945678901",
        courseName: "Vue.js 全端開發",
        courseType: "regular",
        transactionAmount: 699000, // $6990 TWD in cents
        paymentMethod: "credit_card",
        transactionStatus: "completed",
        salesPerson: "王銷售",
        purchaseDate: new Date("2024-09-10T11:20:00Z"),
        worksheetId: "110563615"
      }
    ];

    // Create consultation records showing complete customer journeys
    const sampleConsultations = [
      // Wang Xiaoming's journey consultations
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        consultationType: "phone",
        consultationTopic: "課程選擇諮詢",
        consultantName: "張顧問",
        scheduledDate: new Date("2024-06-25T10:00:00Z"),
        actualDate: new Date("2024-06-25T10:05:00Z"),
        duration: 25,
        status: "completed",
        outcome: "interested",
        notes: "學生對 JavaScript 課程很感興趣，決定報名體驗課程",
        worksheetId: "110563615"
      },
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        consultationType: "online",
        consultationTopic: "進階課程規劃",
        consultantName: "張顧問",
        scheduledDate: new Date("2024-08-10T10:00:00Z"),
        actualDate: new Date("2024-08-10T10:00:00Z"),
        duration: 30,
        status: "completed",
        outcome: "interested",
        notes: "體驗課程完成，學生希望繼續學習正式課程",
        worksheetId: "110563615"
      },
      {
        studentName: "王小明",
        studentEmail: "xiaoming.wang@gmail.com",
        studentPhone: "0912345678",
        consultationType: "phone",
        consultationTopic: "React 進階課程",
        consultantName: "林顧問",
        scheduledDate: new Date("2024-09-15T10:00:00Z"),
        actualDate: new Date("2024-09-15T10:00:00Z"),
        duration: 35,
        status: "completed",
        outcome: "interested",
        notes: "基礎課程完成，計劃學習 React 進階開發",
        worksheetId: "110563615"
      },
      // Zhang Meili's journey consultations  
      {
        studentName: "張美麗",
        studentEmail: "meili.zhang@yahoo.com",
        studentPhone: "0987654321",
        consultationType: "online",
        consultationTopic: "設計課程諮詢",
        consultantName: "李顧問",
        scheduledDate: new Date("2024-07-05T14:00:00Z"),
        actualDate: new Date("2024-07-05T14:00:00Z"),
        duration: 30,
        status: "completed",
        outcome: "interested",
        notes: "對 UI/UX 設計很感興趣，決定報名體驗課程",
        worksheetId: "110563615"
      },
      {
        studentName: "張美麗",
        studentEmail: "meili.zhang@yahoo.com",
        studentPhone: "0987654321",
        consultationType: "phone",
        consultationTopic: "正式課程升級",
        consultantName: "李顧問",
        scheduledDate: new Date("2024-08-20T14:00:00Z"),
        actualDate: new Date("2024-08-20T14:00:00Z"),
        duration: 25,
        status: "completed",
        outcome: "interested",
        notes: "體驗課程完成，希望繼續學習正式設計課程",
        worksheetId: "110563615"
      },
      {
        studentName: "張美麗",
        studentEmail: "meili.zhang@yahoo.com",
        studentPhone: "0987654321",
        consultationType: "online",
        consultationTopic: "進階課程評估",
        consultantName: "李顧問",
        scheduledDate: new Date("2024-09-20T14:00:00Z"),
        actualDate: new Date("2024-09-20T14:00:00Z"),
        duration: 40,
        status: "completed",
        outcome: "follow_up_needed",
        followUpDate: new Date("2024-10-05T14:00:00Z"),
        notes: "正式課程完成，對進階課程有興趣但需要時間考慮",
        worksheetId: "110563615"
      },
      {
        studentName: "林大華",
        studentEmail: "dahua.lin@hotmail.com",
        studentPhone: "0923456789",
        consultationType: "in_person",
        consultationTopic: "職涯轉換諮詢",
        consultantName: "張顧問",
        scheduledDate: new Date("2024-08-15T15:00:00Z"),
        actualDate: new Date("2024-08-15T15:10:00Z"),
        duration: 45,
        status: "completed",
        outcome: "interested",
        notes: "希望轉職為數據分析師，對 Python 課程很有興趣",
        worksheetId: "110563615"
      },
      // Chen Xiaofang's failed journey consultations
      {
        studentName: "陳小芳",
        studentEmail: "xiaofang.chen@outlook.com",
        studentPhone: "0934567890",
        consultationType: "phone",
        consultationTopic: "Python 課程諮詢",
        consultantName: "王顧問",
        scheduledDate: new Date("2024-07-30T16:30:00Z"),
        actualDate: new Date("2024-07-30T16:35:00Z"),
        duration: 20,
        status: "completed",
        outcome: "interested",
        notes: "對 Python 程式設計有興趣，報名體驗課程",
        worksheetId: "110563615"
      },
      {
        studentName: "陳小芳",
        studentEmail: "xiaofang.chen@outlook.com",
        studentPhone: "0934567890",
        consultationType: "phone",
        consultationTopic: "課程進度追蹤",
        consultantName: "王顧問",
        scheduledDate: new Date("2024-08-15T16:30:00Z"),
        actualDate: new Date("2024-08-15T16:35:00Z"),
        duration: 15,
        status: "completed",
        outcome: "not_interested",
        notes: "體驗課程完成但覺得程式設計太困難，暫時不想繼續",
        worksheetId: "110563615"
      },
      {
        studentName: "黃建國",
        studentEmail: "jianguo.huang@gmail.com",
        studentPhone: "0945678901",
        consultationType: "online",
        consultationTopic: "全端開發諮詢",
        consultantName: "林顧問",
        scheduledDate: new Date("2024-09-05T11:00:00Z"),
        actualDate: new Date("2024-09-05T11:00:00Z"),
        duration: 40,
        status: "completed",
        outcome: "interested",
        notes: "有前端基礎，希望學習後端開發成為全端工程師",
        worksheetId: "110563615"
      },
      {
        studentName: "吳麗華",
        studentEmail: "lihua.wu@gmail.com",
        studentPhone: "0956789012",
        consultationType: "phone",
        consultationTopic: "課程了解",
        consultantName: "張顧問",
        scheduledDate: new Date("2024-09-28T10:00:00Z"),
        actualDate: null,
        duration: null,
        status: "scheduled",
        outcome: null,
        notes: "新學員諮詢，尚未完成",
        worksheetId: "110563615"
      }
    ];

    // Create purchase and consultation records
    for (const purchase of samplePurchases) {
      await storage.createPurchaseRecord(purchase);
    }

    for (const consultation of sampleConsultations) {
      await storage.createConsultationRecord(consultation);
    }

    // Create data source relationships for cross-source analysis
    const dataSourceMappings = await storage.listDataSourceMappings();
    const experienceCourseMapping = dataSourceMappings.find(m => m.name === "experience_course_records");
    const purchaseMapping = dataSourceMappings.find(m => m.name === "purchase_records");

    if (experienceCourseMapping && purchaseMapping) {
      // Create relationship between class records and purchase records
      await storage.createDataSourceRelationship({
        name: "class_to_purchase_correlation",
        displayName: "課程記錄與購買記錄關聯",
        description: "連結學生上課記錄與購買記錄，用於分析轉換率",
        primarySourceId: experienceCourseMapping.id,
        secondarySourceId: purchaseMapping.id,
        joinType: "left",
        primaryKey: "email",
        foreignKey: "studentEmail"
      });

      // Create multi-source analytics for conversion analysis
      await storage.createMultiSourceAnalytic({
        name: "student_conversion_analysis",
        displayName: "學生轉換率分析",
        description: "分析從體驗課程到正式購買的學生轉換率和模式",
        analysisType: "conversion",
        filters: {
          timeRange: "last_3_months" as any,
          courseTypes: ["experience", "regular", "advanced"] as any,
          includeCompleted: true as any
        },
        aggregationRules: {
          groupBy: ["courseType", "salesPerson"] as any,
          metrics: ["conversionRate", "averageRevenue", "timeToConversion"] as any,
          calculations: {
            conversionRate: "(purchaseCount / consultationCount) * 100",
            averageRevenue: "SUM(transactionAmount) / COUNT(purchases)",
            timeToConversion: "AVG(purchaseDate - consultationDate)"
          } as any
        }
      });

      await storage.createMultiSourceAnalytic({
        name: "consultant_performance_analysis",
        displayName: "顧問績效分析",
        description: "分析不同顧問的諮詢效果和轉換成果",
        analysisType: "correlation",
        filters: {
          consultationStatus: ["completed"] as any,
          outcomeTypes: ["interested", "follow_up_needed"] as any
        },
        aggregationRules: {
          groupBy: ["consultantName", "consultationTopic"] as any,
          metrics: ["consultationToSaleConversion", "averageDealSize", "customerSatisfaction"] as any,
          calculations: {
            consultationToSaleConversion: "(COUNT(purchases) / COUNT(consultations)) * 100",
            averageDealSize: "AVG(transactionAmount) WHERE transactionStatus = 'completed'",
            followUpSuccess: "(COUNT(followUpPurchases) / COUNT(followUpNeeded)) * 100"
          } as any
        }
      });

      await storage.createMultiSourceAnalytic({
        name: "student_journey_funnel",
        displayName: "學生學習旅程漏斗分析",
        description: "完整追蹤學生從諮詢到購買到完課的完整旅程",
        analysisType: "funnel",
        filters: {
          journeyStages: ["consultation", "purchase", "course_completion"] as any,
          timeWindow: "6_months" as any
        },
        aggregationRules: {
          stages: [
            { name: "consultation", source: "consultations", filter: "status='completed'" },
            { name: "purchase", source: "purchases", filter: "transactionStatus='completed'" },
            { name: "completion", source: "class_records", filter: "是否已確認='是'" }
          ] as any,
          metrics: ["dropOffRate", "stageConversion", "overallConversion"] as any,
          calculations: {
            stageConversion: "nextStageCount / currentStageCount * 100",
            overallConversion: "finalStageCount / initialStageCount * 100",
            averageJourneyTime: "AVG(finalStageDate - initialStageDate)"
          } as any
        }
      });
    }

    // Validate that data source relationships reference existing mappings
    if (experienceCourseMapping && purchaseMapping) {
      console.log("✓ Data source relationship validation passed");
    } else {
      console.warn("⚠ Data source relationship validation failed - missing required mappings");
    }

    console.log("Sample data created:");
    console.log(`- ${samplePurchases.length} purchase records (demonstrating complete student journeys)`);
    console.log(`- ${sampleConsultations.length} consultation records (multi-stage interactions)`);
    console.log("- 1 data source relationship (validated)");
    console.log("- 3 multi-source analytics configurations");
    console.log("Journey patterns:");
    console.log("  • Wang Xiaoming: Complete journey (experience → regular → advanced)");
    console.log("  • Zhang Meili: Partial journey (experience → regular, considering advanced)");
    console.log("  • Lin Dahua: Direct advanced purchase (experienced learner)");
    console.log("  • Chen Xiaofang: Failed conversion (experience only, did not continue)");

  } catch (error) {
    console.error('Error initializing multi-datasource sample data:', error);
  }
})();
*/
