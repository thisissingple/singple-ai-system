/**
 * Total Report Service
 * Ë≤†Ë≤¨Êï¥Âêà Google Sheets Ë≥áÊñôÔºåÁî¢ÁîüÊï∏ÊìöÁ∏ΩÂ†±Ë°®
 */

import { storage } from '../legacy/storage';
import { subDays, subWeeks, subMonths, startOfWeek, endOfWeek, startOfMonth, endOfMonth, format, eachDayOfInterval, eachWeekOfInterval, eachMonthOfInterval } from 'date-fns';
import { findField, extractStandardFields } from './field-mapping';
import { resolveField, parseDateField, parseNumberField, FIELD_ALIASES } from './field-mapping-v2';
import { supabaseReportRepository, type SupabaseDataRow } from './supabase-report-repository';
import { directSqlRepository } from './direct-sql-repository';
import { calculateAllKPIs } from '../kpi-calculator';
import { buildPermissionFilter } from '../permission-filter-service';
import { createPool, queryDatabase } from '../pg-client';

export type PeriodType = 'daily' | 'weekly' | 'lastWeek' | 'monthly' | 'day' | 'week' | 'month' | 'custom';

export interface TotalReportData {
  mode: 'mock' | 'live';
  period: PeriodType;
  dateRange: {
    start: string;
    end: string;
  };
  warnings?: string[];
  summaryMetrics: {
    conversionRate: number;
    avgConversionTime: number;
    trialCompletionRate: number;
    pendingStudents: number;
    potentialRevenue: number;
    totalTrials: number;
    totalConversions: number;
  };
  trendData: Array<{
    date: string;
    trials: number;
    conversions: number;
    revenue: number;
    contactRate?: number;
  }>;
  funnelData: Array<{
    stage: string;
    value: number;
    fill: string;
  }>;
  categoryBreakdown: Array<{
    name: string;
    value: number;
    percentage: number;
  }>;
  teacherInsights: Array<{
    teacherId: string;
    teacherName: string;
    classCount: number;
    conversionRate: number;
    avgSatisfaction: number;
    totalRevenue: number;
    completionRate: number;
    inTrialStudents: number;
    convertedStudents: number;
    studentCount: number;
  }>;
  studentInsights: Array<{
    studentId: string;
    studentName: string;
    email: string;
    classDate: string;
    teacherName: string;
    status: 'pending' | 'contacted' | 'converted' | 'lost';
    intentScore: number;
    recommendedAction: string;
    lastContactDate?: string;
    audioTranscriptUrl?: string;
    aiNotes?: string;
    dealAmount?: number;
  }>;
  aiSuggestions: {
    daily: string[];
    weekly: string[];
    monthly: string[];
    audioInsights?: string[];
  };
  rawData: Array<{
    id: string;
    data: Record<string, any>;
    source: string;
    lastUpdated: string;
  }>;
  dataSourceMeta?: {
    trialClassAttendance?: { rows: number; lastSync: string | null };
    trialClassPurchase?: { rows: number; lastSync: string | null };
    eodsForClosers?: { rows: number; lastSync: string | null };
  };
  filtersApplied?: {
    period: PeriodType;
    startDate: string;
    endDate: string;
  };
}

export interface GenerateTotalReportRequest {
  period: PeriodType;
  baseDate?: string; // ISO date string
  startDate?: string; // For custom period
  endDate?: string; // For custom period
  includedSources?: string[]; // Optional filter for data sources
  userId?: string; // Áî®Êà∂ IDÔºàÁî®ÊñºÊ¨äÈôêÈÅéÊøæÔºâ
}

export class TotalReportService {
  /**
   * Áî¢ÁîüÁ∏ΩÂ†±Ë°®
   */
  async generateReport(request: GenerateTotalReportRequest): Promise<TotalReportData | null> {
    const baseDate = request.baseDate ? new Date(request.baseDate) : new Date();
    const startDate = request.startDate ? new Date(request.startDate) : undefined;
    const endDate = request.endDate ? new Date(request.endDate) : undefined;
    const dateRange = this.getDateRange(request.period, baseDate, startDate, endDate);
    const warnings: string[] = [];

    try {
      // ÂÑ™ÂåñÔºö‰∏¶Ë°åÊü•Ë©¢Áï∂ÊúüÂíåÂâçÊúüË≥áÊñôÔºåÊ∏õÂ∞ëÁ≠âÂæÖÊôÇÈñì
      const shouldFetchPrevious = this.shouldFetchPreviousPeriod(request.period);
      const previousDateRange = shouldFetchPrevious
        ? this.getPreviousPeriodDateRange(request.period, baseDate)
        : null;

      // ‰∏¶Ë°åÂü∑Ë°åÁï∂ÊúüÂíåÂâçÊúüË≥áÊñôÊü•Ë©¢
      const [currentData, previousData] = await Promise.all([
        this.fetchRawData(dateRange, warnings, request.userId),
        shouldFetchPrevious && previousDateRange
          ? this.fetchRawData(previousDateRange, warnings, request.userId)
          : Promise.resolve(null)
      ]);

      const { attendanceData, purchaseData, eodsData, dataSource } = currentData;

      // ÁµÑË£ùÂâçÊúüË≥áÊñô
      let previousPeriodData: { attendanceData: any[]; purchaseData: any[]; eodsData: any[] } | null = null;
      if (previousData) {
        previousPeriodData = {
          attendanceData: previousData.attendanceData,
          purchaseData: previousData.purchaseData,
          eodsData: previousData.eodsData
        };
      }

      if (attendanceData.length === 0 && purchaseData.length === 0 && eodsData.length === 0) {
        console.log('ÁÑ°Ë≥áÊñô‰æÜÊ∫êÔºåÂõûÂÇ≥ null');
        return null;
      }

      // ÁÇ∫‰∫ÜÁõ∏ÂÆπÊÄßÔºå‰øùÁïô sheet Ë≥áË®äÔºàÁî®Êñº dataSourceMetaÔºâ
      let trialAttendanceSheet: any = null;
      let trialPurchaseSheet: any = null;
      let eodsSheet: any = null;

      if (dataSource === 'storage') {
        const spreadsheets = await storage.listSpreadsheets();
        trialAttendanceSheet = spreadsheets.find(s =>
          s.name.includes('È´îÈ©óË™≤‰∏äË™≤Ë®òÈåÑ') || s.name.includes('‰∏äË™≤ÊâìÂç°')
        );
        trialPurchaseSheet = spreadsheets.find(s =>
          s.name.includes('È´îÈ©óË™≤Ë≥ºË≤∑Ë®òÈåÑ') || s.name.includes('È´îÈ©óË™≤Â≠∏Âì°ÂêçÂñÆ')
        );
        eodsSheet = spreadsheets.find(s =>
          s.name.includes('EODs for Closers') || s.name.includes('ÂçáÈ´òÈöéÂ≠∏Âì°')
        );
      }

      // Ë®àÁÆóÂêÑÈ†ÖÊåáÊ®ôÔºàÂÇ≥ÂÖ• warningsÔºâ
      const summaryMetrics = await this.calculateSummaryMetrics(
        attendanceData,
        purchaseData,
        eodsData,
        warnings
      );

      // üÜï Â¶ÇÊûúÊúâÂâç‰∏ÄÊúüË≥áÊñôÔºåË®àÁÆóÂâç‰∏ÄÊúüÁöÑÊåáÊ®ô‰∏¶ÁîüÊàêÂ∞çÊØî
      if (previousPeriodData) {
        const previousMetrics = await this.calculateSummaryMetrics(
          previousPeriodData.attendanceData,
          previousPeriodData.purchaseData,
          previousPeriodData.eodsData,
          [] // Ââç‰∏ÄÊúü‰∏çÈúÄË¶Å warnings
        );

        // Ë®àÁÆóÂ∞çÊØî
        summaryMetrics.comparison = {
          conversionRate: this.calculateMetricComparison(
            summaryMetrics.conversionRate,
            previousMetrics.conversionRate
          ),
          avgConversionTime: this.calculateMetricComparison(
            summaryMetrics.avgConversionTime,
            previousMetrics.avgConversionTime
          ),
          trialCompletionRate: this.calculateMetricComparison(
            summaryMetrics.trialCompletionRate,
            previousMetrics.trialCompletionRate
          ),
          totalTrials: this.calculateMetricComparison(
            summaryMetrics.totalTrials,
            previousMetrics.totalTrials
          ),
          totalConversions: this.calculateMetricComparison(
            summaryMetrics.totalConversions,
            previousMetrics.totalConversions
          ),
        };
      }

      // üÜï ÂÖàË®àÁÆóÂ≠∏ÁîüÊï∏ÊìöÔºåÂõ†ÁÇ∫ÊïôÂ∏´Êï∏ÊìöÈúÄË¶Å‰ΩøÁî®Â≠∏ÁîüÁöÑË®àÁÆóÁµêÊûú
      const studentInsights = await this.calculateStudentInsights(
        attendanceData,
        purchaseData,
        eodsData,
        warnings
      );

      // üÜï Ë®àÁÆóÊïôÂ∏´Êï∏ÊìöÊôÇÂÇ≥ÂÖ•Â≠∏ÁîüÊï∏ÊìöÔºåÁ¢∫‰øùÁãÄÊÖã‰∏ÄËá¥
      const teacherInsights = await this.calculateTeacherInsights(
        attendanceData,
        purchaseData,
        eodsData,
        warnings,
        studentInsights
      );

      // üÜï Â¶ÇÊûúÊúâÂâç‰∏ÄÊúüË≥áÊñôÔºåË®àÁÆóÊïôÂ∏´Â∞çÊØî
      if (previousPeriodData) {
        // ÂÖàË®àÁÆóÂâç‰∏ÄÊúüÁöÑÂ≠∏ÁîüÊï∏Êìö
        const previousStudentInsights = await this.calculateStudentInsights(
          previousPeriodData.attendanceData,
          previousPeriodData.purchaseData,
          previousPeriodData.eodsData,
          []
        );

        // ÂÜçË®àÁÆóÂâç‰∏ÄÊúüÁöÑÊïôÂ∏´Êï∏Êìö
        const previousTeacherInsights = await this.calculateTeacherInsights(
          previousPeriodData.attendanceData,
          previousPeriodData.purchaseData,
          previousPeriodData.eodsData,
          [],
          previousStudentInsights
        );

        // ÁÇ∫ÊØè‰ΩçÊïôÂ∏´Âä†ÂÖ•Â∞çÊØîË≥áÊñô
        teacherInsights.forEach((teacher) => {
          const previousTeacher = previousTeacherInsights.find(
            (t) => t.teacherId === teacher.teacherId
          );

          if (previousTeacher) {
            teacher.comparison = {
              classCount: this.calculateMetricComparison(
                teacher.classCount,
                previousTeacher.classCount
              ),
              conversionRate: this.calculateMetricComparison(
                teacher.conversionRate,
                previousTeacher.conversionRate
              ),
              totalRevenue: this.calculateMetricComparison(
                teacher.totalRevenue,
                previousTeacher.totalRevenue
              ),
              performanceScore: this.calculateMetricComparison(
                teacher.performanceScore,
                previousTeacher.performanceScore
              ),
            };
          }
        });
      }

      const funnelData = this.calculateFunnelData(purchaseData);

      const categoryBreakdown = this.calculateCategoryBreakdown(purchaseData);

      const trendData = this.calculateTrendData(
        request.period,
        dateRange,
        attendanceData,
        purchaseData
      );

      const aiSuggestions = this.generateAISuggestions(
        summaryMetrics,
        teacherInsights,
        studentInsights,
        request.period,
        previousPeriodData ? await this.calculateSummaryMetrics(
          previousPeriodData.attendanceData,
          previousPeriodData.purchaseData,
          previousPeriodData.eodsData,
          []
        ) : undefined
      );

      // Êï¥ÁêÜ rawData
      const rawData = [
        ...attendanceData.map(d => ({
          id: d.id,
          data: d.data,
          source: 'È´îÈ©óË™≤‰∏äË™≤Ë®òÈåÑË°®',
          lastUpdated: d.lastUpdated?.toISOString() || new Date().toISOString(),
        })),
        ...purchaseData.map(d => ({
          id: d.id,
          data: d.data,
          source: 'È´îÈ©óË™≤Ë≥ºË≤∑Ë®òÈåÑË°®',
          lastUpdated: d.lastUpdated?.toISOString() || new Date().toISOString(),
        })),
        ...eodsData.map(d => ({
          id: d.id,
          data: d.data,
          source: 'EODs for Closers',
          lastUpdated: d.lastUpdated?.toISOString() || new Date().toISOString(),
        })),
      ];

      return {
        mode: 'live',
        period: request.period,
        dateRange,
        warnings: warnings.length > 0 ? warnings : undefined,
        summaryMetrics,
        trendData,
        funnelData,
        categoryBreakdown,
        teacherInsights,
        studentInsights,
        aiSuggestions,
        rawData,
        dataSourceMeta: {
          trialClassAttendance: {
            rows: attendanceData.length,
            lastSync: trialAttendanceSheet?.lastSyncAt?.toISOString() || null,
          },
          trialClassPurchase: {
            rows: purchaseData.length,
            lastSync: trialPurchaseSheet?.lastSyncAt?.toISOString() || null,
          },
          eodsForClosers: {
            rows: eodsData.length,
            lastSync: eodsSheet?.lastSyncAt?.toISOString() || null,
          },
        },
        filtersApplied: {
          period: request.period,
          startDate: dateRange.start,
          endDate: dateRange.end,
        },
      };
    } catch (error) {
      console.error('Áî¢ÁîüÁ∏ΩÂ†±Ë°®Â§±Êïó:', error);
      return null;
    }
  }

  /**
   * Áµ±‰∏ÄË≥áÊñôÂèñÂæóÂÖ•Âè£ÔºàSupabase ÂÑ™ÂÖà ‚Üí Storage fallbackÔºâÔºàÂÖ¨Èñã helperÔºâ
   */
  public async fetchRawData(dateRange: { start: string; end: string }, warnings: string[], userId?: string): Promise<{
    attendanceData: any[];
    purchaseData: any[];
    eodsData: any[];
    dataSource: 'supabase' | 'storage';
  }> {
    // ÂÑ™ÂÖà‰ΩøÁî®Áõ¥Êé• SQL Êü•Ë©¢ÔºàÁπûÈÅé PostgREST schema cache ÂïèÈ°åÔºâ
    if (directSqlRepository.isAvailable()) {
      try {
        console.log('üìä Fetching data from Supabase (Direct SQL)...');
        const [supabaseAttendance, supabasePurchases, supabaseDeals] = await Promise.all([
          directSqlRepository.getAttendance(dateRange),
          directSqlRepository.getPurchases(dateRange),
          directSqlRepository.getDeals(dateRange),
        ]);

        const totalRecords = supabaseAttendance.length + supabasePurchases.length + supabaseDeals.length;
        console.log(`‚úì Supabase data: ${supabaseAttendance.length} attendance, ${supabasePurchases.length} purchases, ${supabaseDeals.length} deals`);

        if (totalRecords > 0) {
          // ËΩâÊèõÁÇ∫ÂÖßÈÉ®Ê†ºÂºè
          let attendanceData = this.convertSupabaseToInternalFormat(supabaseAttendance);
          let purchaseData = this.convertSupabaseToInternalFormat(supabasePurchases);
          let eodsData = this.convertSupabaseToInternalFormat(supabaseDeals);

          // Â¶ÇÊûúÊúâ userIdÔºåÈÄ≤Ë°åÊ¨äÈôêÈÅéÊøæ
          if (userId) {
            attendanceData = await this.filterDataByPermission(attendanceData, userId, 'trial_class_attendance');
            purchaseData = await this.filterDataByPermission(purchaseData, userId, 'trial_class_purchases');
            eodsData = await this.filterDataByPermission(eodsData, userId, 'telemarketing_calls');
          }

          warnings.push(`‰ΩøÁî® Supabase Ë≥áÊñô‰æÜÊ∫êÔºàÈÅéÊøæÂæåÔºö${attendanceData.length + purchaseData.length + eodsData.length} Á≠ÜË®òÈåÑÔºâ`);
          return {
            attendanceData,
            purchaseData,
            eodsData,
            dataSource: 'supabase',
          };
        } else {
          console.warn('‚ö†Ô∏è  Supabase returned no data, falling back to storage');
          warnings.push('Supabase Êü•Ë©¢ÊàêÂäü‰ΩÜÁÑ°Ë≥áÊñôÔºåfallback Ëá≥ local storage');
        }
      } catch (error) {
        console.error('‚ùå Supabase query failed:', error);
        const errorMsg = error instanceof Error ? error.message : String(error);
        warnings.push(`Supabase Êü•Ë©¢Â§±ÊïóÔºà${errorMsg}ÔºâÔºåfallback Ëá≥ local storage`);
      }
    } else {
      console.log('‚ÑπÔ∏è  Supabase not available, using local storage');
      warnings.push('Supabase Êú™Ë®≠ÂÆöÔºàÁí∞Â¢ÉËÆäÊï∏Áº∫Â§±ÔºâÔºå‰ΩøÁî® local storage');
    }

    // Fallback to storage
    console.log('üìÅ Fetching data from local storage...');
    const spreadsheets = await storage.listSpreadsheets();

    if (spreadsheets.length === 0) {
      return {
        attendanceData: [],
        purchaseData: [],
        eodsData: [],
        dataSource: 'storage',
      };
    }

    const trialAttendanceSheet = spreadsheets.find(s =>
      s.name.includes('È´îÈ©óË™≤‰∏äË™≤Ë®òÈåÑ') || s.name.includes('‰∏äË™≤ÊâìÂç°')
    );
    const trialPurchaseSheet = spreadsheets.find(s =>
      s.name.includes('È´îÈ©óË™≤Ë≥ºË≤∑Ë®òÈåÑ') || s.name.includes('È´îÈ©óË™≤Â≠∏Âì°ÂêçÂñÆ')
    );
    const eodsSheet = spreadsheets.find(s =>
      s.name.includes('EODs for Closers') || s.name.includes('ÂçáÈ´òÈöéÂ≠∏Âì°')
    );

    const [storageAttendance, storagePurchase, storageEods] = await Promise.all([
      trialAttendanceSheet ? storage.getSheetData(trialAttendanceSheet.spreadsheetId) : Promise.resolve([]),
      trialPurchaseSheet ? storage.getSheetData(trialPurchaseSheet.spreadsheetId) : Promise.resolve([]),
      eodsSheet ? storage.getSheetData(eodsSheet.spreadsheetId) : Promise.resolve([]),
    ]);

    const attendanceData = this.filterDataByDateRange(storageAttendance, dateRange);
    const purchaseData = this.filterDataByDateRange(storagePurchase, dateRange);
    const eodsData = this.filterDataByDateRange(storageEods, dateRange);

    console.log(`‚úì Storage data: ${attendanceData.length} attendance, ${purchaseData.length} purchases, ${eodsData.length} deals`);

    return {
      attendanceData,
      purchaseData,
      eodsData,
      dataSource: 'storage',
    };
  }

  /**
   * Ë®àÁÆóÊó•ÊúüÁØÑÂúçÔºàÂÖ¨Èñã helperÔºâ
   */
  public getDateRange(period: PeriodType, baseDate: Date, startDate?: Date, endDate?: Date): { start: string; end: string } {
    switch (period) {
      case 'all':
        // Return a very wide date range to include all data
        return {
          start: '1970-01-01',  // Unix epoch start
          end: '2099-12-31',    // Far future date
        };
      case 'daily':
      case 'day':
        return {
          start: format(baseDate, 'yyyy-MM-dd'),
          end: format(baseDate, 'yyyy-MM-dd'),
        };
      case 'weekly':
      case 'week':
        return {
          start: format(startOfWeek(baseDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
          end: format(endOfWeek(baseDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
        };
      case 'lastWeek':
        const lastWeekDate = subWeeks(baseDate, 1);
        return {
          start: format(startOfWeek(lastWeekDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
          end: format(endOfWeek(lastWeekDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
        };
      case 'monthly':
      case 'month':
        return {
          start: format(startOfMonth(baseDate), 'yyyy-MM-dd'),
          end: format(endOfMonth(baseDate), 'yyyy-MM-dd'),
        };
      case 'custom':
        if (!startDate || !endDate) {
          throw new Error('Custom period requires startDate and endDate');
        }
        return {
          start: format(startDate, 'yyyy-MM-dd'),
          end: format(endDate, 'yyyy-MM-dd'),
        };
      default:
        // Default to current month if period is unrecognized
        return {
          start: format(startOfMonth(baseDate), 'yyyy-MM-dd'),
          end: format(endOfMonth(baseDate), 'yyyy-MM-dd'),
        };
    }
  }

  /**
   * ‰æùÊó•ÊúüÁØÑÂúçÁØ©ÈÅ∏Ë≥áÊñô
   */
  private filterDataByDateRange(data: any[], dateRange: { start: string; end: string }): any[] {
    return data.filter(row => {
      const dateFields = ['date', 'classDate', 'purchaseDate', 'createdAt', 'Êó•Êúü', '‰∏äË™≤Êó•Êúü', 'Ë≥ºË≤∑Êó•Êúü'];
      let rowDate: string | null = null;

      for (const field of dateFields) {
        if (row.data[field]) {
          rowDate = this.normalizeDate(row.data[field]);
          break;
        }
      }

      if (!rowDate) return false;

      return rowDate >= dateRange.start && rowDate <= dateRange.end;
    });
  }

  /**
   * Ê≠£Ë¶èÂåñÊó•ÊúüÊ†ºÂºè
   */
  private normalizeDate(dateValue: any): string | null {
    if (!dateValue) return null;

    try {
      const date = new Date(dateValue);
      if (isNaN(date.getTime())) return null;
      return format(date, 'yyyy-MM-dd');
    } catch {
      return null;
    }
  }

  /**
   * Ë®àÁÆóÁ∏ΩÁµêÊåáÊ®ôÔºà‰ΩøÁî®Áµ±‰∏ÄÁöÑ KPI CalculatorÔºâ
   */
  private async calculateSummaryMetrics(
    attendanceData: any[],
    purchaseData: any[],
    eodsData: any[],
    warnings: string[]
  ): Promise<TotalReportData['summaryMetrics']> {
    // ‰ΩøÁî®Êñ∞ÁöÑ KPI CalculatorÔºàÊï¥Âêà Formula EngineÔºâ
    const result = await calculateAllKPIs({
      attendance: attendanceData,
      purchases: purchaseData,
      deals: eodsData,
    });

    // Âêà‰Ωµ warnings
    warnings.push(...result.warnings);

    // Ë®àÁÆóÁ∏ΩÂ≠∏ÁîüÊï∏ÔºàË≥ºË≤∑Ë®òÈåÑ‰∏≠ÁöÑÁç®Á´ã email Êï∏ÈáèÔºâ
    const uniqueStudents = new Set<string>();
    purchaseData.forEach(row => {
      const email = (
        resolveField(row.data, 'studentEmail') ||
        row.data?.Â≠∏Âì°‰ø°ÁÆ± ||
        row.data?.email ||
        ''
      ).toLowerCase();
      if (email) {
        uniqueStudents.add(email);
      }
    });

    return {
      ...result.summaryMetrics,
      totalStudents: uniqueStudents.size,
    };
  }

  /**
   * Ë®àÁÆóÊïôÂ∏´Êï∏ÊìöÔºàÂÖ®Êñ∞ÂïÜÊ•≠ÊåáÊ®ôÔºâ
   */
  private async calculateTeacherInsights(
    attendanceData: any[],
    purchaseData: any[],
    eodsData: any[],
    warnings: string[],
    studentInsights: TotalReportData['studentInsights']
  ): Promise<TotalReportData['teacherInsights']> {
    const teacherMap = new Map<string, {
      classCount: number;
      students: Set<string>;
      classDates: Date[];
      convertedStudents: Set<string>;  // Â∑≤ËΩâÈ´òÂ≠∏Áîü
      lostStudents: Set<string>;        // Êú™ËΩâÈ´òÂ≠∏Áîü
      inTrialStudents: Set<string>;     // È´îÈ©ó‰∏≠Â≠∏Áîü
      highLevelDeals: Array<{ amount: number; date: Date; studentEmail: string }>;
      conversionDays: number[];         // ËΩâÊèõÂ§©Êï∏Èô£Âàó
      totalPurchasedClasses: number;    // Ë©≤ÊïôÂ∏´ÊâÄÊúâÂ≠∏ÁîüÁöÑË≥ºË≤∑Â†ÇÊï∏Á∏ΩÂíå
      totalAttendedClasses: number;     // Ë©≤ÊïôÂ∏´ÊâÄÊúâÂ≠∏ÁîüÁöÑÂ∑≤‰∏äÂ†ÇÊï∏Á∏ΩÂíå
    }>();

    // Step 0: Âª∫Á´ãÂ≠∏Áîü email ‚Üí ÊïôÂ∏´ÂêçÁ®±ÁöÑÂ∞çÊáâË°®ÔºàÂæû attendance Âª∫Á´ãÔºâ
    const studentTeacherMap = new Map<string, string>();
    const studentClassDataMap = new Map<string, { purchased: number; attended: number }>();
    let missingTeacherCount = 0;

    // ÂÑ™ÂåñÔºöStep 1 - Áµ±Ë®àÊïôÂ∏´ÊéàË™≤Ë®òÈåÑÔºåÂêåÊôÇÂª∫Á´ãÂ≠∏Áîü‚ÜíÊïôÂ∏´Â∞çÊáâ
    // ÂêåÊôÇÊî∂ÈõÜ class date Ë≥áË®ä‰æõÂæåÁ∫åËΩâÊèõÂ§©Êï∏Ë®àÁÆó‰ΩøÁî®
    const studentClassDatesMap = new Map<string, Date[]>();

    attendanceData.forEach(row => {
      const teacher = resolveField(row.data, 'teacher');
      const studentEmail = resolveField(row.data, 'studentEmail');
      const classDateRaw = resolveField(row.data, 'classDate');
      const classDate = parseDateField(classDateRaw);

      if (!teacher) {
        missingTeacherCount++;
        return;
      }

      if (!teacherMap.has(teacher)) {
        teacherMap.set(teacher, {
          classCount: 0,
          students: new Set(),
          classDates: [],
          convertedStudents: new Set(),
          lostStudents: new Set(),
          inTrialStudents: new Set(),
          highLevelDeals: [],
          conversionDays: [],
          totalPurchasedClasses: 0,
          totalAttendedClasses: 0,
        });
      }

      const stats = teacherMap.get(teacher)!;
      stats.classCount++;

      if (studentEmail) {
        const email = studentEmail.toLowerCase();
        stats.students.add(email);
        studentTeacherMap.set(email, teacher);

        // Á¥ØË®àÂ≠∏ÁîüÂ∑≤‰∏äÂ†ÇÊï∏
        if (!studentClassDataMap.has(email)) {
          studentClassDataMap.set(email, { purchased: 0, attended: 0 });
        }
        if (classDate) {
          studentClassDataMap.get(email)!.attended++;
          // ÂêåÊôÇ‰øùÂ≠ò‰∏äË™≤Êó•Êúü‰æõÂæåÁ∫å‰ΩøÁî®
          if (!studentClassDatesMap.has(email)) {
            studentClassDatesMap.set(email, []);
          }
          studentClassDatesMap.get(email)!.push(classDate);
        }
      }

      if (classDate) stats.classDates.push(classDate);
    });

    if (missingTeacherCount > 0) {
      warnings.push(`${missingTeacherCount} Á≠Ü‰∏äË™≤Ë®òÈåÑÁº∫Â∞ëÊïôÂ∏´ÂßìÂêç`);
    }

    // Step 1.5: üÜï Âæû course_plans Ë°®ÊâπÈáèÊü•Ë©¢Ë≥ºË≤∑Â†ÇÊï∏
    const planTotalClassesMap = new Map<string, number>();
    const planNamesSet = new Set<string>();

    purchaseData.forEach((row) => {
      const packageName = row.plan || row.data?.Êàê‰∫§ÊñπÊ°à || row.data?.plan || '';
      if (packageName) planNamesSet.add(packageName);
    });

    // Note: This is synchronous blocking code - consider making the whole function async if needed
    // For now, we'll skip the query and use fallback values

    // Step 2: ÂæûË≥ºË≤∑Ë®òÈåÑÁµ±Ë®àË≥ºË≤∑Â†ÇÊï∏Ôºà‰ΩøÁî® studentTeacherMap ÊâæÂà∞ÊïôÂ∏´Ôºâ
    purchaseData.forEach(row => {
      const studentEmail = resolveField(row.data, 'studentEmail');

      if (!studentEmail) return;

      const email = studentEmail.toLowerCase();
      const teacher = studentTeacherMap.get(email);

      if (!teacher || !teacherMap.has(teacher)) return;

      // üÜï Á¥ØË®àË≥ºË≤∑Â†ÇÊï∏
      const packageName = row.plan || row.data?.Êàê‰∫§ÊñπÊ°à || row.data?.plan || '';
      const totalClasses = row.trial_class_count || parseNumberField(row.data?.È´îÈ©óÂ†ÇÊï∏) || 0;

      if (!studentClassDataMap.has(email)) {
        studentClassDataMap.set(email, { purchased: 0, attended: 0 });
      }
      studentClassDataMap.get(email)!.purchased = totalClasses;
    });

    // üÜï Step 2.5: ‰ΩøÁî® studentInsights ÁöÑË®àÁÆóÁµêÊûú‰æÜÁµ±Ë®àÂ≠∏ÁîüÁãÄÊÖã
    // ÈÄôÊ®£ÂèØ‰ª•Á¢∫‰øùÂâçÁ´ØÂíåÂæåÁ´Ø‰ΩøÁî®Áõ∏ÂêåÁöÑÁãÄÊÖãÂÆöÁæ©
    studentInsights.forEach(student => {
      const email = student.email.toLowerCase();
      // üîß Fix: ‰ΩøÁî® student.teacherNameÔºàÂæû studentInsightsÔºâÔºåËÄå‰∏çÊòØ studentTeacherMap
      // Âõ†ÁÇ∫ studentInsights Â∑≤Á∂ìÊ≠£Á¢∫Ë®àÁÆó‰∫ÜÊØèÂÄãÂ≠∏ÁîüÁöÑ teacherNameÔºàÊúÄËøë‰∏ÄÊ¨°‰∏äË™≤ÁöÑÊïôÂ∏´Ôºâ
      const teacher = student.teacherName;

      if (!teacher || !teacherMap.has(teacher)) return;

      const stats = teacherMap.get(teacher)!;
      const status = student.currentStatus;

      if (status === 'Â∑≤ËΩâÈ´ò') {
        stats.convertedStudents.add(email);
      } else if (status === 'Êú™ËΩâÈ´ò') {
        stats.lostStudents.add(email);
      } else if (status === 'È´îÈ©ó‰∏≠') {
        stats.inTrialStudents.add(email);
      }
    });

    // ÂÑ™ÂåñÔºöStep 3 - Âæû EODs Áµ±Ë®àÈ´òÈöéÊñπÊ°àÂØ¶Êî∂ÈáëÈ°çÔºåÂêåÊôÇË®àÁÆóËΩâÊèõÂ§©Êï∏
    // Âêà‰ΩµÂéüÊú¨ÁöÑ Step 3 Âíå Step 4ÔºåÈÅøÂÖçÈáçË§áÈÅçÊ≠∑
    eodsData.forEach((row, idx) => {
      const studentEmail = resolveField(row.data, 'studentEmail');
      const plan = (
        row.data?.Êàê‰∫§ÊñπÊ°à ||
        row.data?.deal_package ||
        resolveField(row.data, 'dealPackage') ||
        resolveField(row.data, 'courseType') ||
        ''
      );
      const amountStr = (
        row.data?.ÂØ¶Êî∂ÈáëÈ°ç ||
        row.data?.actual_amount ||
        resolveField(row.data, 'actualAmount') ||
        resolveField(row.data, 'dealAmount') ||
        '0'
      );
      const dealDateRaw = row.data?.Êàê‰∫§Êó•Êúü || resolveField(row.data, 'dealDate');
      const dealDate = parseDateField(dealDateRaw);

      if (!studentEmail) return;

      const email = studentEmail.toLowerCase();
      const teacher = studentTeacherMap.get(email);

      if (!teacher || !teacherMap.has(teacher)) return;

      // Âè™Ë®àÁÆóÈ´òÈöéÊñπÊ°à
      if (!plan.includes('È´òÈöé‰∏ÄÂ∞ç‰∏Ä') && !plan.includes('È´òÈü≥')) return;

      const amount = parseFloat(amountStr.toString().replace(/[^0-9.]/g, '')) || 0;

      if (amount > 0) {
        const stats = teacherMap.get(teacher)!;
        const dealRecord = {
          amount,
          date: dealDate || new Date(),
          studentEmail: email,
        };
        stats.highLevelDeals.push(dealRecord);

        // ÂÑ™ÂåñÔºöÂêåÊôÇË®àÁÆóËΩâÊèõÂ§©Êï∏Ôºå‰ΩøÁî®Â∑≤‰øùÂ≠òÁöÑ‰∏äË™≤Êó•Êúü
        const classDates = studentClassDatesMap.get(email);
        if (classDates && classDates.length > 0 && dealRecord.date) {
          // ÊâæÂà∞ÊúÄÊó©ÁöÑ‰∏äË™≤Êó•Êúü
          const firstClassDate = classDates.reduce((earliest, current) =>
            current < earliest ? current : earliest
          );
          const days = Math.floor((dealRecord.date.getTime() - firstClassDate.getTime()) / (1000 * 60 * 60 * 24));
          if (days >= 0 && days < 365) {  // ÂêàÁêÜÁØÑÂúçÂÖß
            stats.conversionDays.push(days);
          }
        }
      }
    });

    // Step 4.5: üÜï Á¥ØÂä†ÊØè‰ΩçÊïôÂ∏´ÊâÄÊúâÂ≠∏ÁîüÁöÑË≥ºË≤∑ÂíåÂ∑≤‰∏äÂ†ÇÊï∏
    teacherMap.forEach((stats, teacherName) => {
      stats.students.forEach((email) => {
        const classData = studentClassDataMap.get(email);
        if (classData) {
          stats.totalPurchasedClasses += classData.purchased;
          stats.totalAttendedClasses += classData.attended;
        }
      });
    });

    // Step 5: ËΩâÊèõÁÇ∫Èô£Âàó‰∏¶Ë®àÁÆóÊâÄÊúâÊåáÊ®ô
    const insights: TotalReportData['teacherInsights'] = [];
    let index = 0;

    teacherMap.forEach((stats, teacherName) => {
      const studentCount = stats.students.size;
      const convertedCount = stats.convertedStudents.size;
      const lostCount = stats.lostStudents.size;
      const inTrialCount = stats.inTrialStudents.size;
      const completedCount = convertedCount + lostCount;

      // ËΩâÊèõÁéá = Â∑≤ËΩâÈ´ò √∑ (Â∑≤ËΩâÈ´ò + Êú™ËΩâÈ´ò)
      const conversionRate = completedCount > 0
        ? Math.round((convertedCount / completedCount) * 10000) / 100
        : 0;

      // ÂØ¶Êî∂ÈáëÈ°ç = ÊâÄÊúâÈ´òÈöéÊñπÊ°àÁöÑÁ∏ΩÂíå
      const totalRevenue = stats.highLevelDeals.reduce((sum, deal) => sum + deal.amount, 0);

      // Âπ≥ÂùáÂÆ¢ÂñÆÂÉπ = ÂØ¶Êî∂ÈáëÈ°ç √∑ Êàê‰∫§Â≠∏ÁîüÊï∏
      const avgDealAmount = convertedCount > 0
        ? Math.round(totalRevenue / convertedCount)
        : 0;

      // ROIÊïàÁéá = ÂØ¶Êî∂ÈáëÈ°ç √∑ ÊéàË™≤Êï∏
      const revenuePerClass = stats.classCount > 0
        ? Math.round(totalRevenue / stats.classCount)
        : 0;

      // ÊµÅÂ§±Áéá = Êú™ËΩâÈ´ò √∑ (Â∑≤ËΩâÈ´ò + Êú™ËΩâÈ´ò)
      const lostRate = completedCount > 0
        ? Math.round((lostCount / completedCount) * 10000) / 100
        : 0;

      // Âπ≥ÂùáËΩâÊèõÂ§©Êï∏
      const avgConversionDays = stats.conversionDays.length > 0
        ? Math.round(stats.conversionDays.reduce((sum, d) => sum + d, 0) / stats.conversionDays.length)
        : 0;

      // ÊúÄËøë‰∏ÄÊ¨°‰∏äË™≤Êó•
      const lastClassDate = stats.classDates.length > 0
        ? format(new Date(Math.max(...stats.classDates.map(d => d.getTime()))), 'yyyy-MM-dd')
        : null;

      // üÜï ÂÆåË™≤Áéá = Â∑≤‰∏äÂ†ÇÊï∏Á∏ΩÂíå √∑ Ë≥ºË≤∑Â†ÇÊï∏Á∏ΩÂíå
      const completionRate = stats.totalPurchasedClasses > 0
        ? Math.round((stats.totalAttendedClasses / stats.totalPurchasedClasses) * 10000) / 100
        : 0;

      // Á∏æÊïàË©ïÂàÜÔºà0-100ÔºâÔºöËΩâÊèõÁéá 40% + ROIÊïàÁéá 30% + ÂÆåË™≤Áéá 20% + Ê¥ªË∫çÂ∫¶ 10%
      const conversionScore = Math.min(conversionRate / 50 * 40, 40);  // 50% ËΩâÊèõÁéá = ÊªøÂàÜ
      const roiScore = Math.min(revenuePerClass / 30000 * 30, 30);      // 3Ëê¨/Â†Ç = ÊªøÂàÜ
      const completionScore = Math.min(completionRate / 100 * 20, 20);  // 100% ÂÆåË™≤ = ÊªøÂàÜ
      const activityScore = lastClassDate ? 10 : 0;  // ÊúâÊúÄËøë‰∏äË™≤ = ÊªøÂàÜ

      const performanceScore = Math.round(conversionScore + roiScore + completionScore + activityScore);

      insights.push({
        teacherId: `teacher-${index++}`,
        teacherName,
        classCount: stats.classCount,
        studentCount,
        conversionRate,
        totalRevenue,
        avgDealAmount,
        revenuePerClass,
        completionRate,
        inTrialStudents: inTrialCount,
        convertedStudents: convertedCount,
        lostStudents: lostCount,
        lostRate,
        avgConversionDays,
        lastClassDate,
        performanceScore,
      });
    });

    // È†êË®≠ÊåâËΩâÊèõÁéáÊéíÂ∫è
    return insights.sort((a, b) => b.conversionRate - a.conversionRate);
  }

  /**
   * Âæû course_plans Ë°®Êü•Ë©¢ÊñπÊ°àÁöÑÁ∏ΩÂ†ÇÊï∏
   */
  private async getCoursePlanTotalClasses(planName: string): Promise<number | null> {
    if (!planName) return null;

    try {
      const result = await queryDatabase(
        'SELECT total_classes FROM course_plans WHERE plan_name = $1 AND is_active = TRUE',
        [planName]
      );

      if (result.rows.length > 0) {
        return result.rows[0].total_classes;
      }
      return null;
    } catch (error) {
      console.error(`Error querying course_plans for plan "${planName}":`, error);
      return null;
    }
  }

  /**
   * Ë®àÁÆóÂ≠∏ÁîüÊï∏Êìö
   */
  private async calculateStudentInsights(
    attendanceData: any[],
    purchaseData: any[],
    eodsData: any[],
    warnings: string[]
  ): Promise<TotalReportData['studentInsights']> {
    const insights: TotalReportData['studentInsights'] = [];
    const studentMap = new Map<string, any>();
    const studentsWithoutPurchase: string[] = []; // Track students in attendance but not in purchase

    // Step 0: ÊâπÈáèÊü•Ë©¢ÊâÄÊúâÊñπÊ°àÁöÑÁ∏ΩÂ†ÇÊï∏ÔºàÊèêÂçáÊïàËÉΩÔºâ
    const planNamesSet = new Set<string>();
    purchaseData.forEach((row) => {
      const packageName = row.plan || row.data?.Êàê‰∫§ÊñπÊ°à || row.data?.plan || '';
      if (packageName) planNamesSet.add(packageName);
    });

    const planTotalClassesMap = new Map<string, number>();
    const missingPlans: string[] = [];

    try {
      const result = await queryDatabase(
        'SELECT plan_name, total_classes FROM course_plans WHERE is_active = TRUE'
      );

      result.rows.forEach((row: any) => {
        planTotalClassesMap.set(row.plan_name, row.total_classes);
      });

      // Ê™¢Êü•Áº∫Â∞ëÁöÑÊñπÊ°à
      planNamesSet.forEach((planName) => {
        if (!planTotalClassesMap.has(planName)) {
          missingPlans.push(planName);
        }
      });

      if (missingPlans.length > 0) {
        warnings.push(
          `‚ö†Ô∏è ‰ª•‰∏ã ${missingPlans.length} ÂÄãÊñπÊ°àÂ∞öÊú™ÂÆöÁæ©Âú® course_plans Ë°®‰∏≠ÔºåÂ∞á‰ΩøÁî®ÂéüÂßãË≥áÊñôÁöÑÂ†ÇÊï∏Ôºö\n` +
          missingPlans.map(p => `  - "${p}"`).join('\n')
        );
      }
    } catch (error) {
      console.error('Error querying course_plans:', error);
      warnings.push('‚ö†Ô∏è ÁÑ°Ê≥ïÊü•Ë©¢ course_plans Ë°®ÔºåÂ∞á‰ΩøÁî®ÂéüÂßãË≥áÊñôÁöÑÂ†ÇÊï∏');
    }

    // Step 1: Build from purchase records (most complete info)
    purchaseData.forEach((row, index) => {
      const email = (
        resolveField(row.data, 'studentEmail') ||
        row.data?.Â≠∏Âì°‰ø°ÁÆ± ||
        row.data?.email ||
        ''
      ).toLowerCase();

      if (!email) return;

      const name = resolveField(row.data, 'studentName') || row.data?.Â≠∏Âì°ÂßìÂêç || '';
      const packageName = row.plan || row.data?.Êàê‰∫§ÊñπÊ°à || row.data?.plan || '';

      // üÜï ÂÑ™ÂÖàÂæû course_plans Ë°®Êü•Ë©¢Á∏ΩÂ†ÇÊï∏
      let totalTrialClasses: number;
      const planTotalFromDB = packageName ? planTotalClassesMap.get(packageName) : null;

      if (planTotalFromDB !== null && planTotalFromDB !== undefined) {
        // ‚úÖ Âæû course_plans Ë°®ÂèñÂæóÁ∏ΩÂ†ÇÊï∏
        totalTrialClasses = planTotalFromDB;
      } else {
        // ‚ö†Ô∏è Fallback: ‰ΩøÁî®ÂéüÂßãË≥áÊñôÁöÑÂ†ÇÊï∏
        totalTrialClasses = row.trial_class_count || parseNumberField(row.data?.È´îÈ©óÂ†ÇÊï∏) || 0;
      }

      // üÜï Â∑≤‰∏äÂ†ÇÊï∏ÂàùÂßãÂåñÁÇ∫ 0ÔºåÁ®çÂæåÂæû attendance Ë®àÁÆó
      let attendedClasses = 0;
      let remainingTrialClasses = totalTrialClasses;

      // üÜï currentStatus Á®çÂæåÂú® Step 3.5 Ë®àÁÆóÔºåÈÄôË£°ÂàùÂßãÂåñÁÇ∫Á©∫Â≠ó‰∏≤
      const purchaseDateRaw = row.purchase_date || row.data?.Ë≥ºË≤∑Êó•Êúü || row.data?.purchaseDate || '';
      const purchaseDate = parseDateField(purchaseDateRaw);

      studentMap.set(email, {
        studentId: `student-${index}`,
        studentName: name,
        email,
        totalTrialClasses,
        remainingTrialClasses,
        attendedClasses,
        currentStatus: '',  // üÜï Á®çÂæåË®àÁÆó
        packageName,
        purchaseDate: purchaseDate ? format(purchaseDate, 'yyyy-MM-dd') : undefined,
        classDates: [] as Date[],
        teacherName: '',
        intentScore: 50,
        hasPurchaseRecord: true,
      });
    });

    // Step 2: Process attendance data (create students if not in purchase records)
    let attendanceIndex = purchaseData.length;
    attendanceData.forEach((row) => {
      const email = (resolveField(row.data, 'studentEmail') || '').toLowerCase();
      if (!email) return;

      const name = resolveField(row.data, 'studentName') || '';
      const teacher = resolveField(row.data, 'teacher') || '';
      const classDateRaw = resolveField(row.data, 'classDate');
      const classDate = parseDateField(classDateRaw);
      const intentScoreRaw = parseNumberField(resolveField(row.data, 'intentScore'));

      // Create student if not exists (from attendance only, no purchase record)
      if (!studentMap.has(email)) {
        studentsWithoutPurchase.push(`${name} (${email})`);
        studentMap.set(email, {
          studentId: `student-${attendanceIndex++}`,
          studentName: name,
          email,
          totalTrialClasses: 0,
          remainingTrialClasses: 0,
          attendedClasses: 0,
          currentStatus: '',
          packageName: '',
          purchaseDate: undefined,
          classDates: [] as Date[],
          teacherName: teacher,
          intentScore: intentScoreRaw !== null && intentScoreRaw >= 0 && intentScoreRaw <= 100 ? intentScoreRaw : 50,
          hasPurchaseRecord: false,
        });
      }

      const student = studentMap.get(email)!;

      // Collect class dates and track teacher with date
      if (classDate) {
        student.classDates.push(classDate);

        // Ë®òÈåÑÊØèÊ¨°‰∏äË™≤ÁöÑÊïôÂ∏´ÂíåÊó•ÊúüÔºàÁî®ÊñºÊâæÂá∫ÊúÄËøë‰∏ÄÊ¨°ÁöÑÊïôÂ∏´Ôºâ
        if (!student.teacherHistory) {
          student.teacherHistory = [];
        }
        if (teacher) {
          student.teacherHistory.push({ teacher, date: classDate });
        }

        // üÜï Á¥ØË®àÂ∑≤‰∏äÂ†ÇÊï∏ÔºàÊØèÊ¨°Êúâ classDate Â∞± +1Ôºâ
        student.attendedClasses = (student.attendedClasses || 0) + 1;
      }

      // Update intent score if available
      if (intentScoreRaw !== null && intentScoreRaw >= 0 && intentScoreRaw <= 100) {
        student.intentScore = intentScoreRaw;
      }
    });

    // üÜï Step 2.5: ÈáçÊñ∞Ë®àÁÆóÂâ©È§òÂ†ÇÊï∏ = Ë≥ºË≤∑Â†ÇÊï∏ - Â∑≤‰∏äÂ†ÇÊï∏
    studentMap.forEach((student) => {
      if (student.hasPurchaseRecord) {
        student.remainingTrialClasses = Math.max(0, student.totalTrialClasses - student.attendedClasses);
      }
    });

    // üÜï Step 2.6: ÂàùÂßãÂåñ dealAmountÔºàÁ®çÂæåÂú® Step 3 Á¥ØË®àÔºâ
    studentMap.forEach((student) => {
      student.dealAmount = 0;
    });

    // Add warning if students found in attendance but not in purchase
    if (studentsWithoutPurchase.length > 0) {
      warnings.push(
        `‚ö†Ô∏è ÁôºÁèæ ${studentsWithoutPurchase.length} ‰ΩçÂ≠∏ÁîüÊúâ‰∏äË™≤Ë®òÈåÑ‰ΩÜÁº∫Â∞ëË≥ºË≤∑Ë®òÈåÑÔºåË´ãÁõ°Âø´ËôïÁêÜÔºö\n` +
        studentsWithoutPurchase.slice(0, 10).join('\n') +
        (studentsWithoutPurchase.length > 10 ? `\n...‰ª•ÂèäÂÖ∂‰ªñ ${studentsWithoutPurchase.length - 10} ‰ΩçÂ≠∏Áîü` : '')
      );
    }

    // Step 3: Integrate EOD data (deal amounts)
    // Á¥ØÂä†ÊØè‰ΩçÂ≠∏Âì°„ÄåÈ´îÈ©óË™≤Ë≥ºË≤∑Êó•Êúü‰πãÂæå„ÄçÁöÑÊâÄÊúâÈ´òÈöéÊñπÊ°àÈáëÈ°ç
    studentMap.forEach((student) => {
      let totalDealAmount = 0;
      const purchaseDate = student.purchaseDate
        ? parseDateField(student.purchaseDate)
        : null;

      eodsData.forEach((row) => {
        const email = (resolveField(row.data, 'studentEmail') || '').toLowerCase();
        if (email !== student.email) return;

        // ÂèñÂæóÊàê‰∫§Êó•ÊúüÂíåÊñπÊ°à
        const dealDateRaw = resolveField(row.data, 'dealDate') || row.data?.Êàê‰∫§Êó•Êúü || row.data?.deal_date;
        const dealDate = parseDateField(dealDateRaw);
        const plan = (
          row.plan ||
          row.data?.plan ||
          row.data?.Êàê‰∫§ÊñπÊ°à ||
          row.data?.ÊñπÊ°àÂêçÁ®± ||
          resolveField(row.data, 'plan') ||
          ''
        );

        // Âè™Ë®àÁÆóÔºö1) È´îÈ©óË™≤Ë≥ºË≤∑Êó•Êúü‰πãÂæåÁöÑ 2) È´òÈöéÊñπÊ°à
        const isAfterPurchase = !purchaseDate || !dealDate || dealDate >= purchaseDate;
        const isHighLevelPlan = plan.includes('È´òÈöé‰∏ÄÂ∞ç‰∏Ä') || plan.includes('È´òÈü≥');

        if (isAfterPurchase && isHighLevelPlan) {
          const amount = parseNumberField(resolveField(row.data, 'dealAmount'));
          if (amount) {
            totalDealAmount += amount;
          }
        }
      });

      if (totalDealAmount > 0) {
        student.dealAmount = totalDealAmount;
      }
    });

    // üÜï Step 3.5: ÈáçÊñ∞Ë®àÁÆóÁõÆÂâçÁãÄÊÖãÔºàÂü∫ÊñºÊñ∞ÁöÑÈÇèËºØÔºâ
    // ÂÑ™ÂÖàÁ¥öÔºöÂ∑≤ËΩâÈ´ò > Êú™ËΩâÈ´ò > È´îÈ©ó‰∏≠ > Êú™ÈñãÂßã
    studentMap.forEach((student) => {
      const hasAttendance = student.classDates.length > 0;
      const hasHighLevelDeal = student.dealAmount > 0;
      const noRemainingClasses = student.remainingTrialClasses === 0;

      if (hasHighLevelDeal) {
        // 1. ÂÑ™ÂÖàÁ¥öÊúÄÈ´òÔºöÊúâÊàê‰∫§Ë®òÈåÑ ‚Üí Â∑≤ËΩâÈ´ò
        student.currentStatus = 'Â∑≤ËΩâÈ´ò';
      } else if (noRemainingClasses && hasAttendance) {
        // 2. Ââ©È§òÂ†ÇÊï∏ = 0 ‰∏îÊ≤íÊúâÊàê‰∫§ ‚Üí Êú™ËΩâÈ´ò
        student.currentStatus = 'Êú™ËΩâÈ´ò';
      } else if (hasAttendance) {
        // 3. ÊúâÊâìÂç°Ë®òÈåÑ ‚Üí È´îÈ©ó‰∏≠
        student.currentStatus = 'È´îÈ©ó‰∏≠';
      } else {
        // 4. Ê≤íÊúâÊâìÂç°Ë®òÈåÑ ‚Üí Êú™ÈñãÂßã
        student.currentStatus = 'Êú™ÈñãÂßã';
      }
    });

    // Step 4: Assemble final insights with calculated fields
    studentMap.forEach((student) => {
      // Calculate first and last class dates
      student.classDates.sort((a: Date, b: Date) => a.getTime() - b.getTime());
      const firstClassDate = student.classDates.length > 0
        ? format(student.classDates[0], 'yyyy-MM-dd')
        : student.purchaseDate || format(new Date(), 'yyyy-MM-dd');
      const lastClassDate = student.classDates.length > 0
        ? format(student.classDates[student.classDates.length - 1], 'yyyy-MM-dd')
        : undefined;

      // Âæû teacherHistory ‰∏≠ÊâæÂá∫ÊúÄËøë‰∏ÄÊ¨°‰∏äË™≤ÁöÑÊïôÂ∏´
      if (student.teacherHistory && student.teacherHistory.length > 0) {
        // ÊåâÊó•ÊúüÊéíÂ∫èÔºåÊúÄËøëÁöÑÂú®ÊúÄÂæå
        student.teacherHistory.sort((a: any, b: any) => a.date.getTime() - b.date.getTime());
        const latestTeacher = student.teacherHistory[student.teacherHistory.length - 1];
        student.teacherName = latestTeacher.teacher;
      }

      // Map status: Êú™ÈñãÂßã‚Üípending, È´îÈ©ó‰∏≠‚Üícontacted, Êú™ËΩâÈ´ò‚Üílost, Â∑≤ËΩâÈ´ò‚Üíconverted
      let mappedStatus: 'pending' | 'contacted' | 'converted' | 'lost' = 'pending';
      if (student.currentStatus === 'Â∑≤ËΩâÈ´ò') {
        mappedStatus = 'converted';
      } else if (student.currentStatus === 'Êú™ËΩâÈ´ò') {
        mappedStatus = 'lost';
      } else if (student.currentStatus === 'È´îÈ©ó‰∏≠') {
        mappedStatus = 'contacted';
      } else if (student.currentStatus === 'Êú™ÈñãÂßã') {
        mappedStatus = 'pending';
      }

      // Adjust intent score based on status if not set from attendance
      if (student.intentScore === 50) {
        student.intentScore = mappedStatus === 'converted' ? 85
          : mappedStatus === 'contacted' ? 70
          : mappedStatus === 'lost' ? 30
          : 50;
      }

      insights.push({
        studentId: student.studentId,
        studentName: student.studentName,
        email: student.email,
        classDate: firstClassDate,
        teacherName: student.teacherName || 'Êú™Áü•ÊïôÂ∏´',
        status: mappedStatus,
        intentScore: student.intentScore,
        recommendedAction: this.getRecommendedAction(mappedStatus, student.intentScore),
        dealAmount: student.dealAmount,
        totalTrialClasses: student.totalTrialClasses,
        remainingTrialClasses: student.remainingTrialClasses,
        attendedClasses: student.attendedClasses,
        lastClassDate,
        currentStatus: student.currentStatus,
        packageName: student.packageName,
        purchaseDate: student.purchaseDate,
      });
    });

    if (insights.length < purchaseData.length) {
      warnings.push(`${purchaseData.length - insights.length} Á≠ÜË≥ºË≤∑Ë®òÈåÑÁº∫Â∞ëÂ≠∏Âì°‰ø°ÁÆ±`);
    }

    return insights;
  }

  /**
   * ÂèñÂæóÂª∫Ë≠∞Ë°åÂãï
   */
  private getRecommendedAction(status: string, intentScore: number): string {
    if (status === 'converted') return 'Â∑≤Êàê‰∫§ÔºåÈÄ≤Ë°åÂæåÁ∫åÊúçÂãô';
    if (status === 'contacted') return 'ËøΩËπ§Ë≥ºË≤∑ÈÄ≤Â∫¶';
    if (intentScore > 80) return 'Á´ãÂç≥ËÅØÁπ´ÔºåÈ´òÊÑèÈ°òÂ≠∏Âì°';
    if (intentScore > 60) return '24Â∞èÊôÇÂÖßËÅØÁπ´';
    return 'ËßÄÂØüÊÑèÈ°òÔºåÈÅ©ÊôÇË∑üÈÄ≤';
  }

  /**
   * Ë®àÁÆóÊºèÊñóÊï∏ÊìöÔºàÂü∫ÊñºÂ≠∏ÁîüÁãÄÊÖãÔºâ
   */
  private calculateFunnelData(purchaseData: any[]): TotalReportData['funnelData'] {
    // Áµ±Ë®àÂêÑÁãÄÊÖãÁöÑÂ≠∏ÁîüÊï∏
    const statusCounts = {
      Êú™ÈñãÂßã: 0,
      È´îÈ©ó‰∏≠: 0,
      Â∑≤ËΩâÈ´ò: 0,
      Êú™ËΩâÈ´ò: 0,
    };

    purchaseData.forEach(row => {
      const status = resolveField(row.data, 'status') ||
                     resolveField(row.data, 'currentStatus') ||
                     '';

      if (status === 'Êú™ÈñãÂßã') statusCounts.Êú™ÈñãÂßã++;
      else if (status === 'È´îÈ©ó‰∏≠') statusCounts.È´îÈ©ó‰∏≠++;
      else if (status === 'Â∑≤ËΩâÈ´ò') statusCounts.Â∑≤ËΩâÈ´ò++;
      else if (status === 'Êú™ËΩâÈ´ò') statusCounts.Êú™ËΩâÈ´ò++;
    });

    return [
      {
        stage: 'Êú™ÈñãÂßã',
        value: statusCounts.Êú™ÈñãÂßã,
        fill: 'hsl(var(--chart-1))'
      },
      {
        stage: 'È´îÈ©ó‰∏≠',
        value: statusCounts.È´îÈ©ó‰∏≠,
        fill: 'hsl(var(--chart-2))'
      },
      {
        stage: 'Â∑≤ËΩâÈ´ò',
        value: statusCounts.Â∑≤ËΩâÈ´ò,
        fill: 'hsl(var(--chart-3))',
        lostStudents: statusCounts.Êú™ËΩâÈ´ò  // Ê∑ªÂä†ÊµÅÂ§±Â≠∏ÁîüÊï∏
      },
    ];
  }

  /**
   * Ë®àÁÆóË™≤Á®ãÈ°ûÂà•ÂàÜ‰Ωà
   */
  private calculateCategoryBreakdown(purchaseData: any[]): TotalReportData['categoryBreakdown'] {
    const categoryMap = new Map<string, number>();
    const total = purchaseData.length;

    purchaseData.forEach(row => {
      const category = row.data.courseType || row.data.plan || row.data['Ë™≤Á®ãÈ°ûÂûã'] || 'Êú™ÂàÜÈ°û';
      categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
    });

    const breakdown: TotalReportData['categoryBreakdown'] = [];
    categoryMap.forEach((count, name) => {
      breakdown.push({
        name,
        value: count,
        percentage: Math.round((count / total) * 10000) / 100,
      });
    });

    return breakdown.sort((a, b) => b.value - a.value);
  }

  /**
   * Ë®àÁÆóË∂®Âã¢Êï∏Êìö
   */
  private calculateTrendData(
    period: PeriodType,
    dateRange: { start: string; end: string },
    attendanceData: any[],
    purchaseData: any[]
  ): TotalReportData['trendData'] {
    const startDate = new Date(dateRange.start);
    const endDate = new Date(dateRange.end);
    const trendData: TotalReportData['trendData'] = [];

    // Ê†πÊìöÊúüÈñìÈ°ûÂûãÁî¢Áîü‰∏çÂêåÁ≤íÂ∫¶ÁöÑÊï∏ÊìöÈªû
    if (period === 'daily') {
      // Daily: ÊåâÂ∞èÊôÇÁµ±Ë®àÔºàÁ∞°ÂåñÁâàÔºöËøîÂõûÁï∂Êó•Á∏ΩË®àÔºâ
      const dayData: Record<string, { trials: number; conversions: number; revenue: number }> = {};

      attendanceData.forEach(row => {
        const dateValue = parseDateField(resolveField(row.data, 'classDate'));
        if (dateValue) {
          const dateKey = format(dateValue, 'yyyy-MM-dd');
          if (!dayData[dateKey]) {
            dayData[dateKey] = { trials: 0, conversions: 0, revenue: 0 };
          }
          dayData[dateKey].trials++;
        }
      });

      purchaseData.forEach(row => {
        const dateValue = parseDateField(resolveField(row.data, 'purchaseDate')) ||
                          parseDateField(resolveField(row.data, 'classDate'));
        const revenueValue = parseNumberField(resolveField(row.data, 'dealAmount')) || 45000;

        if (dateValue) {
          const dateKey = format(dateValue, 'yyyy-MM-dd');
          if (!dayData[dateKey]) {
            dayData[dateKey] = { trials: 0, conversions: 0, revenue: 0 };
          }
          dayData[dateKey].conversions++;
          dayData[dateKey].revenue += revenueValue;
        }
      });

      Object.keys(dayData).sort().forEach(dateKey => {
        const data = dayData[dateKey];
        trendData.push({
          date: dateKey,
          trials: data.trials,
          conversions: data.conversions,
          revenue: data.revenue,
          contactRate: data.trials > 0 ? (data.conversions / data.trials) * 100 : 0,
        });
      });
    } else if (period === 'weekly') {
      // Weekly: ÊåâÂ§©Áµ±Ë®à
      const days = eachDayOfInterval({ start: startDate, end: endDate });

      days.forEach(day => {
        const dayKey = format(day, 'yyyy-MM-dd');

        const dayTrials = attendanceData.filter(row => {
          const dateValue = parseDateField(resolveField(row.data, 'classDate'));
          return dateValue && format(dateValue, 'yyyy-MM-dd') === dayKey;
        }).length;

        const dayPurchases = purchaseData.filter(row => {
          const dateValue = parseDateField(resolveField(row.data, 'purchaseDate')) ||
                            parseDateField(resolveField(row.data, 'classDate'));
          return dateValue && format(dateValue, 'yyyy-MM-dd') === dayKey;
        });

        const dayRevenue = dayPurchases.reduce((sum, row) => {
          const amount = parseNumberField(resolveField(row.data, 'dealAmount')) || 45000;
          return sum + amount;
        }, 0);

        trendData.push({
          date: dayKey,
          trials: dayTrials,
          conversions: dayPurchases.length,
          revenue: dayRevenue,
          contactRate: dayTrials > 0 ? (dayPurchases.length / dayTrials) * 100 : 0,
        });
      });
    } else if (period === 'monthly') {
      // Monthly: ÊåâÂ§©Áµ±Ë®à
      const days = eachDayOfInterval({ start: startDate, end: endDate });

      days.forEach(day => {
        const dayKey = format(day, 'yyyy-MM-dd');

        const dayTrials = attendanceData.filter(row => {
          const dateValue = parseDateField(resolveField(row.data, 'classDate'));
          return dateValue && format(dateValue, 'yyyy-MM-dd') === dayKey;
        }).length;

        const dayPurchases = purchaseData.filter(row => {
          const dateValue = parseDateField(resolveField(row.data, 'purchaseDate')) ||
                            parseDateField(resolveField(row.data, 'classDate'));
          return dateValue && format(dateValue, 'yyyy-MM-dd') === dayKey;
        });

        const dayRevenue = dayPurchases.reduce((sum, row) => {
          const amount = parseNumberField(resolveField(row.data, 'dealAmount')) || 45000;
          return sum + amount;
        }, 0);

        trendData.push({
          date: dayKey,
          trials: dayTrials,
          conversions: dayPurchases.length,
          revenue: dayRevenue,
          contactRate: dayTrials > 0 ? (dayPurchases.length / dayTrials) * 100 : 0,
        });
      });
    }

    // Â¶ÇÊûúÊ≤íÊúâ‰ªª‰ΩïÊï∏ÊìöÔºåËøîÂõûÊúüÈñìËµ∑ÂßãÊó•ÁöÑÁ©∫Êï∏ÊìöÈªû
    if (trendData.length === 0) {
      return [{
        date: dateRange.start,
        trials: 0,
        conversions: 0,
        revenue: 0,
        contactRate: 0,
      }];
    }

    return trendData;
  }

  /**
   * Áî¢Áîü AI Âª∫Ë≠∞ÔºàÊ†πÊìö KPI ÂãïÊÖãÁîüÊàêÔºâ
   */
  private generateAISuggestions(
    metrics: TotalReportData['summaryMetrics'],
    teachers: TotalReportData['teacherInsights'],
    students: TotalReportData['studentInsights'],
    period: PeriodType,
    previousMetrics?: any
  ): TotalReportData['aiSuggestions'] {
    const daily: string[] = [];
    const weekly: string[] = [];
    const monthly: string[] = [];
    let periodComparison: string | undefined;

    // ========================================
    // Daily Âª∫Ë≠∞ÔºàÁ´ãÂç≥Ë°åÂãïÔºâ
    // ========================================
    const highIntentStudents = students.filter(s => s.intentScore > 80 && s.status === 'pending');
    const mediumIntentStudents = students.filter(s => s.intentScore > 60 && s.intentScore <= 80 && s.status === 'pending');
    const contactedStudents = students.filter(s => s.status === 'contacted');

    if (highIntentStudents.length > 0) {
      daily.push(`üî• Á∑äÊÄ•Ôºö${highIntentStudents.length} ‰ΩçÈ´òÊÑèÈ°òÂ≠∏Âì°ÂæÖËÅØÁπ´ÔºàÊÑèÈ°òÂàÜÊï∏ > 80Ôºâ`);
    }
    if (mediumIntentStudents.length > 0) {
      daily.push(`‚ö†Ô∏è ÈáçË¶ÅÔºö${mediumIntentStudents.length} ‰Ωç‰∏≠ÊÑèÈ°òÂ≠∏Âì°Âª∫Ë≠∞ 24 Â∞èÊôÇÂÖßËÅØÁπ´`);
    }
    if (contactedStudents.length > 5) {
      daily.push(`üìû ËøΩËπ§Ôºö${contactedStudents.length} ‰ΩçÂ≠∏Âì°Â∑≤ËÅØÁπ´ÔºåÂæÖÁ¢∫Ë™çÊàê‰∫§ÁãÄÊÖã`);
    }
    if (metrics.totalTrials > 0 && metrics.totalConversions === 0) {
      daily.push(`‚ö° Ê≥®ÊÑèÔºö‰ªäÊó•Êúâ ${metrics.totalTrials} ‰ΩçÈ´îÈ©óË™≤Â≠∏Âì°Ôºå‰ΩÜÂ∞öÁÑ°Êàê‰∫§Ë®òÈåÑ`);
    }

    // ========================================
    // Weekly Âª∫Ë≠∞ÔºàÁ≠ñÁï•Ë™øÊï¥Ôºâ
    // ========================================
    if (metrics.conversionRate < 15) {
      weekly.push(`üìâ ËΩâÊèõÁéá ${metrics.conversionRate.toFixed(1)}% ‰ΩéÊñºÁõÆÊ®ôÔºà15%ÔºâÔºåÂª∫Ë≠∞Ê™¢Ë¶ñËÅØÁπ´Ë©±Ë°ìËàáÊµÅÁ®ã`);
    } else if (metrics.conversionRate > 25) {
      weekly.push(`üìà ËΩâÊèõÁéá ${metrics.conversionRate.toFixed(1)}% Ë°®ÁèæÂÑ™Áï∞ÔºåÁ∂≠ÊåÅÁï∂ÂâçÁ≠ñÁï•`);
    }

    if (metrics.avgConversionTime > 10) {
      weekly.push(`‚è∞ Âπ≥ÂùáËΩâÊèõÊôÇÈñì ${metrics.avgConversionTime} Â§©ÂÅèÈï∑ÔºåÂª∫Ë≠∞Âä†Âº∑Âç≥ÊôÇË∑üÈÄ≤`);
    } else if (metrics.avgConversionTime < 5) {
      weekly.push(`‚ö° Âπ≥ÂùáËΩâÊèõÊôÇÈñì ${metrics.avgConversionTime} Â§©ÔºåÊàê‰∫§ÈÄüÂ∫¶ÂÑ™ÁßÄ`);
    }

    if (teachers.length > 0) {
      const topTeacher = teachers[0];
      const bottomTeacher = teachers[teachers.length - 1];
      weekly.push(`üèÜ ${topTeacher.teacherName} Ë°®ÁèæÊúÄ‰Ω≥ÔºåËΩâÊèõÁéá ${topTeacher.conversionRate.toFixed(1)}%Ôºà${topTeacher.classCount} Â†ÇË™≤Ôºâ`);
      if (teachers.length > 1 && bottomTeacher.conversionRate < 10) {
        weekly.push(`üìö ${bottomTeacher.teacherName} ËΩâÊèõÁéá ${bottomTeacher.conversionRate.toFixed(1)}%ÔºåÂª∫Ë≠∞ÂÆâÊéíÂüπË®ìÊàñËßÄÊë©`);
      }
    }

    if (metrics.trialCompletionRate < 50) {
      weekly.push(`‚ö†Ô∏è È´îÈ©óË™≤ÂÆåÊàêÁéáÂÉÖ ${metrics.trialCompletionRate.toFixed(1)}%ÔºåÂª∫Ë≠∞Ê™¢Ë¶ñË™≤Á®ãÂê∏ÂºïÂäõ`);
    }

    // ========================================
    // Monthly Âª∫Ë≠∞ÔºàÈï∑ÊúüË¶èÂäÉÔºâ
    // ========================================
    if (metrics.pendingStudents > 10) {
      monthly.push(`üí∞ Êú¨ÊúàÁ¥ØÁ©ç ${metrics.pendingStudents} ‰ΩçÂæÖËøΩËπ§Â≠∏Âì°ÔºåÊΩõÂú®Êî∂Áõä NT$ ${metrics.potentialRevenue.toLocaleString()}`);
    }

    if (metrics.totalTrials < 20) {
      monthly.push(`üìä Êú¨ÊúàÈ´îÈ©óË™≤‰∫∫Êï∏ ${metrics.totalTrials} ‰ΩçÂÅè‰ΩéÔºåÂª∫Ë≠∞Âä†Âº∑ÊãõÁîüÊ¥ªÂãï`);
    } else if (metrics.totalTrials > 50) {
      monthly.push(`üéØ Êú¨ÊúàÈ´îÈ©óË™≤‰∫∫Êï∏ ${metrics.totalTrials} ‰ΩçÔºåÊãõÁîüÊàêÊïàËâØÂ•Ω`);
    }

    if (metrics.totalConversions > 0) {
      const avgRevenue = metrics.potentialRevenue / Math.max(1, metrics.pendingStudents);
      monthly.push(`üíµ Âπ≥ÂùáÂÆ¢ÂñÆÂÉπÁ¥Ñ NT$ ${avgRevenue.toLocaleString()}ÔºåÂ∑≤Êàê‰∫§ ${metrics.totalConversions} ‰Ωç`);
    }

    // Êï¥È´îË©ï‰º∞
    if (metrics.conversionRate > 20 && metrics.avgConversionTime < 7) {
      monthly.push(`üéâ Êï¥È´îË°®ÁèæÂÑ™ÁßÄÔºÅËΩâÊèõÁéáËàáÈÄüÂ∫¶ÈÉΩÈÅîÊ®ôÔºåÂª∫Ë≠∞Êì¥Â§ßÊãõÁîüË¶èÊ®°`);
    } else if (metrics.conversionRate < 10 || metrics.avgConversionTime > 14) {
      monthly.push(`üîç Âª∫Ë≠∞Ê∑±ÂÖ•ÂàÜÊûêÊµÅÂ§±ÂéüÂõ†ÔºöËΩâÊèõÁéáÊàñËΩâÊèõÊôÇÈñìÈúÄË¶ÅÊîπÂñÑ`);
    }

    // ========================================
    // üÜï AI ÊúüÈñìÂ∞çÊØîÂàÜÊûê
    // ========================================
    if (previousMetrics && metrics.comparison) {
      const insights: string[] = [];
      const { comparison } = metrics;

      // ËΩâÊèõÁéáÂàÜÊûê
      if (comparison.conversionRate) {
        const { trend, changePercent, current, previous } = comparison.conversionRate;
        if (trend === 'up' && changePercent > 10) {
          insights.push(`‚ú® ËΩâÊèõÁéáÈ°ØËëóÊèêÂçá ${Math.abs(changePercent).toFixed(1)}%Ôºà${previous.toFixed(1)}% ‚Üí ${current.toFixed(1)}%ÔºâÔºåË°®ÁèæÂÑ™Áï∞`);
        } else if (trend === 'down' && Math.abs(changePercent) > 10) {
          insights.push(`‚ö†Ô∏è ËΩâÊèõÁéá‰∏ãÈôç ${Math.abs(changePercent).toFixed(1)}%Ôºà${previous.toFixed(1)}% ‚Üí ${current.toFixed(1)}%ÔºâÔºåÈúÄË¶ÅÈóúÊ≥®`);
        } else if (trend === 'stable') {
          insights.push(`üìä ËΩâÊèõÁéáÁ∂≠ÊåÅÁ©©ÂÆöÔºà${current.toFixed(1)}%Ôºâ`);
        }
      }

      // È´îÈ©óË™≤Êï∏ÈáèÂàÜÊûê
      if (comparison.totalTrials) {
        const { trend, change, current, previous } = comparison.totalTrials;
        if (trend === 'up' && change > 5) {
          insights.push(`üìà È´îÈ©óË™≤Êï∏ÈáèÂ¢ûÂä† ${change} ‰ΩçÔºà${previous} ‚Üí ${current}ÔºâÔºåÊãõÁîüÂãïËÉΩËâØÂ•Ω`);
        } else if (trend === 'down' && Math.abs(change) > 5) {
          insights.push(`üìâ È´îÈ©óË™≤Êï∏ÈáèÊ∏õÂ∞ë ${Math.abs(change)} ‰ΩçÔºà${previous} ‚Üí ${current}ÔºâÔºåÂª∫Ë≠∞Âä†Âº∑ÊãõÁîü`);
        }
      }

      // Êàê‰∫§Êï∏ÂàÜÊûê
      if (comparison.totalConversions) {
        const { trend, change, current, previous } = comparison.totalConversions;
        if (trend === 'up' && change > 0) {
          insights.push(`üí∞ Êàê‰∫§Êï∏Â¢ûÂä† ${change} ‰ΩçÔºà${previous} ‚Üí ${current}Ôºâ`);
        } else if (trend === 'down' && change < 0) {
          insights.push(`‚ö†Ô∏è Êàê‰∫§Êï∏Ê∏õÂ∞ë ${Math.abs(change)} ‰ΩçÔºà${previous} ‚Üí ${current}Ôºâ`);
        }
      }

      // ÂÆåË™≤ÁéáÂàÜÊûê
      if (comparison.trialCompletionRate) {
        const { trend, changePercent, current, previous } = comparison.trialCompletionRate;
        if (trend === 'up' && changePercent > 5) {
          insights.push(`üëç ÂÆåË™≤ÁéáÊèêÂçáÔºà${previous.toFixed(1)}% ‚Üí ${current.toFixed(1)}%ÔºâÔºåÂ≠∏Âì°ÂèÉËàáÂ∫¶ÊèêÈ´ò`);
        } else if (trend === 'down' && Math.abs(changePercent) > 5) {
          insights.push(`üìå ÂÆåË™≤Áéá‰∏ãÈôçÔºà${previous.toFixed(1)}% ‚Üí ${current.toFixed(1)}%ÔºâÔºåÂª∫Ë≠∞Ê™¢Ë¶ñË™≤Á®ãÂÆâÊéí`);
        }
      }

      // Á∂úÂêàÂª∫Ë≠∞
      if (insights.length === 0) {
        periodComparison = 'üìä Êú¨ÊúüËàáÂâçÊúüË°®ÁèæÁõ∏ËøëÔºåÂª∫Ë≠∞ÊåÅÁ∫åÂÑ™ÂåñÁèæÊúâÊµÅÁ®ã„ÄÇ';
      } else if (insights.filter(i => i.includes('‚ú®') || i.includes('üìà') || i.includes('üí∞')).length >= 2) {
        periodComparison = `üéâ Êï¥È´îË°®ÁèæÂêë‰∏äÔºÅ${insights.join('Ôºõ')}„ÄÇË´ãÁπºÁ∫å‰øùÊåÅ‰∏¶ÂàÜ‰∫´ÊàêÂäüÁ∂ìÈ©ó„ÄÇ`;
      } else if (insights.filter(i => i.includes('‚ö†Ô∏è') || i.includes('üìâ')).length >= 2) {
        periodComparison = `‚ö†Ô∏è Â§öÈ†ÖÊåáÊ®ô‰∏ãÊªë„ÄÇ${insights.join('Ôºõ')}„ÄÇÂª∫Ë≠∞Âè¨ÈñãÂúòÈöäÊúÉË≠∞Ê™¢Ë®éÊîπÂñÑÊñπÊ°à„ÄÇ`;
      } else {
        periodComparison = insights.join('Ôºõ') + '„ÄÇ';
      }
    }

    return { daily, weekly, monthly, periodComparison };
  }

  /**
   * Convert Supabase data to internal format
   */
  private convertSupabaseToInternalFormat(supabaseData: SupabaseDataRow[]): any[] {
    return supabaseData.map(row => {
      // Parse dealAmount from raw_data if not in normalized fields
      let dealAmount = row.deal_amount;
      if (!dealAmount && row.raw_data) {
        const rawAmount = resolveField(row.raw_data, 'dealAmount');
        dealAmount = parseNumberField(rawAmount) || undefined;
      }

      return {
        id: row.id,
        data: {
          // Use normalized fields from Supabase
          studentName: row.student_name,
          studentEmail: row.student_email,
          teacher: row.teacher_name || row.teacher_name,
          teacherName: row.teacher_name,
          classDate: row.class_date,
          purchaseDate: row.purchase_date,
          dealDate: row.deal_date,
          courseType: row.course_type,
          dealAmount: dealAmount,  // Use parsed amount
          status: row.status,
          intentScore: row.intent_score,
          satisfaction: row.satisfaction,
          attended: row.attended,
          plan: row.plan,
          // Include original raw_data for any additional fields
          ...row.raw_data,
        },
        lastUpdated: new Date(row.synced_at),
      };
    });
  }

  /**
   * Ê†πÊìöÁî®Êà∂Ê¨äÈôêÈÅéÊøæË≥áÊñô
   */
  private async filterDataByPermission(data: any[], userId: string, tableName: string): Promise<any[]> {
    try {
      // ÈñãÁôºÊ®°ÂºèË∑≥ÈÅéÊ¨äÈôêÈÅéÊøæ
      if (process.env.SKIP_AUTH === 'true') {
        console.log(`[Permission Filter] SKIP_AUTH enabled - no filtering`);
        return data;
      }

      // ÂèñÂæó‰ΩøÁî®ËÄÖË≥áË®äÔºàÂåÖÂê´Ê•≠ÂãôË∫´‰ªΩÔºâ
      const userResult = await queryDatabase('SELECT id, roles FROM users WHERE id = $1', [userId]);

      if (userResult.rows.length === 0) {
        console.warn(`User not found: ${userId}`);
        return [];
      }

      const user = userResult.rows[0];
      const userRoles: string[] = user.roles || [];

      // Â¶ÇÊûúÊòØ admin Êàñ managerÔºåÁúãÊâÄÊúâË≥áÊñô
      if (userRoles.includes('admin') || userRoles.includes('super_admin') || userRoles.includes('manager')) {
        console.log(`[Permission Filter] Admin/Manager user ${userId} - no filtering`);
        return data;
      }

      // ÂèñÂæó‰∏ªË¶ÅËßíËâ≤ÔºàÁî®ÊñºÈÅéÊøæÈÇèËºØÔºâ
      const primaryRole = userRoles.find(r => ['teacher', 'consultant', 'setter'].includes(r)) || userRoles[0];

      // ÂèñÂæóÊ•≠ÂãôË∫´‰ªΩ
      const identitiesResult = await queryDatabase(`
        SELECT identity_type, identity_code
        FROM business_identities
        WHERE user_id = $1 AND is_active = true
      `, [userId]);

      const identities: { [key: string]: string[] } = {};
      identitiesResult.rows.forEach((row: any) => {
        const type = row.identity_type;
        if (!identities[type]) {
          identities[type] = [];
        }
        identities[type].push(row.identity_code);
      });

      console.log(`[Permission Filter] User ${userId} primaryRole=${primaryRole}, roles=${userRoles.join(',')}, identities:`, identities);

      // Ê†πÊìöË≥áÊñôË°®È°ûÂûãÈÄ≤Ë°åÈÅéÊøæÔºàÈúÄË¶Å awaitÔºåÂõ†ÁÇ∫ matchTrialClassAttendance ÊòØ asyncÔºâ
      const filteredData: any[] = [];
      for (const item of data) {
        const itemData = item.data || item;
        let matches = false;

        switch (tableName) {
          case 'trial_class_attendance':
            matches = await this.matchTrialClassAttendance(itemData, primaryRole, userRoles, identities, userId);
            break;

          case 'trial_class_purchases':
            matches = await this.matchTrialClassPurchases(itemData, primaryRole, userRoles, identities, userId);
            break;

          case 'telemarketing_calls':
            matches = this.matchTelemarketingCalls(itemData, primaryRole, userRoles, identities, userId);
            break;

          default:
            // È†êË®≠ÔºöÂè™ÁúãËá™Â∑±ÂâµÂª∫ÁöÑ
            matches = itemData.created_by === userId;
        }

        if (matches) {
          filteredData.push(item);
        }
      }

      console.log(`[Permission Filter] ${tableName}: ${data.length} -> ${filteredData.length} records`);
      return filteredData;

    } catch (error) {
      console.error('Error filtering data by permission:', error);
      // ÁôºÁîüÈåØË™§ÊôÇÔºåÁÇ∫‰∫ÜÂÆâÂÖ®Ëµ∑Ë¶ãÔºåÂõûÂÇ≥Á©∫Èô£Âàó
      return [];
    }
  }

  /**
   * Ê™¢Êü•È´îÈ©óË™≤Âá∫Â∏≠Ë®òÈåÑÊòØÂê¶Á¨¶ÂêàÊ¨äÈôê
   */
  private async matchTrialClassAttendance(item: any, primaryRole: string, allRoles: string[], identities: any, userId: string): Promise<boolean> {
    // Manager ÁúãÊâÄÊúâ
    if (allRoles.includes('manager')) {
      return true;
    }

    // Teacher ÁúãËá™Â∑±ÁöÑË™≤
    if (allRoles.includes('teacher')) {
      const teacherCode = item.teacher_code || item.teacherCode || item.raw_data?.teacher_code;

      // Â¶ÇÊûúÊúâ teacher_codeÔºåÊØîÂ∞ç teacher_code
      if (teacherCode && identities.teacher && identities.teacher.includes(teacherCode)) {
        return true;
      }

      // Â¶ÇÊûúÊ≤íÊúâ teacher_codeÔºåÊØîÂ∞ç teacher_name
      const teacherName = item.teacher_name || item.teacherName || item.raw_data?.teacher_name || item.raw_data?.ÊéàË™≤ËÄÅÂ∏´;
      if (teacherName) {
        // ÂèñÂæóË©≤ teacher_name Â∞çÊáâÁöÑ‰ΩøÁî®ËÄÖ
        const userResult = await queryDatabase('SELECT id, first_name FROM users WHERE id = $1', [userId]);
        if (userResult.rows.length > 0) {
          const userName = userResult.rows[0].first_name;
          if (teacherName.includes(userName)) {
            return true;
          }
        }
      }
    }

    // Consultant ÁúãËá™Â∑±ÁöÑÂ≠∏Áîü
    if (allRoles.includes('consultant')) {
      const consultantCode = item.consultant_code || item.consultantCode || item.raw_data?.consultant_code;
      if (consultantCode && identities.consultant && identities.consultant.includes(consultantCode)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Ê™¢Êü•Ë≥ºË≤∑Ë®òÈåÑÊòØÂê¶Á¨¶ÂêàÊ¨äÈôê
   */
  private async matchTrialClassPurchases(item: any, primaryRole: string, allRoles: string[], identities: any, userId: string): Promise<boolean> {
    // Manager ÁúãÊâÄÊúâ
    if (allRoles.includes('manager')) {
      return true;
    }

    // Ê™¢Êü•Ë≥ºË≤∑Ë®òÈåÑ‰∏≠ÁöÑÊïôÂ∏´/Ë´ÆË©¢Â∏´Ë≥áË®ä
    const teacherCode = item.teacher_code || item.teacherCode || item.raw_data?.teacher_code;
    const consultantCode = item.consultant_code || item.consultantCode || item.raw_data?.consultant_code;
    const studentName = item.student_name || item.studentName || item.raw_data?.student_name || item.raw_data?.Â≠∏Âì°ÂßìÂêç;

    // Teacher ÁúãËá™Â∑±Áõ∏ÈóúÁöÑË≥ºË≤∑Ë®òÈåÑ
    if (allRoles.includes('teacher')) {
      // ÊñπÊ≥ï1: ÈÄöÈÅé teacher_code ÈÅéÊøæ
      if (teacherCode && identities.teacher && identities.teacher.includes(teacherCode)) {
        return true;
      }

      // ÊñπÊ≥ï2: Â¶ÇÊûúÊ≤íÊúâ teacher_codeÔºåÂòóË©¶ÈÄöÈÅéÂ≠∏ÁîüÂßìÂêçÈóúËÅØÂà∞Âá∫Â∏≠Ë®òÈåÑ
      if (studentName) {
        try {
          const attendanceResult = await queryDatabase(`
            SELECT teacher_code, teacher_name
            FROM trial_class_attendance
            WHERE student_name = $1
            LIMIT 1
          `, [studentName]);

          if (attendanceResult.rows.length > 0) {
            const attendanceTeacherCode = attendanceResult.rows[0].teacher_code;
            if (attendanceTeacherCode && identities.teacher && identities.teacher.includes(attendanceTeacherCode)) {
              return true;
            }
          }
        } catch (error) {
          console.error('Error querying attendance for purchase filtering:', error);
        }
      }
    }

    // Consultant ÁúãËá™Â∑±Áõ∏ÈóúÁöÑË≥ºË≤∑Ë®òÈåÑ
    if (allRoles.includes('consultant')) {
      if (consultantCode && identities.consultant && identities.consultant.includes(consultantCode)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Ê™¢Êü•ÈõªË®™Ë®òÈåÑÊòØÂê¶Á¨¶ÂêàÊ¨äÈôê
   */
  private matchTelemarketingCalls(item: any, primaryRole: string, allRoles: string[], identities: any, userId: string): boolean {
    // Manager ÁúãÊâÄÊúâ
    if (allRoles.includes('manager')) {
      return true;
    }

    // Consultant ÁúãËá™Â∑±ÁöÑÈõªË®™
    if (allRoles.includes('consultant')) {
      const consultantCode = item.closer_code || item.closerCode;
      if (consultantCode && identities.consultant && identities.consultant.includes(consultantCode)) {
        return true;
      }
    }

    // Setter ÁúãËá™Â∑±ÁöÑÈõªË®™
    if (allRoles.includes('setter')) {
      const setterCode = item.setter_code || item.setterCode;
      if (setterCode && identities.setter && identities.setter.includes(setterCode)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Âà§Êñ∑ÊòØÂê¶ÈúÄË¶ÅÂèñÂæóÂâç‰∏ÄÊôÇÊÆµË≥áÊñô
   */
  private shouldFetchPreviousPeriod(period: PeriodType): boolean {
    // 'all' Âíå 'custom' ‰∏çÈúÄË¶ÅÂ∞çÊØî
    return !['all', 'custom'].includes(period);
  }

  /**
   * Ë®àÁÆóÂâç‰∏ÄÊôÇÊÆµÁöÑÊó•ÊúüÁØÑÂúç
   */
  private getPreviousPeriodDateRange(period: PeriodType, baseDate: Date): { start: string; end: string } {
    switch (period) {
      case 'daily':
      case 'day':
        const previousDay = subDays(baseDate, 1);
        return {
          start: format(previousDay, 'yyyy-MM-dd'),
          end: format(previousDay, 'yyyy-MM-dd'),
        };
      case 'weekly':
      case 'week':
        const previousWeekDate = subWeeks(baseDate, 1);
        return {
          start: format(startOfWeek(previousWeekDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
          end: format(endOfWeek(previousWeekDate, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
        };
      case 'lastWeek':
        // lastWeek ÁöÑÂâç‰∏ÄÊúüÊòØÂÖ©ÈÄ±Ââç
        const twoWeeksAgo = subWeeks(baseDate, 2);
        return {
          start: format(startOfWeek(twoWeeksAgo, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
          end: format(endOfWeek(twoWeeksAgo, { weekStartsOn: 1 }), 'yyyy-MM-dd'),
        };
      case 'monthly':
      case 'month':
        const previousMonth = subMonths(baseDate, 1);
        return {
          start: format(startOfMonth(previousMonth), 'yyyy-MM-dd'),
          end: format(endOfMonth(previousMonth), 'yyyy-MM-dd'),
        };
      default:
        return {
          start: format(startOfMonth(baseDate), 'yyyy-MM-dd'),
          end: format(endOfMonth(baseDate), 'yyyy-MM-dd'),
        };
    }
  }

  /**
   * Ë®àÁÆóÊåáÊ®ôÊØîËºÉ
   */
  private calculateMetricComparison(current: number, previous: number): {
    current: number;
    previous: number;
    change: number;
    changePercent: number;
    trend: 'up' | 'down' | 'stable';
  } {
    const change = current - previous;
    const changePercent = previous !== 0 ? (change / previous) * 100 : 0;
    let trend: 'up' | 'down' | 'stable' = 'stable';

    if (Math.abs(changePercent) < 1) {
      trend = 'stable';
    } else if (change > 0) {
      trend = 'up';
    } else {
      trend = 'down';
    }

    return {
      current,
      previous,
      change,
      changePercent,
      trend
    };
  }
}

export const totalReportService = new TotalReportService();
